diff --git a/include/fcl/broadphase/broadphase_SSaP-inl.h b/include/fcl/broadphase/broadphase_SSaP-inl.h
index ad859ea..3a7080a 100644
--- a/include/fcl/broadphase/broadphase_SSaP-inl.h
+++ b/include/fcl/broadphase/broadphase_SSaP-inl.h
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -85,7 +85,7 @@ struct SortByZLow
 
 /** @brief Dummy collision object with a point AABB<S> */
 template <typename S>
-class FCL_EXPORT DummyCollisionObject : public CollisionObject<S>
+class DummyCollisionObject : public CollisionObject<S>
 {
 public:
   DummyCollisionObject(const AABB<S>& aabb_) : CollisionObject<S>(std::shared_ptr<CollisionGeometry<S>>())
diff --git a/include/fcl/broadphase/broadphase_SSaP.h b/include/fcl/broadphase/broadphase_SSaP.h
index b0cc0a9..1d0225e 100644
--- a/include/fcl/broadphase/broadphase_SSaP.h
+++ b/include/fcl/broadphase/broadphase_SSaP.h
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -44,9 +44,9 @@
 namespace fcl
 {
 
-/// @brief Simple SAP collision manager 
+/// @brief Simple SAP collision manager
 template <typename S>
-class FCL_EXPORT SSaPCollisionManager : public BroadPhaseCollisionManager<S>
+class SSaPCollisionManager : public BroadPhaseCollisionManager<S>
 {
 public:
   SSaPCollisionManager();
@@ -89,7 +89,7 @@ public:
 
   /// @brief whether the manager is empty
   bool empty() const;
-  
+
   /// @brief the number of objects managed by the manager
   size_t size() const;
 
@@ -97,13 +97,13 @@ protected:
   /// @brief check collision between one object and a list of objects, return value is whether stop is possible
   bool checkColl(typename std::vector<CollisionObject<S>*>::const_iterator pos_start, typename std::vector<CollisionObject<S>*>::const_iterator pos_end,
                  CollisionObject<S>* obj, void* cdata, CollisionCallBack<S> callback) const;
-  
+
   /// @brief check distance between one object and a list of objects, return value is whether stop is possible
   bool checkDis(typename std::vector<CollisionObject<S>*>::const_iterator pos_start, typename std::vector<CollisionObject<S>*>::const_iterator pos_end,
                 CollisionObject<S>* obj, void* cdata, DistanceCallBack<S> callback, S& min_dist) const;
 
   bool collide_(CollisionObject<S>* obj, void* cdata, CollisionCallBack<S> callback) const;
-  
+
   bool distance_(CollisionObject<S>* obj, void* cdata, DistanceCallBack<S> callback, S& min_dist) const;
 
   static size_t selectOptimalAxis(
diff --git a/include/fcl/broadphase/broadphase_SaP-inl.h b/include/fcl/broadphase/broadphase_SaP-inl.h
index 7d201c7..8c2382d 100644
--- a/include/fcl/broadphase/broadphase_SaP-inl.h
+++ b/include/fcl/broadphase/broadphase_SaP-inl.h
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
diff --git a/include/fcl/broadphase/broadphase_SaP.h b/include/fcl/broadphase/broadphase_SaP.h
index 8a6b611..e5b210c 100644
--- a/include/fcl/broadphase/broadphase_SaP.h
+++ b/include/fcl/broadphase/broadphase_SaP.h
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -48,7 +48,7 @@ namespace fcl
 
 /// @brief Rigorous SAP collision manager
 template <typename S>
-class FCL_EXPORT SaPCollisionManager : public BroadPhaseCollisionManager<S>
+class SaPCollisionManager : public BroadPhaseCollisionManager<S>
 {
 public:
 
@@ -103,7 +103,7 @@ public:
 
   /// @brief whether the manager is empty
   bool empty() const;
-  
+
   /// @brief the number of objects managed by the manager
   size_t size() const;
 
@@ -119,10 +119,10 @@ protected:
   struct SaPPair;
 
   /// @brief Functor to help unregister one object
-  class FCL_EXPORT isUnregistered;
+  class isUnregistered;
 
   /// @brief Functor to help remove collision pairs no longer valid (i.e., should be culled away)
-  class FCL_EXPORT isNotValidPair;
+  class isNotValidPair;
 
   void update_(SaPAABB* updated_aabb);
 
@@ -130,7 +130,7 @@ protected:
 
   /// @brief End point list for x, y, z coordinates
   EndPoint* elist[3];
-  
+
   /// @brief vector version of elist, for acceleration
   std::vector<EndPoint*> velist[3];
 
@@ -215,7 +215,7 @@ struct SaPCollisionManager<S>::SaPPair
 
 /// @brief Functor to help unregister one object
 template <typename S>
-class FCL_EXPORT SaPCollisionManager<S>::isUnregistered
+class SaPCollisionManager<S>::isUnregistered
 {
   CollisionObject<S>* obj;
 
@@ -227,7 +227,7 @@ public:
 
 /// @brief Functor to help remove collision pairs no longer valid (i.e., should be culled away)
 template <typename S>
-class FCL_EXPORT SaPCollisionManager<S>::isNotValidPair
+class SaPCollisionManager<S>::isNotValidPair
 {
   CollisionObject<S>* obj1;
   CollisionObject<S>* obj2;
diff --git a/include/fcl/broadphase/broadphase_bruteforce-inl.h b/include/fcl/broadphase/broadphase_bruteforce-inl.h
index 0c92ace..2a3ec27 100644
--- a/include/fcl/broadphase/broadphase_bruteforce-inl.h
+++ b/include/fcl/broadphase/broadphase_bruteforce-inl.h
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
diff --git a/include/fcl/broadphase/broadphase_bruteforce.h b/include/fcl/broadphase/broadphase_bruteforce.h
index f8ce6c5..322576b 100644
--- a/include/fcl/broadphase/broadphase_bruteforce.h
+++ b/include/fcl/broadphase/broadphase_bruteforce.h
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -46,7 +46,7 @@ namespace fcl
 
 /// @brief Brute force N-body collision manager
 template <typename S>
-class FCL_EXPORT NaiveCollisionManager : public BroadPhaseCollisionManager<S>
+class NaiveCollisionManager : public BroadPhaseCollisionManager<S>
 {
 public:
   NaiveCollisionManager();
@@ -92,7 +92,7 @@ public:
 
   /// @brief whether the manager is empty
   bool empty() const;
-  
+
   /// @brief the number of objects managed by the manager
   size_t size() const;
 
diff --git a/include/fcl/broadphase/broadphase_collision_manager.h b/include/fcl/broadphase/broadphase_collision_manager.h
index c372c7a..6c4306a 100644
--- a/include/fcl/broadphase/broadphase_collision_manager.h
+++ b/include/fcl/broadphase/broadphase_collision_manager.h
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -63,7 +63,7 @@ using DistanceCallBack = bool (*)(
 /// collision/distance between N objects. Also support self collision, self
 /// distance and collision/distance with another M objects.
 template <typename S>
-class FCL_EXPORT BroadPhaseCollisionManager
+class BroadPhaseCollisionManager
 {
 public:
   BroadPhaseCollisionManager();
@@ -117,7 +117,7 @@ public:
 
   /// @brief whether the manager is empty
   virtual bool empty() const = 0;
-  
+
   /// @brief the number of objects managed by the manager
   virtual size_t size() const = 0;
 
diff --git a/include/fcl/broadphase/broadphase_continuous_collision_manager.h b/include/fcl/broadphase/broadphase_continuous_collision_manager.h
index d0a0435..f9950eb 100644
--- a/include/fcl/broadphase/broadphase_continuous_collision_manager.h
+++ b/include/fcl/broadphase/broadphase_continuous_collision_manager.h
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -63,7 +63,7 @@ using ContinuousDistanceCallBack = bool (*)(
 /// accelerate the continuous collision/distance between N objects. Also support
 /// self collision, self distance and collision/distance with another M objects.
 template <typename S>
-class FCL_EXPORT BroadPhaseContinuousCollisionManager
+class BroadPhaseContinuousCollisionManager
 {
 public:
   BroadPhaseContinuousCollisionManager();
@@ -117,7 +117,7 @@ public:
 
   /// @brief whether the manager is empty
   virtual bool empty() const = 0;
-  
+
   /// @brief the number of objects managed by the manager
   virtual size_t size() const = 0;
 };
diff --git a/include/fcl/broadphase/broadphase_dynamic_AABB_tree-inl.h b/include/fcl/broadphase/broadphase_dynamic_AABB_tree-inl.h
index 1a7341b..aada05d 100644
--- a/include/fcl/broadphase/broadphase_dynamic_AABB_tree-inl.h
+++ b/include/fcl/broadphase/broadphase_dynamic_AABB_tree-inl.h
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -59,7 +59,6 @@ namespace dynamic_AABB_tree {
 #if FCL_HAVE_OCTOMAP
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool collisionRecurse_(
     typename DynamicAABBTreeCollisionManager<S>::DynamicAABBNode* root1,
     const OcTree<S>* tree2,
@@ -171,7 +170,6 @@ bool collisionRecurse_(
 
 //==============================================================================
 template <typename S, typename Derived>
-FCL_EXPORT
 bool collisionRecurse_(
     typename DynamicAABBTreeCollisionManager<S>::DynamicAABBNode* root1,
     const OcTree<S>* tree2,
@@ -278,7 +276,6 @@ bool collisionRecurse_(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool distanceRecurse_(
     typename DynamicAABBTreeCollisionManager<S>::DynamicAABBNode* root1,
     const OcTree<S>* tree2,
@@ -369,7 +366,6 @@ bool distanceRecurse_(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool collisionRecurse(
     typename DynamicAABBTreeCollisionManager<S>::DynamicAABBNode* root1,
     const OcTree<S>* tree2,
@@ -387,7 +383,6 @@ bool collisionRecurse(
 
 //==============================================================================
 template <typename S, typename Derived>
-FCL_EXPORT
 bool distanceRecurse_(
     typename DynamicAABBTreeCollisionManager<S>::DynamicAABBNode* root1,
     const OcTree<S>* tree2,
@@ -477,7 +472,6 @@ bool distanceRecurse_(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool distanceRecurse(typename DynamicAABBTreeCollisionManager<S>::DynamicAABBNode* root1, const OcTree<S>* tree2, const typename OcTree<S>::OcTreeNode* root2, const AABB<S>& root2_bv, const Transform3<S>& tf2, void* cdata, DistanceCallBack<S> callback, S& min_dist)
 {
   if(tf2.linear().isIdentity())
@@ -490,7 +484,6 @@ bool distanceRecurse(typename DynamicAABBTreeCollisionManager<S>::DynamicAABBNod
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool collisionRecurse(
     typename DynamicAABBTreeCollisionManager<S>::DynamicAABBNode* root1,
     typename DynamicAABBTreeCollisionManager<S>::DynamicAABBNode* root2,
@@ -524,7 +517,6 @@ bool collisionRecurse(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool collisionRecurse(typename DynamicAABBTreeCollisionManager<S>::DynamicAABBNode* root, CollisionObject<S>* query, void* cdata, CollisionCallBack<S> callback)
 {
   if(root->isLeaf())
@@ -548,7 +540,6 @@ bool collisionRecurse(typename DynamicAABBTreeCollisionManager<S>::DynamicAABBNo
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool selfCollisionRecurse(typename DynamicAABBTreeCollisionManager<S>::DynamicAABBNode* root, void* cdata, CollisionCallBack<S> callback)
 {
   if(root->isLeaf()) return false;
@@ -567,7 +558,6 @@ bool selfCollisionRecurse(typename DynamicAABBTreeCollisionManager<S>::DynamicAA
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool distanceRecurse(
     typename DynamicAABBTreeCollisionManager<S>::DynamicAABBNode* root1,
     typename DynamicAABBTreeCollisionManager<S>::DynamicAABBNode* root2,
@@ -656,7 +646,6 @@ bool distanceRecurse(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool distanceRecurse(typename DynamicAABBTreeCollisionManager<S>::DynamicAABBNode* root, CollisionObject<S>* query, void* cdata, DistanceCallBack<S> callback, S& min_dist)
 {
   if(root->isLeaf())
@@ -702,7 +691,6 @@ bool distanceRecurse(typename DynamicAABBTreeCollisionManager<S>::DynamicAABBNod
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool selfDistanceRecurse(typename DynamicAABBTreeCollisionManager<S>::DynamicAABBNode* root, void* cdata, DistanceCallBack<S> callback, S& min_dist)
 {
   if(root->isLeaf()) return false;
@@ -725,7 +713,6 @@ bool selfDistanceRecurse(typename DynamicAABBTreeCollisionManager<S>::DynamicAAB
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 DynamicAABBTreeCollisionManager<S>::DynamicAABBTreeCollisionManager()
   : tree_topdown_balance_threshold(dtree.bu_threshold),
     tree_topdown_level(dtree.topdown_level)
@@ -744,7 +731,6 @@ DynamicAABBTreeCollisionManager<S>::DynamicAABBTreeCollisionManager()
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager<S>::registerObjects(
     const std::vector<CollisionObject<S>*>& other_objs)
 {
@@ -777,7 +763,6 @@ void DynamicAABBTreeCollisionManager<S>::registerObjects(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager<S>::registerObject(CollisionObject<S>* obj)
 {
   DynamicAABBNode* node = dtree.insert(obj->getAABB(), obj);
@@ -786,7 +771,6 @@ void DynamicAABBTreeCollisionManager<S>::registerObject(CollisionObject<S>* obj)
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager<S>::unregisterObject(CollisionObject<S>* obj)
 {
   DynamicAABBNode* node = table[obj];
@@ -796,7 +780,6 @@ void DynamicAABBTreeCollisionManager<S>::unregisterObject(CollisionObject<S>* ob
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager<S>::setup()
 {
   if(!setup_)
@@ -822,7 +805,6 @@ void DynamicAABBTreeCollisionManager<S>::setup()
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager<S>::update()
 {
   for(auto it = table.cbegin(); it != table.cend(); ++it)
@@ -840,7 +822,6 @@ void DynamicAABBTreeCollisionManager<S>::update()
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager<S>::update_(CollisionObject<S>* updated_obj)
 {
   const auto it = table.find(updated_obj);
@@ -855,7 +836,6 @@ void DynamicAABBTreeCollisionManager<S>::update_(CollisionObject<S>* updated_obj
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager<S>::update(CollisionObject<S>* updated_obj)
 {
   update_(updated_obj);
@@ -864,7 +844,6 @@ void DynamicAABBTreeCollisionManager<S>::update(CollisionObject<S>* updated_obj)
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager<S>::update(const std::vector<CollisionObject<S>*>& updated_objs)
 {
   for(size_t i = 0, size = updated_objs.size(); i < size; ++i)
@@ -874,7 +853,6 @@ void DynamicAABBTreeCollisionManager<S>::update(const std::vector<CollisionObjec
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager<S>::clear()
 {
   dtree.clear();
@@ -883,7 +861,6 @@ void DynamicAABBTreeCollisionManager<S>::clear()
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager<S>::getObjects(std::vector<CollisionObject<S>*>& objs) const
 {
   objs.resize(this->size());
@@ -892,7 +869,6 @@ void DynamicAABBTreeCollisionManager<S>::getObjects(std::vector<CollisionObject<
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager<S>::collide(CollisionObject<S>* obj, void* cdata, CollisionCallBack<S> callback) const
 {
   if(size() == 0) return;
@@ -918,7 +894,6 @@ void DynamicAABBTreeCollisionManager<S>::collide(CollisionObject<S>* obj, void*
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager<S>::distance(CollisionObject<S>* obj, void* cdata, DistanceCallBack<S> callback) const
 {
   if(size() == 0) return;
@@ -945,7 +920,6 @@ void DynamicAABBTreeCollisionManager<S>::distance(CollisionObject<S>* obj, void*
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager<S>::collide(void* cdata, CollisionCallBack<S> callback) const
 {
   if(size() == 0) return;
@@ -954,7 +928,6 @@ void DynamicAABBTreeCollisionManager<S>::collide(void* cdata, CollisionCallBack<
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager<S>::distance(void* cdata, DistanceCallBack<S> callback) const
 {
   if(size() == 0) return;
@@ -964,7 +937,6 @@ void DynamicAABBTreeCollisionManager<S>::distance(void* cdata, DistanceCallBack<
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager<S>::collide(BroadPhaseCollisionManager<S>* other_manager_, void* cdata, CollisionCallBack<S> callback) const
 {
   DynamicAABBTreeCollisionManager* other_manager = static_cast<DynamicAABBTreeCollisionManager*>(other_manager_);
@@ -974,7 +946,6 @@ void DynamicAABBTreeCollisionManager<S>::collide(BroadPhaseCollisionManager<S>*
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager<S>::distance(BroadPhaseCollisionManager<S>* other_manager_, void* cdata, DistanceCallBack<S> callback) const
 {
   DynamicAABBTreeCollisionManager* other_manager = static_cast<DynamicAABBTreeCollisionManager*>(other_manager_);
@@ -985,7 +956,6 @@ void DynamicAABBTreeCollisionManager<S>::distance(BroadPhaseCollisionManager<S>*
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool DynamicAABBTreeCollisionManager<S>::empty() const
 {
   return dtree.empty();
@@ -993,7 +963,6 @@ bool DynamicAABBTreeCollisionManager<S>::empty() const
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 size_t DynamicAABBTreeCollisionManager<S>::size() const
 {
   return dtree.size();
@@ -1001,7 +970,6 @@ size_t DynamicAABBTreeCollisionManager<S>::size() const
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 const detail::HierarchyTree<AABB<S>>&
 DynamicAABBTreeCollisionManager<S>::getTree() const
 {
diff --git a/include/fcl/broadphase/broadphase_dynamic_AABB_tree.h b/include/fcl/broadphase/broadphase_dynamic_AABB_tree.h
index 7ee6a33..e6cfc89 100644
--- a/include/fcl/broadphase/broadphase_dynamic_AABB_tree.h
+++ b/include/fcl/broadphase/broadphase_dynamic_AABB_tree.h
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -51,7 +51,7 @@ namespace fcl
 {
 
 template <typename S>
-class FCL_EXPORT DynamicAABBTreeCollisionManager : public BroadPhaseCollisionManager<S>
+class DynamicAABBTreeCollisionManager : public BroadPhaseCollisionManager<S>
 {
 public:
 
@@ -71,7 +71,7 @@ public:
 
   /// @brief add objects to the manager
   void registerObjects(const std::vector<CollisionObject<S>*>& other_objs);
-  
+
   /// @brief add one object to the manager
   void registerObject(CollisionObject<S>* obj);
 
@@ -113,10 +113,10 @@ public:
 
   /// @brief perform distance test with objects belonging to another manager
   void distance(BroadPhaseCollisionManager<S>* other_manager_, void* cdata, DistanceCallBack<S> callback) const;
-  
+
   /// @brief whether the manager is empty
   bool empty() const;
-  
+
   /// @brief the number of objects managed by the manager
   size_t size() const;
 
diff --git a/include/fcl/broadphase/broadphase_dynamic_AABB_tree_array-inl.h b/include/fcl/broadphase/broadphase_dynamic_AABB_tree_array-inl.h
index 3cec23c..0c34d42 100644
--- a/include/fcl/broadphase/broadphase_dynamic_AABB_tree_array-inl.h
+++ b/include/fcl/broadphase/broadphase_dynamic_AABB_tree_array-inl.h
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -61,7 +61,6 @@ namespace dynamic_AABB_tree_array
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool collisionRecurse_(
     typename DynamicAABBTreeCollisionManager_Array<S>::DynamicAABBNode* nodes1,
     size_t root1_id,
@@ -175,7 +174,6 @@ bool collisionRecurse_(
 
 //==============================================================================
 template <typename S, typename Derived>
-FCL_EXPORT
 bool collisionRecurse_(
     typename DynamicAABBTreeCollisionManager_Array<S>::DynamicAABBNode* nodes1,
     size_t root1_id,
@@ -284,7 +282,6 @@ bool collisionRecurse_(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool distanceRecurse_(typename DynamicAABBTreeCollisionManager_Array<S>::DynamicAABBNode* nodes1, size_t root1_id, const OcTree<S>* tree2, const typename OcTree<S>::OcTreeNode* root2, const AABB<S>& root2_bv, const Transform3<S>& tf2, void* cdata, DistanceCallBack<S> callback, S& min_dist)
 {
   typename DynamicAABBTreeCollisionManager_Array<S>::DynamicAABBNode* root1 = nodes1 + root1_id;
@@ -368,7 +365,6 @@ bool distanceRecurse_(typename DynamicAABBTreeCollisionManager_Array<S>::Dynamic
 
 //==============================================================================
 template <typename S, typename Derived>
-FCL_EXPORT
 bool distanceRecurse_(
     typename DynamicAABBTreeCollisionManager_Array<S>::DynamicAABBNode* nodes1,
     size_t root1_id,
@@ -464,7 +460,6 @@ bool distanceRecurse_(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool collisionRecurse(typename DynamicAABBTreeCollisionManager_Array<S>::DynamicAABBNode* nodes1, size_t root1_id,
                       typename DynamicAABBTreeCollisionManager_Array<S>::DynamicAABBNode* nodes2, size_t root2_id,
                       void* cdata, CollisionCallBack<S> callback)
@@ -498,7 +493,6 @@ bool collisionRecurse(typename DynamicAABBTreeCollisionManager_Array<S>::Dynamic
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool collisionRecurse(typename DynamicAABBTreeCollisionManager_Array<S>::DynamicAABBNode* nodes, size_t root_id, CollisionObject<S>* query, void* cdata, CollisionCallBack<S> callback)
 {
   typename DynamicAABBTreeCollisionManager_Array<S>::DynamicAABBNode* root = nodes + root_id;
@@ -523,7 +517,6 @@ bool collisionRecurse(typename DynamicAABBTreeCollisionManager_Array<S>::Dynamic
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool selfCollisionRecurse(typename DynamicAABBTreeCollisionManager_Array<S>::DynamicAABBNode* nodes, size_t root_id, void* cdata, CollisionCallBack<S> callback)
 {
   typename DynamicAABBTreeCollisionManager_Array<S>::DynamicAABBNode* root = nodes + root_id;
@@ -543,7 +536,6 @@ bool selfCollisionRecurse(typename DynamicAABBTreeCollisionManager_Array<S>::Dyn
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool distanceRecurse(typename DynamicAABBTreeCollisionManager_Array<S>::DynamicAABBNode* nodes1, size_t root1_id,
                      typename DynamicAABBTreeCollisionManager_Array<S>::DynamicAABBNode* nodes2, size_t root2_id,
                      void* cdata, DistanceCallBack<S> callback, S& min_dist)
@@ -631,7 +623,6 @@ bool distanceRecurse(typename DynamicAABBTreeCollisionManager_Array<S>::DynamicA
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool distanceRecurse(typename DynamicAABBTreeCollisionManager_Array<S>::DynamicAABBNode* nodes, size_t root_id, CollisionObject<S>* query, void* cdata, DistanceCallBack<S> callback, S& min_dist)
 {
   typename DynamicAABBTreeCollisionManager_Array<S>::DynamicAABBNode* root = nodes + root_id;
@@ -678,7 +669,6 @@ bool distanceRecurse(typename DynamicAABBTreeCollisionManager_Array<S>::DynamicA
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool selfDistanceRecurse(typename DynamicAABBTreeCollisionManager_Array<S>::DynamicAABBNode* nodes, size_t root_id, void* cdata, DistanceCallBack<S> callback, S& min_dist)
 {
   typename DynamicAABBTreeCollisionManager_Array<S>::DynamicAABBNode* root = nodes + root_id;
@@ -701,7 +691,6 @@ bool selfDistanceRecurse(typename DynamicAABBTreeCollisionManager_Array<S>::Dyna
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool collisionRecurse(typename DynamicAABBTreeCollisionManager_Array<S>::DynamicAABBNode* nodes1, size_t root1_id, const OcTree<S>* tree2, const typename OcTree<S>::OcTreeNode* root2, const AABB<S>& root2_bv, const Transform3<S>& tf2, void* cdata, CollisionCallBack<S> callback)
 {
   if(tf2.linear().isIdentity())
@@ -712,7 +701,6 @@ bool collisionRecurse(typename DynamicAABBTreeCollisionManager_Array<S>::Dynamic
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool distanceRecurse(typename DynamicAABBTreeCollisionManager_Array<S>::DynamicAABBNode* nodes1, size_t root1_id, const OcTree<S>* tree2, const typename OcTree<S>::OcTreeNode* root2, const AABB<S>& root2_bv, const Transform3<S>& tf2, void* cdata, DistanceCallBack<S> callback, S& min_dist)
 {
   if(tf2.linear().isIdentity())
@@ -729,7 +717,6 @@ bool distanceRecurse(typename DynamicAABBTreeCollisionManager_Array<S>::DynamicA
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 DynamicAABBTreeCollisionManager_Array<S>::DynamicAABBTreeCollisionManager_Array()
   : tree_topdown_balance_threshold(dtree.bu_threshold),
     tree_topdown_level(dtree.topdown_level)
@@ -748,7 +735,6 @@ DynamicAABBTreeCollisionManager_Array<S>::DynamicAABBTreeCollisionManager_Array(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager_Array<S>::registerObjects(
     const std::vector<CollisionObject<S>*>& other_objs)
 {
@@ -781,7 +767,6 @@ void DynamicAABBTreeCollisionManager_Array<S>::registerObjects(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager_Array<S>::registerObject(CollisionObject<S>* obj)
 {
   size_t node = dtree.insert(obj->getAABB(), obj);
@@ -790,7 +775,6 @@ void DynamicAABBTreeCollisionManager_Array<S>::registerObject(CollisionObject<S>
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager_Array<S>::unregisterObject(CollisionObject<S>* obj)
 {
   size_t node = table[obj];
@@ -800,7 +784,6 @@ void DynamicAABBTreeCollisionManager_Array<S>::unregisterObject(CollisionObject<
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager_Array<S>::setup()
 {
   if(!setup_)
@@ -826,7 +809,6 @@ void DynamicAABBTreeCollisionManager_Array<S>::setup()
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager_Array<S>::update()
 {
   for(auto it = table.cbegin(), end = table.cend(); it != end; ++it)
@@ -844,7 +826,6 @@ void DynamicAABBTreeCollisionManager_Array<S>::update()
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager_Array<S>::update_(CollisionObject<S>* updated_obj)
 {
   const auto it = table.find(updated_obj);
@@ -859,7 +840,6 @@ void DynamicAABBTreeCollisionManager_Array<S>::update_(CollisionObject<S>* updat
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager_Array<S>::update(CollisionObject<S>* updated_obj)
 {
   update_(updated_obj);
@@ -868,7 +848,6 @@ void DynamicAABBTreeCollisionManager_Array<S>::update(CollisionObject<S>* update
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager_Array<S>::update(const std::vector<CollisionObject<S>*>& updated_objs)
 {
   for(size_t i = 0, size = updated_objs.size(); i < size; ++i)
@@ -878,7 +857,6 @@ void DynamicAABBTreeCollisionManager_Array<S>::update(const std::vector<Collisio
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager_Array<S>::clear()
 {
   dtree.clear();
@@ -887,7 +865,6 @@ void DynamicAABBTreeCollisionManager_Array<S>::clear()
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager_Array<S>::getObjects(std::vector<CollisionObject<S>*>& objs) const
 {
   objs.resize(this->size());
@@ -896,7 +873,6 @@ void DynamicAABBTreeCollisionManager_Array<S>::getObjects(std::vector<CollisionO
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager_Array<S>::collide(CollisionObject<S>* obj, void* cdata, CollisionCallBack<S> callback) const
 {
   if(size() == 0) return;
@@ -922,7 +898,6 @@ void DynamicAABBTreeCollisionManager_Array<S>::collide(CollisionObject<S>* obj,
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager_Array<S>::distance(CollisionObject<S>* obj, void* cdata, DistanceCallBack<S> callback) const
 {
   if(size() == 0) return;
@@ -949,7 +924,6 @@ void DynamicAABBTreeCollisionManager_Array<S>::distance(CollisionObject<S>* obj,
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager_Array<S>::collide(void* cdata, CollisionCallBack<S> callback) const
 {
   if(size() == 0) return;
@@ -958,7 +932,6 @@ void DynamicAABBTreeCollisionManager_Array<S>::collide(void* cdata, CollisionCal
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager_Array<S>::distance(void* cdata, DistanceCallBack<S> callback) const
 {
   if(size() == 0) return;
@@ -968,7 +941,6 @@ void DynamicAABBTreeCollisionManager_Array<S>::distance(void* cdata, DistanceCal
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager_Array<S>::collide(BroadPhaseCollisionManager<S>* other_manager_, void* cdata, CollisionCallBack<S> callback) const
 {
   DynamicAABBTreeCollisionManager_Array* other_manager = static_cast<DynamicAABBTreeCollisionManager_Array*>(other_manager_);
@@ -978,7 +950,6 @@ void DynamicAABBTreeCollisionManager_Array<S>::collide(BroadPhaseCollisionManage
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DynamicAABBTreeCollisionManager_Array<S>::distance(BroadPhaseCollisionManager<S>* other_manager_, void* cdata, DistanceCallBack<S> callback) const
 {
   DynamicAABBTreeCollisionManager_Array* other_manager = static_cast<DynamicAABBTreeCollisionManager_Array*>(other_manager_);
@@ -989,7 +960,6 @@ void DynamicAABBTreeCollisionManager_Array<S>::distance(BroadPhaseCollisionManag
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool DynamicAABBTreeCollisionManager_Array<S>::empty() const
 {
   return dtree.empty();
@@ -997,7 +967,6 @@ bool DynamicAABBTreeCollisionManager_Array<S>::empty() const
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 size_t DynamicAABBTreeCollisionManager_Array<S>::size() const
 {
   return dtree.size();
@@ -1005,7 +974,6 @@ size_t DynamicAABBTreeCollisionManager_Array<S>::size() const
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 const detail::implementation_array::HierarchyTree<AABB<S>>&
 DynamicAABBTreeCollisionManager_Array<S>::getTree() const
 {
diff --git a/include/fcl/broadphase/broadphase_dynamic_AABB_tree_array.h b/include/fcl/broadphase/broadphase_dynamic_AABB_tree_array.h
index 3d535f8..58b1432 100644
--- a/include/fcl/broadphase/broadphase_dynamic_AABB_tree_array.h
+++ b/include/fcl/broadphase/broadphase_dynamic_AABB_tree_array.h
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -52,7 +52,7 @@ namespace fcl
 {
 
 template <typename S>
-class FCL_EXPORT DynamicAABBTreeCollisionManager_Array : public BroadPhaseCollisionManager<S>
+class DynamicAABBTreeCollisionManager_Array : public BroadPhaseCollisionManager<S>
 {
 public:
 
@@ -67,12 +67,12 @@ public:
 
   bool octree_as_geometry_collide;
   bool octree_as_geometry_distance;
-  
+
   DynamicAABBTreeCollisionManager_Array();
 
   /// @brief add objects to the manager
   void registerObjects(const std::vector<CollisionObject<S>*>& other_objs);
-  
+
   /// @brief add one object to the manager
   void registerObject(CollisionObject<S>* obj);
 
@@ -114,10 +114,10 @@ public:
 
   /// @brief perform distance test with objects belonging to another manager
   void distance(BroadPhaseCollisionManager<S>* other_manager_, void* cdata, DistanceCallBack<S> callback) const;
-  
+
   /// @brief whether the manager is empty
   bool empty() const;
-  
+
   /// @brief the number of objects managed by the manager
   size_t size() const;
 
diff --git a/include/fcl/broadphase/broadphase_interval_tree-inl.h b/include/fcl/broadphase/broadphase_interval_tree-inl.h
index dcc4f6d..44a6ccc 100644
--- a/include/fcl/broadphase/broadphase_interval_tree-inl.h
+++ b/include/fcl/broadphase/broadphase_interval_tree-inl.h
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
diff --git a/include/fcl/broadphase/broadphase_interval_tree.h b/include/fcl/broadphase/broadphase_interval_tree.h
index 79c5467..b7b174d 100644
--- a/include/fcl/broadphase/broadphase_interval_tree.h
+++ b/include/fcl/broadphase/broadphase_interval_tree.h
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -48,7 +48,7 @@ namespace fcl
 
 /// @brief Collision manager based on interval tree
 template <typename S>
-class FCL_EXPORT IntervalTreeCollisionManager : public BroadPhaseCollisionManager<S>
+class IntervalTreeCollisionManager : public BroadPhaseCollisionManager<S>
 {
 public:
   IntervalTreeCollisionManager();
@@ -99,7 +99,7 @@ public:
 
   /// @brief whether the manager is empty
   bool empty() const;
-  
+
   /// @brief the number of objects managed by the manager
   size_t size() const;
 
@@ -147,7 +147,7 @@ using IntervalTreeCollisionManagerd = IntervalTreeCollisionManager<double>;
 
 /// @brief SAP end point
 template <typename S>
-struct FCL_EXPORT IntervalTreeCollisionManager<S>::EndPoint
+struct IntervalTreeCollisionManager<S>::EndPoint
 {
   /// @brief object related with the end point
   CollisionObject<S>* obj;
@@ -163,7 +163,7 @@ struct FCL_EXPORT IntervalTreeCollisionManager<S>::EndPoint
 
 /// @brief Extention interval tree's interval to SAP interval, adding more information
 template <typename S>
-struct FCL_EXPORT IntervalTreeCollisionManager<S>::SAPInterval : public detail::SimpleInterval<S>
+struct IntervalTreeCollisionManager<S>::SAPInterval : public detail::SimpleInterval<S>
 {
   CollisionObject<S>* obj;
 
diff --git a/include/fcl/broadphase/broadphase_spatialhash-inl.h b/include/fcl/broadphase/broadphase_spatialhash-inl.h
index 12551ce..920a490 100644
--- a/include/fcl/broadphase/broadphase_spatialhash-inl.h
+++ b/include/fcl/broadphase/broadphase_spatialhash-inl.h
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
diff --git a/include/fcl/broadphase/broadphase_spatialhash.h b/include/fcl/broadphase/broadphase_spatialhash.h
index a21d041..0cedef7 100644
--- a/include/fcl/broadphase/broadphase_spatialhash.h
+++ b/include/fcl/broadphase/broadphase_spatialhash.h
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -53,7 +53,7 @@ namespace fcl
 template<typename S,
          typename HashTable
              = detail::SimpleHashTable<AABB<S>, CollisionObject<S>*, detail::SpatialHash<S>> >
-class FCL_EXPORT SpatialHashingCollisionManager : public BroadPhaseCollisionManager<S>
+class SpatialHashingCollisionManager : public BroadPhaseCollisionManager<S>
 {
 public:
   SpatialHashingCollisionManager(
diff --git a/include/fcl/broadphase/detail/hierarchy_tree.h b/include/fcl/broadphase/detail/hierarchy_tree.h
index 456314a..bdabe90 100644
--- a/include/fcl/broadphase/detail/hierarchy_tree.h
+++ b/include/fcl/broadphase/detail/hierarchy_tree.h
@@ -55,7 +55,7 @@ namespace detail
 
 /// @brief Class for hierarchy tree structure
 template<typename BV>
-class FCL_EXPORT HierarchyTree
+class HierarchyTree
 {
 public:
 
@@ -70,7 +70,7 @@ public:
   HierarchyTree(int bu_threshold_ = 16, int topdown_level_ = 0);
 
   ~HierarchyTree();
-  
+
   /// @brief Initialize the tree by a set of leaves using algorithm with a given level.
   void init(std::vector<NodeType*>& leaves, int level = 0);
 
@@ -80,10 +80,10 @@ public:
   /// @brief Remove a leaf node
   void remove(NodeType* leaf);
 
-  /// @brief Clear the tree 
+  /// @brief Clear the tree
   void clear();
 
-  /// @brief Whether the tree is empty 
+  /// @brief Whether the tree is empty
   bool empty() const;
 
   /// @brief Updates a `leaf` node. A use case is when the bounding volume
@@ -102,10 +102,10 @@ public:
   /// @brief update the tree when the bounding volume of a given leaf has changed
   bool update(NodeType* leaf, const BV& bv);
 
-  /// @brief update one leaf's bounding volume, with prediction 
+  /// @brief update one leaf's bounding volume, with prediction
   bool update(NodeType* leaf, const BV& bv, const Vector3<S>& vel, S margin);
 
-  /// @brief update one leaf's bounding volume, with prediction 
+  /// @brief update one leaf's bounding volume, with prediction
   bool update(NodeType* leaf, const BV& bv, const Vector3<S>& vel);
 
   /// @brief get the max height of the tree
@@ -114,19 +114,19 @@ public:
   /// @brief get the max depth of the tree
   size_t getMaxDepth() const;
 
-  /// @brief balance the tree from bottom 
+  /// @brief balance the tree from bottom
   void balanceBottomup();
 
-  /// @brief balance the tree from top 
+  /// @brief balance the tree from top
   void balanceTopdown();
-  
-  /// @brief balance the tree in an incremental way 
+
+  /// @brief balance the tree in an incremental way
   void balanceIncremental(int iterations);
-  
+
   /// @brief refit the tree, i.e., when the leaf nodes' bounding volumes change, update the entire tree in a bottom-up manner
   void refit();
 
-  /// @brief extract all the leaves of the tree 
+  /// @brief extract all the leaves of the tree
   void extractLeaves(const NodeType* root, std::vector<NodeType*>& leaves) const;
 
   /// @brief number of leaves in the tree
@@ -153,10 +153,10 @@ private:
     }
   };
 
-  /// @brief construct a tree for a set of leaves from bottom -- very heavy way 
+  /// @brief construct a tree for a set of leaves from bottom -- very heavy way
   void bottomup(const NodeVecIterator lbeg, const NodeVecIterator lend);
 
-  /// @brief construct a tree for a set of leaves from top 
+  /// @brief construct a tree for a set of leaves from top
   NodeType* topdown(const NodeVecIterator lbeg, const NodeVecIterator lend);
 
   /// @brief compute the maximum height of a subtree rooted from a given node
@@ -184,24 +184,24 @@ private:
   void init_1(std::vector<NodeType*>& leaves);
 
   /// @brief init tree from leaves using morton code. It uses morton_0, i.e., for nodes which is of depth more than the maximum bits of the morton code,
-  /// we split the leaves into two parts with the same size simply using the node index. 
+  /// we split the leaves into two parts with the same size simply using the node index.
   void init_2(std::vector<NodeType*>& leaves);
 
   /// @brief init tree from leaves using morton code. It uses morton_2, i.e., for all nodes, we simply divide the leaves into parts with the same size simply using the node index.
   void init_3(std::vector<NodeType*>& leaves);
-  
+
   NodeType* mortonRecurse_0(const NodeVecIterator lbeg, const NodeVecIterator lend, const uint32& split, int bits);
 
   NodeType* mortonRecurse_1(const NodeVecIterator lbeg, const NodeVecIterator lend, const uint32& split, int bits);
 
   NodeType* mortonRecurse_2(const NodeVecIterator lbeg, const NodeVecIterator lend);
 
-  /// @brief update one leaf node's bounding volume 
+  /// @brief update one leaf node's bounding volume
   void update_(NodeType* leaf, const BV& bv);
 
-  /// @brief sort node n and its parent according to their memory position 
+  /// @brief sort node n and its parent according to their memory position
   NodeType* sort(NodeType* n, NodeType*& r);
-  
+
   /// @brief Insert a leaf node and also update its ancestors. Maintain the
   /// tree as a full binary tree (every interior node has exactly two children).
   /// Furthermore, adjust the BV of interior nodes so that each parent's BV
@@ -219,13 +219,13 @@ private:
   //           adjusted.
   NodeType* removeLeaf(NodeType* const leaf);
 
-  /// @brief Delete all internal nodes and return all leaves nodes with given depth from root 
+  /// @brief Delete all internal nodes and return all leaves nodes with given depth from root
   void fetchLeaves(NodeType* root, std::vector<NodeType*>& leaves, int depth = -1);
 
   static size_t indexOf(NodeType* node);
 
-  /// @brief create one node (leaf or internal)  
-  NodeType* createNode(NodeType* parent, 
+  /// @brief create one node (leaf or internal)
+  NodeType* createNode(NodeType* parent,
                        const BV& bv,
                        void* data);
 
@@ -233,7 +233,7 @@ private:
                        const BV& bv1,
                        const BV& bv2,
                        void* data);
-  
+
   NodeType* createNode(NodeType* parent,
                        void* data);
 
@@ -250,11 +250,11 @@ protected:
 
   unsigned int opath;
 
-  /// This is a one NodeType cache, the reason is that we need to remove a node and then add it again frequently. 
-  NodeType* free_node; 
+  /// This is a one NodeType cache, the reason is that we need to remove a node and then add it again frequently.
+  NodeType* free_node;
 
   int max_lookahead_level;
-  
+
 public:
   /// @brief decide which topdown algorithm to use
   int topdown_level;
diff --git a/include/fcl/broadphase/detail/hierarchy_tree_array.h b/include/fcl/broadphase/detail/hierarchy_tree_array.h
index b55f1e8..a9ba633 100644
--- a/include/fcl/broadphase/detail/hierarchy_tree_array.h
+++ b/include/fcl/broadphase/detail/hierarchy_tree_array.h
@@ -58,11 +58,11 @@ namespace implementation_array
 
 /// @brief Class for hierarchy tree structure
 template<typename BV>
-class FCL_EXPORT HierarchyTree
+class HierarchyTree
 {
   using S = typename BV::S;
   typedef NodeBase<BV> NodeType;
-  
+
   struct SortByMorton
   {
     bool operator() (size_t a, size_t b) const
@@ -99,22 +99,22 @@ public:
   /// @brief Remove a leaf node
   void remove(size_t leaf);
 
-  /// @brief Clear the tree 
+  /// @brief Clear the tree
   void clear();
 
-  /// @brief Whether the tree is empty 
+  /// @brief Whether the tree is empty
   bool empty() const;
- 
-  /// @brief update one leaf node 
+
+  /// @brief update one leaf node
   void update(size_t leaf, int lookahead_level = -1);
 
   /// @brief update the tree when the bounding volume of a given leaf has changed
   bool update(size_t leaf, const BV& bv);
 
-  /// @brief update one leaf's bounding volume, with prediction 
+  /// @brief update one leaf's bounding volume, with prediction
   bool update(size_t leaf, const BV& bv, const Vector3<S>& vel, S margin);
 
-  /// @brief update one leaf's bounding volume, with prediction 
+  /// @brief update one leaf's bounding volume, with prediction
   bool update(size_t leaf, const BV& bv, const Vector3<S>& vel);
 
   /// @brief get the max height of the tree
@@ -123,19 +123,19 @@ public:
   /// @brief get the max depth of the tree
   size_t getMaxDepth() const;
 
-  /// @brief balance the tree from bottom 
+  /// @brief balance the tree from bottom
   void balanceBottomup();
 
-  /// @brief balance the tree from top 
+  /// @brief balance the tree from top
   void balanceTopdown();
 
-  /// @brief balance the tree in an incremental way 
+  /// @brief balance the tree in an incremental way
   void balanceIncremental(int iterations);
 
   /// @brief refit the tree, i.e., when the leaf nodes' bounding volumes change, update the entire tree in a bottom-up manner
   void refit();
 
-  /// @brief extract all the leaves of the tree 
+  /// @brief extract all the leaves of the tree
   void extractLeaves(size_t root, NodeType*& leaves) const;
 
   /// @brief number of leaves in the tree
@@ -152,10 +152,10 @@ public:
 
 private:
 
-  /// @brief construct a tree for a set of leaves from bottom -- very heavy way 
+  /// @brief construct a tree for a set of leaves from bottom -- very heavy way
   void bottomup(size_t* lbeg, size_t* lend);
-  
-  /// @brief construct a tree for a set of leaves from top 
+
+  /// @brief construct a tree for a set of leaves from top
   size_t topdown(size_t* lbeg, size_t* lend);
 
   /// @brief compute the maximum height of a subtree rooted from a given node
@@ -183,7 +183,7 @@ private:
   void init_1(NodeType* leaves, int n_leaves_);
 
   /// @brief init tree from leaves using morton code. It uses morton_0, i.e., for nodes which is of depth more than the maximum bits of the morton code,
-  /// we split the leaves into two parts with the same size simply using the node index. 
+  /// we split the leaves into two parts with the same size simply using the node index.
   void init_2(NodeType* leaves, int n_leaves_);
 
   /// @brief init tree from leaves using morton code. It uses morton_2, i.e., for all nodes, we simply divide the leaves into parts with the same size simply using the node index.
@@ -195,17 +195,17 @@ private:
 
   size_t mortonRecurse_2(size_t* lbeg, size_t* lend);
 
-  /// @brief update one leaf node's bounding volume 
+  /// @brief update one leaf node's bounding volume
   void update_(size_t leaf, const BV& bv);
 
-  /// @brief Insert a leaf node and also update its ancestors 
+  /// @brief Insert a leaf node and also update its ancestors
   void insertLeaf(size_t root, size_t leaf);
 
   /// @brief Remove a leaf. The leaf node itself is not deleted yet, but all the unnecessary internal nodes are deleted.
-  /// return the node with the smallest depth and is influenced by the remove operation 
+  /// return the node with the smallest depth and is influenced by the remove operation
   size_t removeLeaf(size_t leaf);
 
-  /// @brief Delete all internal nodes and return all leaves nodes with given depth from root 
+  /// @brief Delete all internal nodes and return all leaves nodes with given depth from root
   void fetchLeaves(size_t root, NodeType*& leaves, int depth = -1);
 
   size_t indexOf(size_t node);
@@ -213,13 +213,13 @@ private:
   size_t allocateNode();
 
   /// @brief create one node (leaf or internal)
-  size_t createNode(size_t parent, 
+  size_t createNode(size_t parent,
                     const BV& bv1,
                     const BV& bv2,
                     void* data);
 
   size_t createNode(size_t parent,
-                    const BV& bv, 
+                    const BV& bv,
                     void* data);
 
   size_t createNode(size_t parent,
@@ -234,7 +234,7 @@ protected:
   NodeType* nodes;
   size_t n_nodes;
   size_t n_nodes_alloc;
-  
+
   size_t n_leaves;
   size_t freelist;
   unsigned int opath;
diff --git a/include/fcl/broadphase/detail/interval_tree-inl.h b/include/fcl/broadphase/detail/interval_tree-inl.h
index 330b676..719a796 100644
--- a/include/fcl/broadphase/detail/interval_tree-inl.h
+++ b/include/fcl/broadphase/detail/interval_tree-inl.h
@@ -47,7 +47,7 @@ namespace detail {
 
 //==============================================================================
 extern template
-class IntervalTree<double>;
+class FCL_EXPORT IntervalTree<double>;
 
 //==============================================================================
 template <typename S>
diff --git a/include/fcl/broadphase/detail/interval_tree.h b/include/fcl/broadphase/detail/interval_tree.h
index 6573520..e2abb03 100644
--- a/include/fcl/broadphase/detail/interval_tree.h
+++ b/include/fcl/broadphase/detail/interval_tree.h
@@ -51,7 +51,7 @@ namespace detail {
 /// right branch in searching for intervals but possibly come back
 /// and check the left branch as well.
 template <typename S>
-struct FCL_EXPORT it_recursion_node
+struct it_recursion_node
 {
 public:
   IntervalTreeNode<S>* start_node;
@@ -65,11 +65,11 @@ using it_recursion_nodef = it_recursion_node<float>;
 using it_recursion_noded = it_recursion_node<double>;
 
 extern template
-struct it_recursion_node<double>;
+struct FCL_EXPORT it_recursion_node<double>;
 
 /// @brief Interval tree
 template <typename S>
-class FCL_EXPORT IntervalTree
+class IntervalTree
 {
 public:
 
@@ -113,7 +113,7 @@ protected:
   /// @brief Inserts node into the tree as if it were a regular binary tree
   void recursiveInsert(IntervalTreeNode<S>* node);
 
-  /// @brief recursively print a subtree 
+  /// @brief recursively print a subtree
   void recursivePrint(IntervalTreeNode<S>* node) const;
 
   /// @brief recursively find the node corresponding to the interval
diff --git a/include/fcl/broadphase/detail/interval_tree_node.h b/include/fcl/broadphase/detail/interval_tree_node.h
index 537adab..9d60e6e 100644
--- a/include/fcl/broadphase/detail/interval_tree_node.h
+++ b/include/fcl/broadphase/detail/interval_tree_node.h
@@ -48,11 +48,11 @@ namespace detail
 {
 
 template <typename S>
-class FCL_EXPORT IntervalTree;
+class IntervalTree;
 
 /// @brief The node for interval tree
 template <typename S>
-class FCL_EXPORT IntervalTreeNode
+class IntervalTreeNode
 {
 public:
 
@@ -60,7 +60,7 @@ public:
   friend class IntervalTree;
 
   friend class IntervalTree<double>;
-  
+
   /// @brief Create an empty node
   IntervalTreeNode();
 
@@ -83,7 +83,7 @@ protected:
   S max_high;
 
   /// @brief red or black node: if red = false then the node is black
-  bool red;  
+  bool red;
 
   IntervalTreeNode* left;
 
diff --git a/include/fcl/broadphase/detail/morton-inl.h b/include/fcl/broadphase/detail/morton-inl.h
index cb23207..0753cc6 100644
--- a/include/fcl/broadphase/detail/morton-inl.h
+++ b/include/fcl/broadphase/detail/morton-inl.h
@@ -47,15 +47,16 @@ namespace detail {
 
 //==============================================================================
 extern template
+FCL_EXPORT
 uint32 quantize(double x, uint32 n);
 
 //==============================================================================
 extern template
-struct morton_functor<double, uint32>;
+struct FCL_EXPORT morton_functor<double, uint32>;
 
 //==============================================================================
 extern template
-struct morton_functor<double, uint64>;
+struct FCL_EXPORT morton_functor<double, uint64>;
 
 //==============================================================================
 template <typename S>
diff --git a/include/fcl/broadphase/detail/morton.h b/include/fcl/broadphase/detail/morton.h
index 6b430c4..7a840e4 100644
--- a/include/fcl/broadphase/detail/morton.h
+++ b/include/fcl/broadphase/detail/morton.h
@@ -52,7 +52,6 @@ namespace detail
 {
 
 template <typename S>
-FCL_EXPORT
 uint32 quantize(S x, uint32 n);
 
 /// @brief compute 30 bit morton code
@@ -68,11 +67,11 @@ uint64 morton_code60(uint32 x, uint32 y, uint32 z);
 /// a 30- or 60-bit code, respectively, and for `std::bitset<N>` where
 /// N is the length of the code and must be a multiple of 3.
 template<typename S, typename T>
-struct FCL_EXPORT morton_functor {};
+struct morton_functor {};
 
 /// @brief Functor to compute 30 bit morton code for a given AABB<S>
 template<typename S>
-struct FCL_EXPORT morton_functor<S, uint32>
+struct morton_functor<S, uint32>
 {
   morton_functor(const AABB<S>& bbox);
 
@@ -89,7 +88,7 @@ using morton_functoru32d = morton_functor<double, uint32>;
 
 /// @brief Functor to compute 60 bit morton code for a given AABB<S>
 template<typename S>
-struct FCL_EXPORT morton_functor<S, uint64>
+struct morton_functor<S, uint64>
 {
   morton_functor(const AABB<S>& bbox);
 
@@ -107,7 +106,7 @@ using morton_functoru64d = morton_functor<double, uint64>;
 /// @brief Functor to compute N bit morton code for a given AABB<S>
 /// N must be a multiple of 3.
 template<typename S, size_t N>
-struct FCL_EXPORT morton_functor<S, std::bitset<N>>
+struct morton_functor<S, std::bitset<N>>
 {
   static_assert(N%3==0, "Number of bits must be a multiple of 3");
 
diff --git a/include/fcl/broadphase/detail/simple_hash_table.h b/include/fcl/broadphase/detail/simple_hash_table.h
index 2708d02..d45d3c9 100644
--- a/include/fcl/broadphase/detail/simple_hash_table.h
+++ b/include/fcl/broadphase/detail/simple_hash_table.h
@@ -52,7 +52,7 @@ namespace detail
 /// @brief A simple hash table implemented as multiple buckets. HashFnc is any
 /// extended hash function: HashFnc(key) = {index1, index2, ..., }
 template<typename Key, typename Data, typename HashFnc>
-class FCL_EXPORT SimpleHashTable
+class SimpleHashTable
 {
 protected:
   typedef std::list<Data> Bin;
diff --git a/include/fcl/broadphase/detail/simple_interval-inl.h b/include/fcl/broadphase/detail/simple_interval-inl.h
index 4daafd9..354fc11 100644
--- a/include/fcl/broadphase/detail/simple_interval-inl.h
+++ b/include/fcl/broadphase/detail/simple_interval-inl.h
@@ -45,7 +45,7 @@ namespace detail {
 
 //==============================================================================
 extern template
-struct SimpleInterval<double>;
+struct FCL_EXPORT SimpleInterval<double>;
 
 //==============================================================================
 template <typename S>
diff --git a/include/fcl/broadphase/detail/simple_interval.h b/include/fcl/broadphase/detail/simple_interval.h
index ee8cbca..0c5e8e2 100644
--- a/include/fcl/broadphase/detail/simple_interval.h
+++ b/include/fcl/broadphase/detail/simple_interval.h
@@ -49,11 +49,11 @@ namespace detail
 /// @brief Interval trees implemented using red-black-trees as described in
 /// the book Introduction_To_Algorithms_ by Cormen, Leisserson, and Rivest.
 template <typename S>
-struct FCL_EXPORT SimpleInterval
+struct SimpleInterval
 {
 public:
   virtual ~SimpleInterval();
-  
+
   virtual void print();
 
   /// @brief interval is defined as [low, high]
diff --git a/include/fcl/broadphase/detail/sparse_hash_table.h b/include/fcl/broadphase/detail/sparse_hash_table.h
index 8f1a133..7d1f07a 100644
--- a/include/fcl/broadphase/detail/sparse_hash_table.h
+++ b/include/fcl/broadphase/detail/sparse_hash_table.h
@@ -51,25 +51,25 @@ namespace detail
 {
 
 template<typename U, typename V>
-class FCL_EXPORT unordered_map_hash_table : public std::unordered_map<U, V> {};
+class unordered_map_hash_table : public std::unordered_map<U, V> {};
 
 /// @brief A hash table implemented using unordered_map
 template <typename Key, typename Data, typename HashFnc,
           template<typename, typename> class TableT = unordered_map_hash_table>
-class FCL_EXPORT SparseHashTable
+class SparseHashTable
 {
 protected:
   HashFnc h_;
   typedef std::list<Data> Bin;
   typedef TableT<size_t, Bin> Table;
-  
+
   Table table_;
 public:
   SparseHashTable(const HashFnc& h);
 
   /// @brief Init the hash table. The bucket size is dynamically decided.
   void init(size_t);
-  
+
   /// @brief insert one key-value pair into the hash table
   void insert(Key key, Data value);
 
diff --git a/include/fcl/broadphase/detail/spatial_hash-inl.h b/include/fcl/broadphase/detail/spatial_hash-inl.h
index 1d4985f..c054d47 100644
--- a/include/fcl/broadphase/detail/spatial_hash-inl.h
+++ b/include/fcl/broadphase/detail/spatial_hash-inl.h
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -45,7 +45,7 @@ namespace detail {
 
 //==============================================================================
 extern template
-struct SpatialHash<double>;
+struct FCL_EXPORT SpatialHash<double>;
 
 //==============================================================================
 template <typename S>
diff --git a/include/fcl/broadphase/detail/spatial_hash.h b/include/fcl/broadphase/detail/spatial_hash.h
index b3f1cdd..f3fdf7e 100644
--- a/include/fcl/broadphase/detail/spatial_hash.h
+++ b/include/fcl/broadphase/detail/spatial_hash.h
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -48,12 +48,12 @@ namespace detail
 
 /// @brief Spatial hash function: hash an AABB to a set of integer values
 template <typename S_>
-struct FCL_EXPORT SpatialHash
+struct SpatialHash
 {
   using S = S_;
 
   SpatialHash(const AABB<S>& scene_limit_, S cell_size_);
-    
+
   std::vector<unsigned int> operator() (const AABB<S>& aabb) const;
 
 private:
diff --git a/include/fcl/common/types.h b/include/fcl/common/types.h
index 53f49d7..bd9d5a6 100644
--- a/include/fcl/common/types.h
+++ b/include/fcl/common/types.h
@@ -140,7 +140,7 @@ inline std::shared_ptr<_Tp> make_aligned_shared(_Args&&... __args)
 // C++11 compatible version is available since Eigen 3.2.9 so we use this copy
 // for Eigen (< 3.2.9).
 template <class T>
-class FCL_EXPORT aligned_allocator_cpp11 : public std::allocator<T>
+class aligned_allocator_cpp11 : public std::allocator<T>
 {
 public:
   typedef std::size_t     size_type;
diff --git a/include/fcl/geometry/bvh/BVH_model.h b/include/fcl/geometry/bvh/BVH_model.h
index 294d521..15849ee 100644
--- a/include/fcl/geometry/bvh/BVH_model.h
+++ b/include/fcl/geometry/bvh/BVH_model.h
@@ -54,7 +54,7 @@ namespace fcl
 
 /// @brief A class describing the bounding hierarchy of a mesh model or a point cloud model (which is viewed as a degraded version of mesh)
 template <typename BV>
-class FCL_EXPORT BVHModel : public CollisionGeometry<typename BV::S>
+class BVHModel : public CollisionGeometry<typename BV::S>
 {
 public:
 
@@ -74,7 +74,7 @@ public:
 
   /// @brief We provide getBV() and getNumBVs() because BVH may be compressed
   /// (in future), so we must provide some flexibility here
-  
+
   /// @brief Access the bv giving the its index
   const BVNode<BV>& getBV(int id) const;
 
@@ -147,7 +147,7 @@ public:
   /// @brief Check the number of memory used
   int memUsage(int msg) const;
 
-  /// @brief This is a special acceleration: BVH_model default stores the BV's transform in world coordinate. However, we can also store each BV's transform related to its parent 
+  /// @brief This is a special acceleration: BVH_model default stores the BV's transform in world coordinate. However, we can also store each BV's transform related to its parent
   /// BV node. When traversing the BVH, this can save one matrix transformation.
   void makeParentRelative();
 
@@ -211,7 +211,7 @@ private:
   /// @brief Recursive kernel for hierarchy construction
   int recursiveBuildTree(int bv_id, int first_primitive, int num_primitives);
 
-  /// @brief Recursive kernel for bottomup refitting 
+  /// @brief Recursive kernel for bottomup refitting
   int recursiveRefitTree_bottomup(int bv_id);
 
   /// @recursively compute each bv's transform related to its parent. For
diff --git a/include/fcl/geometry/bvh/BVH_utility-inl.h b/include/fcl/geometry/bvh/BVH_utility-inl.h
index 2196ca4..a9db5d8 100644
--- a/include/fcl/geometry/bvh/BVH_utility-inl.h
+++ b/include/fcl/geometry/bvh/BVH_utility-inl.h
@@ -47,17 +47,18 @@ namespace fcl
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void BVHExpand(
     BVHModel<OBB<double>>& model, const Variance3<double>* ucs, double r);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void BVHExpand(
     BVHModel<RSS<double>>& model, const Variance3<double>* ucs, double r);
 
 //==============================================================================
 template <typename S, typename BV>
-FCL_EXPORT
 void BVHExpand(BVHModel<BV>& model, const Variance3<S>* ucs, S r)
 {
   for(int i = 0; i < model.num_bvs; ++i)
@@ -85,7 +86,6 @@ void BVHExpand(BVHModel<BV>& model, const Variance3<S>* ucs, S r)
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void BVHExpand(
     BVHModel<OBB<S>>& model,
     const Variance3<S>* ucs,
@@ -129,7 +129,6 @@ void BVHExpand(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void BVHExpand(
     BVHModel<RSS<S>>& model,
     const Variance3<S>* ucs,
diff --git a/include/fcl/geometry/bvh/BVH_utility.h b/include/fcl/geometry/bvh/BVH_utility.h
index 68e3974..a086222 100644
--- a/include/fcl/geometry/bvh/BVH_utility.h
+++ b/include/fcl/geometry/bvh/BVH_utility.h
@@ -47,20 +47,17 @@ namespace fcl
 /// @brief Expand the BVH bounding boxes according to the variance matrix
 /// corresponding to the data stored within each BV node
 template <typename S, typename BV>
-FCL_EXPORT
 void BVHExpand(BVHModel<BV>& model, const Variance3<S>* ucs, S r);
 
 /// @brief Expand the BVH bounding boxes according to the corresponding variance
 /// information, for OBB
 template <typename S>
-FCL_EXPORT
 void BVHExpand(
     BVHModel<OBB<S>>& model, const Variance3<S>* ucs, S r = 1.0);
 
 /// @brief Expand the BVH bounding boxes according to the corresponding variance
 /// information, for RSS
 template <typename S>
-FCL_EXPORT
 void BVHExpand(
     BVHModel<RSS<S>>& model, const Variance3<S>* ucs, S r = 1.0);
 
diff --git a/include/fcl/geometry/bvh/BV_node.h b/include/fcl/geometry/bvh/BV_node.h
index 08dabbc..b87b9fd 100644
--- a/include/fcl/geometry/bvh/BV_node.h
+++ b/include/fcl/geometry/bvh/BV_node.h
@@ -49,7 +49,7 @@ namespace fcl
 
 /// @brief A class describing a bounding volume node. It includes the tree structure providing in BVNodeBase and also the geometry data provided in BV template parameter.
 template <typename BV>
-struct FCL_EXPORT BVNode : public BVNodeBase
+struct BVNode : public BVNodeBase
 {
   using S = typename BV::S;
 
diff --git a/include/fcl/geometry/bvh/detail/BV_fitter.h b/include/fcl/geometry/bvh/detail/BV_fitter.h
index c78c523..c31e2b8 100644
--- a/include/fcl/geometry/bvh/detail/BV_fitter.h
+++ b/include/fcl/geometry/bvh/detail/BV_fitter.h
@@ -53,7 +53,7 @@ namespace detail
 
 /// @brief The class for the default algorithm fitting a bounding volume to a set of points
 template <typename BV>
-class FCL_EXPORT BVFitter : public BVFitterBase<BV>
+class BVFitter : public BVFitterBase<BV>
 {
 public:
 
diff --git a/include/fcl/geometry/bvh/detail/BV_fitter_base.h b/include/fcl/geometry/bvh/detail/BV_fitter_base.h
index 3e10fbb..6bc1db1 100644
--- a/include/fcl/geometry/bvh/detail/BV_fitter_base.h
+++ b/include/fcl/geometry/bvh/detail/BV_fitter_base.h
@@ -52,7 +52,7 @@ namespace detail
 
 /// @brief Interface for fitting a bv given the triangles or points inside it.
 template <typename BV>
-class FCL_EXPORT BVFitterBase
+class BVFitterBase
 {
 public:
 
diff --git a/include/fcl/geometry/bvh/detail/BV_splitter.h b/include/fcl/geometry/bvh/detail/BV_splitter.h
index 7480f77..b155610 100644
--- a/include/fcl/geometry/bvh/detail/BV_splitter.h
+++ b/include/fcl/geometry/bvh/detail/BV_splitter.h
@@ -62,7 +62,7 @@ enum SplitMethodType
 
 /// @brief A class describing the split rule that splits each BV node
 template <typename BV>
-class FCL_EXPORT BVSplitter : public BVSplitterBase<BV>
+class BVSplitter : public BVSplitterBase<BV>
 {
 public:
 
diff --git a/include/fcl/geometry/bvh/detail/BV_splitter_base.h b/include/fcl/geometry/bvh/detail/BV_splitter_base.h
index 893c2be..595b794 100644
--- a/include/fcl/geometry/bvh/detail/BV_splitter_base.h
+++ b/include/fcl/geometry/bvh/detail/BV_splitter_base.h
@@ -53,7 +53,7 @@ namespace detail
 
 /// @brief Base interface for BV splitting algorithm
 template <typename BV>
-class FCL_EXPORT BVSplitterBase
+class BVSplitterBase
 {
 public:
 
diff --git a/include/fcl/geometry/collision_geometry.h b/include/fcl/geometry/collision_geometry.h
index 21fe849..09d34b8 100644
--- a/include/fcl/geometry/collision_geometry.h
+++ b/include/fcl/geometry/collision_geometry.h
@@ -55,7 +55,7 @@ enum NODE_TYPE {BV_UNKNOWN, BV_AABB, BV_OBB, BV_RSS, BV_kIOS, BV_OBBRSS, BV_KDOP
 
 /// @brief The geometry for the object for collision or distance computation
 template <typename S>
-class FCL_EXPORT CollisionGeometry
+class CollisionGeometry
 {
 public:
   CollisionGeometry();
diff --git a/include/fcl/geometry/octree/octree-inl.h b/include/fcl/geometry/octree/octree-inl.h
index 95d63db..a05c12c 100644
--- a/include/fcl/geometry/octree/octree-inl.h
+++ b/include/fcl/geometry/octree/octree-inl.h
@@ -53,6 +53,7 @@ class FCL_EXPORT OcTree<double>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void computeChildBV(const AABB<double>& root_bv, unsigned int i, AABB<double>& child_bv);
 
 //==============================================================================
diff --git a/include/fcl/geometry/octree/octree.h b/include/fcl/geometry/octree/octree.h
index 58f7364..908a017 100644
--- a/include/fcl/geometry/octree/octree.h
+++ b/include/fcl/geometry/octree/octree.h
@@ -55,7 +55,7 @@ namespace fcl
 /// @brief Octree is one type of collision geometry which can encode uncertainty
 /// information in the sensor data.
 template <typename S>
-class FCL_EXPORT OcTree : public CollisionGeometry<S>
+class OcTree : public CollisionGeometry<S>
 {
 private:
   std::shared_ptr<const octomap::OcTree> tree;
@@ -119,7 +119,7 @@ public:
 
   /// @return const ptr to child number childIdx of node
   const OcTreeNode* getNodeChild(const OcTreeNode* node, unsigned int childIdx) const;
-      
+
   /// @brief return true if the child at childIdx exists
   bool nodeChildExists(const OcTreeNode* node, unsigned int childIdx) const;
 
@@ -138,7 +138,6 @@ using OcTreed = OcTree<double>;
 
 /// @brief compute the bounding volume of an octree node's i-th child
 template <typename S>
-FCL_EXPORT
 void computeChildBV(const AABB<S>& root_bv, unsigned int i, AABB<S>& child_bv);
 
 } // namespace fcl
diff --git a/include/fcl/geometry/shape/box.h b/include/fcl/geometry/shape/box.h
index d15e9f2..5460828 100644
--- a/include/fcl/geometry/shape/box.h
+++ b/include/fcl/geometry/shape/box.h
@@ -47,7 +47,7 @@ namespace fcl
 
 /// @brief Center at zero point, axis aligned box
 template <typename S_>
-class FCL_EXPORT Box : public ShapeBase<S_>
+class Box : public ShapeBase<S_>
 {
 public:
 
diff --git a/include/fcl/geometry/shape/capsule.h b/include/fcl/geometry/shape/capsule.h
index 5add95e..8c21a96 100644
--- a/include/fcl/geometry/shape/capsule.h
+++ b/include/fcl/geometry/shape/capsule.h
@@ -45,9 +45,9 @@
 namespace fcl
 {
 
-/// @brief Center at zero point capsule 
+/// @brief Center at zero point capsule
 template <typename S_>
-class FCL_EXPORT Capsule : public ShapeBase<S_>
+class Capsule : public ShapeBase<S_>
 {
 public:
 
@@ -56,16 +56,16 @@ public:
   /// @brief Constructor
   Capsule(S radius, S lz);
 
-  /// @brief Radius of capsule 
+  /// @brief Radius of capsule
   S radius;
 
-  /// @brief Length along z axis 
+  /// @brief Length along z axis
   S lz;
 
   /// @brief Compute AABB<S>
   void computeLocalAABB() override;
 
-  /// @brief Get node type: a capsule 
+  /// @brief Get node type: a capsule
   NODE_TYPE getNodeType() const override;
 
   // Documentation inherited
diff --git a/include/fcl/geometry/shape/cone.h b/include/fcl/geometry/shape/cone.h
index ef9180c..30fff43 100644
--- a/include/fcl/geometry/shape/cone.h
+++ b/include/fcl/geometry/shape/cone.h
@@ -45,9 +45,9 @@
 namespace fcl
 {
 
-/// @brief Center at zero cone 
+/// @brief Center at zero cone
 template <typename S_>
-class FCL_EXPORT Cone : public ShapeBase<S_>
+class Cone : public ShapeBase<S_>
 {
 public:
 
@@ -55,16 +55,16 @@ public:
 
   Cone(S radius, S lz);
 
-  /// @brief Radius of the cone 
+  /// @brief Radius of the cone
   S radius;
 
-  /// @brief Length along z axis 
+  /// @brief Length along z axis
   S lz;
 
   /// @brief Compute AABB
   void computeLocalAABB() override;
 
-  /// @brief Get node type: a cone 
+  /// @brief Get node type: a cone
   NODE_TYPE getNodeType() const override;
 
   // Documentation inherited
diff --git a/include/fcl/geometry/shape/convex.h b/include/fcl/geometry/shape/convex.h
index 03c0489..8a47b67 100644
--- a/include/fcl/geometry/shape/convex.h
+++ b/include/fcl/geometry/shape/convex.h
@@ -78,7 +78,7 @@ namespace fcl
 ///
 /// @tparam S_  The scalar type; must be a valid Eigen scalar.
 template <typename S_>
-class FCL_EXPORT Convex : public ShapeBase<S_>
+class Convex : public ShapeBase<S_>
 {
 public:
 
@@ -103,7 +103,7 @@ public:
   Convex(const std::shared_ptr<const std::vector<Vector3<S>>>& vertices,
          int num_faces, const std::shared_ptr<const std::vector<int>>& faces);
 
-  /// @brief Copy constructor 
+  /// @brief Copy constructor
   Convex(const Convex& other);
 
   ~Convex() = default;
diff --git a/include/fcl/geometry/shape/cylinder.h b/include/fcl/geometry/shape/cylinder.h
index bd67d31..6e7280d 100644
--- a/include/fcl/geometry/shape/cylinder.h
+++ b/include/fcl/geometry/shape/cylinder.h
@@ -45,9 +45,9 @@
 namespace fcl
 {
 
-/// @brief Center at zero cylinder 
+/// @brief Center at zero cylinder
 template <typename S_>
-class FCL_EXPORT Cylinder : public ShapeBase<S_>
+class Cylinder : public ShapeBase<S_>
 {
 public:
 
@@ -55,17 +55,17 @@ public:
 
   /// @brief Constructor
   Cylinder(S radius, S lz);
-  
-  /// @brief Radius of the cylinder 
+
+  /// @brief Radius of the cylinder
   S radius;
 
-  /// @brief Length along z axis 
+  /// @brief Length along z axis
   S lz;
 
-  /// @brief Compute AABB 
+  /// @brief Compute AABB
   void computeLocalAABB() override;
 
-  /// @brief Get node type: a cylinder 
+  /// @brief Get node type: a cylinder
   NODE_TYPE getNodeType() const override;
 
   // Documentation inherited
diff --git a/include/fcl/geometry/shape/ellipsoid.h b/include/fcl/geometry/shape/ellipsoid.h
index 85632a9..3dfd1c0 100644
--- a/include/fcl/geometry/shape/ellipsoid.h
+++ b/include/fcl/geometry/shape/ellipsoid.h
@@ -47,7 +47,7 @@ namespace fcl
 
 /// @brief Center at zero point ellipsoid
 template <typename S_>
-class FCL_EXPORT Ellipsoid : public ShapeBase<S_>
+class Ellipsoid : public ShapeBase<S_>
 {
 public:
 
diff --git a/include/fcl/geometry/shape/halfspace-inl.h b/include/fcl/geometry/shape/halfspace-inl.h
index bc58f80..ee954f0 100644
--- a/include/fcl/geometry/shape/halfspace-inl.h
+++ b/include/fcl/geometry/shape/halfspace-inl.h
@@ -49,6 +49,7 @@ class FCL_EXPORT Halfspace<double>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 Halfspace<double> transform(const Halfspace<double>& a, const Transform3<double>& tf);
 
 //==============================================================================
diff --git a/include/fcl/geometry/shape/halfspace.h b/include/fcl/geometry/shape/halfspace.h
index 374b9e2..12c441a 100644
--- a/include/fcl/geometry/shape/halfspace.h
+++ b/include/fcl/geometry/shape/halfspace.h
@@ -54,7 +54,7 @@ namespace fcl
 /// Points in the negative side of the separation plane (i.e. {x | n * x < d}) are inside the half space and points
 /// in the positive side of the separation plane (i.e. {x | n * x > d}) are outside the half space
 template <typename S_>
-class FCL_EXPORT Halfspace : public ShapeBase<S_>
+class Halfspace : public ShapeBase<S_>
 {
 public:
 
@@ -77,10 +77,10 @@ public:
 
   /// @brief Get node type: a half space
   NODE_TYPE getNodeType() const override;
-  
+
   /// @brief Planed normal
   Vector3<S> n;
-  
+
   /// @brief Planed offset
   S d;
 
@@ -101,7 +101,6 @@ using Halfspacef = Halfspace<float>;
 using Halfspaced = Halfspace<double>;
 
 template <typename S>
-FCL_EXPORT
 Halfspace<S> transform(const Halfspace<S>& a, const Transform3<S>& tf);
 
 } // namespace fcl
diff --git a/include/fcl/geometry/shape/plane-inl.h b/include/fcl/geometry/shape/plane-inl.h
index 2e5da9c..598848c 100644
--- a/include/fcl/geometry/shape/plane-inl.h
+++ b/include/fcl/geometry/shape/plane-inl.h
@@ -49,6 +49,7 @@ class FCL_EXPORT Plane<double>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 Plane<double> transform(const Plane<double>& a, const Transform3<double>& tf);
 
 //==============================================================================
diff --git a/include/fcl/geometry/shape/plane.h b/include/fcl/geometry/shape/plane.h
index bcf3421..77a8ce2 100644
--- a/include/fcl/geometry/shape/plane.h
+++ b/include/fcl/geometry/shape/plane.h
@@ -45,18 +45,18 @@
 namespace fcl
 {
 
-/// @brief Infinite plane 
+/// @brief Infinite plane
 template <typename S_>
-class FCL_EXPORT Plane : public ShapeBase<S_>
+class Plane : public ShapeBase<S_>
 {
 public:
 
   using S = S_;
 
-  /// @brief Construct a plane with normal direction and offset 
+  /// @brief Construct a plane with normal direction and offset
   Plane(const Vector3<S>& n, S d);
-  
-  /// @brief Construct a plane with normal direction and offset 
+
+  /// @brief Construct a plane with normal direction and offset
   Plane(S a, S b, S c, S d);
 
   Plane();
@@ -68,13 +68,13 @@ public:
   /// @brief Compute AABB
   void computeLocalAABB() override;
 
-  /// @brief Get node type: a plane 
+  /// @brief Get node type: a plane
   NODE_TYPE getNodeType() const override;
 
-  /// @brief Plane normal 
+  /// @brief Plane normal
   Vector3<S> n;
 
-  /// @brief Plane offset 
+  /// @brief Plane offset
   S d;
 
   friend
@@ -84,8 +84,8 @@ public:
   }
 
 protected:
-  
-  /// @brief Turn non-unit normal into unit 
+
+  /// @brief Turn non-unit normal into unit
   void unitNormalTest();
 };
 
@@ -93,7 +93,6 @@ using Planef = Plane<float>;
 using Planed = Plane<double>;
 
 template <typename S>
-FCL_EXPORT
 Plane<S> transform(const Plane<S>& a, const Transform3<S>& tf);
 
 } // namespace fcl
diff --git a/include/fcl/geometry/shape/shape_base.h b/include/fcl/geometry/shape/shape_base.h
index 6acc6da..1f68aa2 100644
--- a/include/fcl/geometry/shape/shape_base.h
+++ b/include/fcl/geometry/shape/shape_base.h
@@ -45,7 +45,7 @@ namespace fcl
 
 /// @brief Base class for all basic geometric shapes
 template <typename S_>
-class FCL_EXPORT ShapeBase : public CollisionGeometry<S_>
+class ShapeBase : public CollisionGeometry<S_>
 {
 public:
 
diff --git a/include/fcl/geometry/shape/sphere.h b/include/fcl/geometry/shape/sphere.h
index 48b6792..d33a3f0 100644
--- a/include/fcl/geometry/shape/sphere.h
+++ b/include/fcl/geometry/shape/sphere.h
@@ -47,7 +47,7 @@ namespace fcl
 
 /// @brief Center at zero point sphere
 template <typename S_>
-class FCL_EXPORT Sphere : public ShapeBase<S_>
+class Sphere : public ShapeBase<S_>
 {
 public:
 
diff --git a/include/fcl/geometry/shape/triangle_p.h b/include/fcl/geometry/shape/triangle_p.h
index 7cc18ca..da3c92a 100644
--- a/include/fcl/geometry/shape/triangle_p.h
+++ b/include/fcl/geometry/shape/triangle_p.h
@@ -47,7 +47,7 @@ namespace fcl
 
 /// @brief Triangle stores the points instead of only indices of points
 template <typename S_>
-class FCL_EXPORT TriangleP : public ShapeBase<S_>
+class TriangleP : public ShapeBase<S_>
 {
 public:
 
@@ -59,7 +59,7 @@ public:
 
   /// @brief virtual function of compute AABB<S> in local coordinate
   void computeLocalAABB() override;
-  
+
   // Documentation inherited
   NODE_TYPE getNodeType() const override;
 
diff --git a/include/fcl/geometry/shape/utility-inl.h b/include/fcl/geometry/shape/utility-inl.h
index 146819d..5cd3af8 100644
--- a/include/fcl/geometry/shape/utility-inl.h
+++ b/include/fcl/geometry/shape/utility-inl.h
@@ -58,62 +58,77 @@ namespace fcl {
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void constructBox(const OBB<double>& bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void constructBox(const OBBRSS<double>& bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void constructBox(const kIOS<double>& bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void constructBox(const RSS<double>& bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void constructBox(const KDOP<double, 16>& bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void constructBox(const KDOP<double, 18>& bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void constructBox(const KDOP<double, 24>& bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void constructBox(const AABB<double>& bv, const Transform3<double>& tf_bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void constructBox(const OBB<double>& bv, const Transform3<double>& tf_bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void constructBox(const OBBRSS<double>& bv, const Transform3<double>& tf_bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void constructBox(const kIOS<double>& bv, const Transform3<double>& tf_bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void constructBox(const RSS<double>& bv, const Transform3<double>& tf_bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void constructBox(const KDOP<double, 16>& bv, const Transform3<double>& tf_bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void constructBox(const KDOP<double, 18>& bv, const Transform3<double>& tf_bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void constructBox(const KDOP<double, 24>& bv, const Transform3<double>& tf_bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
@@ -122,7 +137,7 @@ namespace detail {
 
 //==============================================================================
 template <typename S, typename BV, typename Shape>
-struct FCL_EXPORT ComputeBVImpl
+struct ComputeBVImpl
 {
   static void run(const Shape& s, const Transform3<S>& tf, BV& bv)
   {
@@ -134,7 +149,7 @@ struct FCL_EXPORT ComputeBVImpl
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, AABB<S>, Box<S>>
+struct ComputeBVImpl<S, AABB<S>, Box<S>>
 {
   static void run(const Box<S>& s, const Transform3<S>& tf, AABB<S>& bv)
   {
@@ -153,7 +168,7 @@ struct FCL_EXPORT ComputeBVImpl<S, AABB<S>, Box<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, OBB<S>, Box<S>>
+struct ComputeBVImpl<S, OBB<S>, Box<S>>
 {
   static void run(const Box<S>& s, const Transform3<S>& tf, OBB<S>& bv)
   {
@@ -165,7 +180,7 @@ struct FCL_EXPORT ComputeBVImpl<S, OBB<S>, Box<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, AABB<S>, Capsule<S>>
+struct ComputeBVImpl<S, AABB<S>, Capsule<S>>
 {
   static void run(const Capsule<S>& s, const Transform3<S>& tf, AABB<S>& bv)
   {
@@ -184,7 +199,7 @@ struct FCL_EXPORT ComputeBVImpl<S, AABB<S>, Capsule<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, OBB<S>, Capsule<S>>
+struct ComputeBVImpl<S, OBB<S>, Capsule<S>>
 {
   static void run(const Capsule<S>& s, const Transform3<S>& tf, OBB<S>& bv)
   {
@@ -196,7 +211,7 @@ struct FCL_EXPORT ComputeBVImpl<S, OBB<S>, Capsule<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, AABB<S>, Cone<S>>
+struct ComputeBVImpl<S, AABB<S>, Cone<S>>
 {
   static void run(const Cone<S>& s, const Transform3<S>& tf, AABB<S>& bv)
   {
@@ -215,7 +230,7 @@ struct FCL_EXPORT ComputeBVImpl<S, AABB<S>, Cone<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, OBB<S>, Cone<S>>
+struct ComputeBVImpl<S, OBB<S>, Cone<S>>
 {
   static void run(const Cone<S>& s, const Transform3<S>& tf, OBB<S>& bv)
   {
@@ -227,7 +242,7 @@ struct FCL_EXPORT ComputeBVImpl<S, OBB<S>, Cone<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, AABB<S>, Convex<S>>
+struct ComputeBVImpl<S, AABB<S>, Convex<S>>
 {
   static void run(const Convex<S>& s, const Transform3<S>& tf, AABB<S>& bv)
   {
@@ -247,7 +262,7 @@ struct FCL_EXPORT ComputeBVImpl<S, AABB<S>, Convex<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, OBB<S>, Convex<S>>
+struct ComputeBVImpl<S, OBB<S>, Convex<S>>
 {
   static void run(const Convex<S>& s, const Transform3<S>& tf, OBB<S>& bv)
   {
@@ -260,7 +275,7 @@ struct FCL_EXPORT ComputeBVImpl<S, OBB<S>, Convex<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, AABB<S>, Cylinder<S>>
+struct ComputeBVImpl<S, AABB<S>, Cylinder<S>>
 {
   static void run(const Cylinder<S>& s, const Transform3<S>& tf, AABB<S>& bv)
   {
@@ -279,7 +294,7 @@ struct FCL_EXPORT ComputeBVImpl<S, AABB<S>, Cylinder<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, OBB<S>, Cylinder<S>>
+struct ComputeBVImpl<S, OBB<S>, Cylinder<S>>
 {
   static void run(const Cylinder<S>& s, const Transform3<S>& tf, OBB<S>& bv)
   {
@@ -291,7 +306,7 @@ struct FCL_EXPORT ComputeBVImpl<S, OBB<S>, Cylinder<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, AABB<S>, Ellipsoid<S>>
+struct ComputeBVImpl<S, AABB<S>, Ellipsoid<S>>
 {
   static void run(const Ellipsoid<S>& s, const Transform3<S>& tf, AABB<S>& bv)
   {
@@ -310,7 +325,7 @@ struct FCL_EXPORT ComputeBVImpl<S, AABB<S>, Ellipsoid<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, OBB<S>, Ellipsoid<S>>
+struct ComputeBVImpl<S, OBB<S>, Ellipsoid<S>>
 {
   static void run(const Ellipsoid<S>& s, const Transform3<S>& tf, OBB<S>& bv)
   {
@@ -322,7 +337,7 @@ struct FCL_EXPORT ComputeBVImpl<S, OBB<S>, Ellipsoid<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, AABB<S>, Halfspace<S>>
+struct ComputeBVImpl<S, AABB<S>, Halfspace<S>>
 {
   static void run(const Halfspace<S>& s, const Transform3<S>& tf, AABB<S>& bv)
   {
@@ -358,7 +373,7 @@ struct FCL_EXPORT ComputeBVImpl<S, AABB<S>, Halfspace<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, OBB<S>, Halfspace<S>>
+struct ComputeBVImpl<S, OBB<S>, Halfspace<S>>
 {
   static void run(const Halfspace<S>& s, const Transform3<S>& tf, OBB<S>& bv)
   {
@@ -374,7 +389,7 @@ struct FCL_EXPORT ComputeBVImpl<S, OBB<S>, Halfspace<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, RSS<S>, Halfspace<S>>
+struct ComputeBVImpl<S, RSS<S>, Halfspace<S>>
 {
   static void run(const Halfspace<S>& s, const Transform3<S>& tf, RSS<S>& bv)
   {
@@ -390,7 +405,7 @@ struct FCL_EXPORT ComputeBVImpl<S, RSS<S>, Halfspace<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, OBBRSS<S>, Halfspace<S>>
+struct ComputeBVImpl<S, OBBRSS<S>, Halfspace<S>>
 {
   static void run(const Halfspace<S>& s, const Transform3<S>& tf, OBBRSS<S>& bv)
   {
@@ -401,7 +416,7 @@ struct FCL_EXPORT ComputeBVImpl<S, OBBRSS<S>, Halfspace<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, kIOS<S>, Halfspace<S>>
+struct ComputeBVImpl<S, kIOS<S>, Halfspace<S>>
 {
   static void run(const Halfspace<S>& s, const Transform3<S>& tf, kIOS<S>& bv)
   {
@@ -414,7 +429,7 @@ struct FCL_EXPORT ComputeBVImpl<S, kIOS<S>, Halfspace<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, KDOP<S, 16>, Halfspace<S>>
+struct ComputeBVImpl<S, KDOP<S, 16>, Halfspace<S>>
 {
   static void run(const Halfspace<S>& s, const Transform3<S>& tf, KDOP<S, 16>& bv)
   {
@@ -473,7 +488,7 @@ struct FCL_EXPORT ComputeBVImpl<S, KDOP<S, 16>, Halfspace<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, KDOP<S, 18>, Halfspace<S>>
+struct ComputeBVImpl<S, KDOP<S, 18>, Halfspace<S>>
 {
   static void run(const Halfspace<S>& s, const Transform3<S>& tf, KDOP<S, 18>& bv)
   {
@@ -538,7 +553,7 @@ struct FCL_EXPORT ComputeBVImpl<S, KDOP<S, 18>, Halfspace<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, KDOP<S, 24>, Halfspace<S>>
+struct ComputeBVImpl<S, KDOP<S, 24>, Halfspace<S>>
 {
   static void run(const Halfspace<S>& s, const Transform3<S>& tf, KDOP<S, 24>& bv)
   {
@@ -618,7 +633,7 @@ struct FCL_EXPORT ComputeBVImpl<S, KDOP<S, 24>, Halfspace<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, AABB<S>, Plane<S>>
+struct ComputeBVImpl<S, AABB<S>, Plane<S>>
 {
   static void run(const Plane<S>& s, const Transform3<S>& tf, AABB<S>& bv)
   {
@@ -654,7 +669,7 @@ struct FCL_EXPORT ComputeBVImpl<S, AABB<S>, Plane<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, OBB<S>, Plane<S>>
+struct ComputeBVImpl<S, OBB<S>, Plane<S>>
 {
   static void run(const Plane<S>& s, const Transform3<S>& tf, OBB<S>& bv)
   {
@@ -671,7 +686,7 @@ struct FCL_EXPORT ComputeBVImpl<S, OBB<S>, Plane<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, RSS<S>, Plane<S>>
+struct ComputeBVImpl<S, RSS<S>, Plane<S>>
 {
   static void run(const Plane<S>& s, const Transform3<S>& tf, RSS<S>& bv)
   {
@@ -692,7 +707,7 @@ struct FCL_EXPORT ComputeBVImpl<S, RSS<S>, Plane<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, OBBRSS<S>, Plane<S>>
+struct ComputeBVImpl<S, OBBRSS<S>, Plane<S>>
 {
   static void run(const Plane<S>& s, const Transform3<S>& tf, OBBRSS<S>& bv)
   {
@@ -703,7 +718,7 @@ struct FCL_EXPORT ComputeBVImpl<S, OBBRSS<S>, Plane<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, kIOS<S>, Plane<S>>
+struct ComputeBVImpl<S, kIOS<S>, Plane<S>>
 {
   static void run(const Plane<S>& s, const Transform3<S>& tf, kIOS<S>& bv)
   {
@@ -716,7 +731,7 @@ struct FCL_EXPORT ComputeBVImpl<S, kIOS<S>, Plane<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, KDOP<S, 16>, Plane<S>>
+struct ComputeBVImpl<S, KDOP<S, 16>, Plane<S>>
 {
   static void run(const Plane<S>& s, const Transform3<S>& tf, KDOP<S, 16>& bv)
   {
@@ -771,7 +786,7 @@ struct FCL_EXPORT ComputeBVImpl<S, KDOP<S, 16>, Plane<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, KDOP<S, 18>, Plane<S>>
+struct ComputeBVImpl<S, KDOP<S, 18>, Plane<S>>
 {
   static void run(const Plane<S>& s, const Transform3<S>& tf, KDOP<S, 18>& bv)
   {
@@ -830,7 +845,7 @@ struct FCL_EXPORT ComputeBVImpl<S, KDOP<S, 18>, Plane<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, KDOP<S, 24>, Plane<S>>
+struct ComputeBVImpl<S, KDOP<S, 24>, Plane<S>>
 {
   static void run(const Plane<S>& s, const Transform3<S>& tf, KDOP<S, 24>& bv)
   {
@@ -901,7 +916,7 @@ struct FCL_EXPORT ComputeBVImpl<S, KDOP<S, 24>, Plane<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, AABB<S>, Sphere<S>>
+struct ComputeBVImpl<S, AABB<S>, Sphere<S>>
 {
   static void run(const Sphere<S>& s, const Transform3<S>& tf, AABB<S>& bv)
   {
@@ -913,7 +928,7 @@ struct FCL_EXPORT ComputeBVImpl<S, AABB<S>, Sphere<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, OBB<S>, Sphere<S>>
+struct ComputeBVImpl<S, OBB<S>, Sphere<S>>
 {
   static void run(const Sphere<S>& s, const Transform3<S>& tf, OBB<S>& bv)
   {
@@ -925,7 +940,7 @@ struct FCL_EXPORT ComputeBVImpl<S, OBB<S>, Sphere<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT ComputeBVImpl<S, AABB<S>, TriangleP<S>>
+struct ComputeBVImpl<S, AABB<S>, TriangleP<S>>
 {
   static void run(const TriangleP<S>& s, const Transform3<S>& tf, AABB<S>& bv)
   {
@@ -935,119 +950,119 @@ struct FCL_EXPORT ComputeBVImpl<S, AABB<S>, TriangleP<S>>
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, AABB<double>, Box<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, AABB<double>, Box<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, OBB<double>, Box<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, OBB<double>, Box<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, AABB<double>, Capsule<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, AABB<double>, Capsule<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, OBB<double>, Capsule<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, OBB<double>, Capsule<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, AABB<double>, Cone<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, AABB<double>, Cone<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, OBB<double>, Cone<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, OBB<double>, Cone<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, AABB<double>, Cylinder<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, AABB<double>, Cylinder<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, OBB<double>, Cylinder<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, OBB<double>, Cylinder<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, AABB<double>, Ellipsoid<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, AABB<double>, Ellipsoid<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, OBB<double>, Ellipsoid<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, OBB<double>, Ellipsoid<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, AABB<double>, Halfspace<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, AABB<double>, Halfspace<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, OBB<double>, Halfspace<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, OBB<double>, Halfspace<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, RSS<double>, Halfspace<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, RSS<double>, Halfspace<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, OBBRSS<double>, Halfspace<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, OBBRSS<double>, Halfspace<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, kIOS<double>, Halfspace<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, kIOS<double>, Halfspace<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, KDOP<double, 16>, Halfspace<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, KDOP<double, 16>, Halfspace<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, KDOP<double, 18>, Halfspace<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, KDOP<double, 18>, Halfspace<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, KDOP<double, 24>, Halfspace<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, KDOP<double, 24>, Halfspace<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, AABB<double>, Plane<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, AABB<double>, Plane<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, OBB<double>, Plane<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, OBB<double>, Plane<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, RSS<double>, Plane<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, RSS<double>, Plane<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, OBBRSS<double>, Plane<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, OBBRSS<double>, Plane<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, kIOS<double>, Plane<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, kIOS<double>, Plane<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, KDOP<double, 16>, Plane<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, KDOP<double, 16>, Plane<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, KDOP<double, 18>, Plane<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, KDOP<double, 18>, Plane<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, KDOP<double, 24>, Plane<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, KDOP<double, 24>, Plane<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, AABB<double>, Sphere<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, AABB<double>, Sphere<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, OBB<double>, Sphere<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, OBB<double>, Sphere<double>>;
 
 //==============================================================================
 extern template
-struct ComputeBVImpl<double, AABB<double>, TriangleP<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, AABB<double>, TriangleP<double>>;
 
 //==============================================================================
 } // namespace detail
@@ -1055,7 +1070,6 @@ struct ComputeBVImpl<double, AABB<double>, TriangleP<double>>;
 
 //==============================================================================
 template <typename BV, typename Shape>
-FCL_EXPORT
 void computeBV(const Shape& s, const Transform3<typename BV::S>& tf, BV& bv)
 {
   using S = typename BV::S;
diff --git a/include/fcl/geometry/shape/utility.h b/include/fcl/geometry/shape/utility.h
index ec70def..fe0bc62 100644
--- a/include/fcl/geometry/shape/utility.h
+++ b/include/fcl/geometry/shape/utility.h
@@ -57,72 +57,55 @@ namespace fcl
 
 /// @brief calculate a bounding volume for a shape in a specific configuration
 template <typename BV, typename Shape>
-FCL_EXPORT
 void computeBV(const Shape& s, const Transform3<typename BV::S>& tf, BV& bv);
 
 /// @brief construct a box shape (with a configuration) from a given bounding volume
 template <typename S>
-FCL_EXPORT
 void constructBox(const AABB<S>& bv, Box<S>& box, Transform3<S>& tf);
 
 template <typename S>
-FCL_EXPORT
 void constructBox(const OBB<S>& bv, Box<S>& box, Transform3<S>& tf);
 
 template <typename S>
-FCL_EXPORT
 void constructBox(const OBBRSS<S>& bv, Box<S>& box, Transform3<S>& tf);
 
 template <typename S>
-FCL_EXPORT
 void constructBox(const kIOS<S>& bv, Box<S>& box, Transform3<S>& tf);
 
 template <typename S>
-FCL_EXPORT
 void constructBox(const RSS<S>& bv, Box<S>& box, Transform3<S>& tf);
 
 template <typename S>
-FCL_EXPORT
 void constructBox(const KDOP<S, 16>& bv, Box<S>& box, Transform3<S>& tf);
 
 template <typename S>
-FCL_EXPORT
 void constructBox(const KDOP<S, 18>& bv, Box<S>& box, Transform3<S>& tf);
 
 template <typename S>
-FCL_EXPORT
 void constructBox(const KDOP<S, 24>& bv, Box<S>& box, Transform3<S>& tf);
 
 template <typename S>
-FCL_EXPORT
 void constructBox(const AABB<S>& bv, const Transform3<S>& tf_bv, Box<S>& box, Transform3<S>& tf);
 
 template <typename S>
-FCL_EXPORT
 void constructBox(const OBB<S>& bv, const Transform3<S>& tf_bv, Box<S>& box, Transform3<S>& tf);
 
 template <typename S>
-FCL_EXPORT
 void constructBox(const OBBRSS<S>& bv, const Transform3<S>& tf_bv, Box<S>& box, Transform3<S>& tf);
 
 template <typename S>
-FCL_EXPORT
 void constructBox(const kIOS<S>& bv, const Transform3<S>& tf_bv, Box<S>& box, Transform3<S>& tf);
 
 template <typename S>
-FCL_EXPORT
 void constructBox(const RSS<S>& bv, const Transform3<S>& tf_bv, Box<S>& box, Transform3<S>& tf);
 
 template <typename S>
-FCL_EXPORT
 void constructBox(const KDOP<S, 16>& bv, const Transform3<S>& tf_bv, Box<S>& box, Transform3<S>& tf);
 
 template <typename S>
-FCL_EXPORT
 void constructBox(const KDOP<S, 18>& bv, const Transform3<S>& tf_bv, Box<S>& box, Transform3<S>& tf);
 
 template <typename S>
-FCL_EXPORT
 void constructBox(const KDOP<S, 24>& bv, const Transform3<S>& tf_bv, Box<S>& box, Transform3<S>& tf);
 
 } // namespace fcl
diff --git a/include/fcl/math/bv/AABB.h b/include/fcl/math/bv/AABB.h
index f84b737..d785a63 100644
--- a/include/fcl/math/bv/AABB.h
+++ b/include/fcl/math/bv/AABB.h
@@ -46,7 +46,7 @@ namespace fcl
 /// @brief A class describing the AABB collision structure, which is a box in 3D
 /// space determined by two diagonal points
 template <typename S_>
-class FCL_EXPORT AABB
+class AABB
 {
 public:
 
diff --git a/include/fcl/math/bv/OBB-inl.h b/include/fcl/math/bv/OBB-inl.h
index 8881322..603ec47 100644
--- a/include/fcl/math/bv/OBB-inl.h
+++ b/include/fcl/math/bv/OBB-inl.h
@@ -51,18 +51,22 @@ class FCL_EXPORT OBB<double>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void computeVertices(const OBB<double>& b, Vector3<double> vertices[8]);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 OBB<double> merge_largedist(const OBB<double>& b1, const OBB<double>& b2);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 OBB<double> merge_smalldist(const OBB<double>& b1, const OBB<double>& b2);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool obbDisjoint(
     const Matrix3<double>& B,
     const Vector3<double>& T,
@@ -71,6 +75,7 @@ bool obbDisjoint(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool obbDisjoint(
     const Transform3<double>& tf,
     const Vector3<double>& a,
diff --git a/include/fcl/math/bv/OBB.h b/include/fcl/math/bv/OBB.h
index 3d7e216..1f3f0c4 100644
--- a/include/fcl/math/bv/OBB.h
+++ b/include/fcl/math/bv/OBB.h
@@ -48,7 +48,7 @@ namespace fcl
 
 /// @brief Oriented bounding box class
 template <typename S_>
-class FCL_EXPORT OBB
+class OBB
 {
 public:
 
@@ -75,10 +75,10 @@ public:
       const Vector3<S>& center,
       const Vector3<S>& extent);
 
-  /// @brief Check collision between two OBB, return true if collision happens. 
+  /// @brief Check collision between two OBB, return true if collision happens.
   bool overlap(const OBB<S>& other) const;
-  
-  /// @brief Check collision between two OBB and return the overlap part. For OBB, the overlap_part return value is NOT used as the overlap part of two obbs usually is not an obb. 
+
+  /// @brief Check collision between two OBB and return the overlap part. For OBB, the overlap_part return value is NOT used as the overlap part of two obbs usually is not an obb.
   bool overlap(const OBB<S>& other, OBB<S>& overlap_part) const;
 
   /// @brief Check whether the OBB contains a point.
@@ -124,29 +124,24 @@ using OBBd = OBB<double>;
 
 /// @brief Compute the 8 vertices of a OBB
 template <typename S>
-FCL_EXPORT
 void computeVertices(const OBB<S>& b, Vector3<S> vertices[8]);
 
 /// @brief OBB merge method when the centers of two smaller OBB are far away
 template <typename S>
-FCL_EXPORT
 OBB<S> merge_largedist(const OBB<S>& b1, const OBB<S>& b2);
 
 /// @brief OBB merge method when the centers of two smaller OBB are close
 template <typename S>
-FCL_EXPORT
 OBB<S> merge_smalldist(const OBB<S>& b1, const OBB<S>& b2);
 
 /// @brief Translate the OBB bv
 template <typename S, typename Derived>
-FCL_EXPORT
 OBB<S> translate(
     const OBB<S>& bv, const Eigen::MatrixBase<Derived>& t);
 
 /// @brief Check collision between two obbs, b1 is in configuration (R0, T0) and
 /// b2 is in identity.
 template <typename S, typename DerivedA, typename DerivedB>
-FCL_EXPORT
 bool overlap(const Eigen::MatrixBase<DerivedA>& R0,
              const Eigen::MatrixBase<DerivedB>& T0,
              const OBB<S>& b1, const OBB<S>& b2);
@@ -155,7 +150,6 @@ bool overlap(const Eigen::MatrixBase<DerivedA>& R0,
 /// (R, T) and its half dimension is set by a; the second box is in identity
 /// configuration and its half dimension is set by b.
 template <typename S>
-FCL_EXPORT
 bool obbDisjoint(
     const Matrix3<S>& B,
     const Vector3<S>& T,
@@ -166,7 +160,6 @@ bool obbDisjoint(
 /// (R, T) and its half dimension is set by a; the second box is in identity
 /// configuration and its half dimension is set by b.
 template <typename S>
-FCL_EXPORT
 bool obbDisjoint(
     const Transform3<S>& tf,
     const Vector3<S>& a,
diff --git a/include/fcl/math/bv/OBBRSS-inl.h b/include/fcl/math/bv/OBBRSS-inl.h
index 814a66f..bea07b3 100644
--- a/include/fcl/math/bv/OBBRSS-inl.h
+++ b/include/fcl/math/bv/OBBRSS-inl.h
@@ -49,6 +49,7 @@ class FCL_EXPORT OBBRSS<double>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 OBBRSS<double> translate(const OBBRSS<double>& bv, const Vector3<double>& t);
 
 //==============================================================================
diff --git a/include/fcl/math/bv/OBBRSS.h b/include/fcl/math/bv/OBBRSS.h
index 9f84c11..4f1d656 100644
--- a/include/fcl/math/bv/OBBRSS.h
+++ b/include/fcl/math/bv/OBBRSS.h
@@ -47,7 +47,7 @@ namespace fcl
 /// @brief Class merging the OBB and RSS, can handle collision and distance
 /// simultaneously
 template <typename S_>
-class FCL_EXPORT OBBRSS
+class OBBRSS
 {
 public:
 
@@ -108,13 +108,11 @@ using OBBRSSd = OBBRSS<double>;
 
 /// @brief Translate the OBBRSS bv
 template <typename S>
-FCL_EXPORT
 OBBRSS<S> translate(const OBBRSS<S>& bv, const Vector3<S>& t);
 
 /// @brief Check collision between two OBBRSS, b1 is in configuration (R0, T0)
 /// and b2 is in indentity
 template <typename S, typename DerivedA, typename DerivedB>
-FCL_EXPORT
 bool overlap(const Eigen::MatrixBase<DerivedA>& R0,
              const Eigen::MatrixBase<DerivedB>& T0,
              const OBBRSS<S>& b1, const OBBRSS<S>& b2);
@@ -122,7 +120,6 @@ bool overlap(const Eigen::MatrixBase<DerivedA>& R0,
 /// @brief Check collision between two OBBRSS, b1 is in configuration (R0, T0)
 /// and b2 is in indentity
 template <typename S>
-FCL_EXPORT
 bool overlap(
     const Transform3<S>& tf,
     const OBBRSS<S>& b1,
@@ -131,7 +128,6 @@ bool overlap(
 /// @brief Computate distance between two OBBRSS, b1 is in configuation (R0, T0)
 /// and b2 is in indentity; P and Q, is not nullptr, returns the nearest points
 template <typename S, typename DerivedA, typename DerivedB>
-FCL_EXPORT
 S distance(
     const Eigen::MatrixBase<DerivedA>& R0,
     const Eigen::MatrixBase<DerivedB>& T0,
@@ -141,7 +137,6 @@ S distance(
 /// @brief Computate distance between two OBBRSS, b1 is in configuation (R0, T0)
 /// and b2 is in indentity; P and Q, is not nullptr, returns the nearest points
 template <typename S>
-FCL_EXPORT
 S distance(
     const Transform3<S>& tf,
     const OBBRSS<S>& b1,
diff --git a/include/fcl/math/bv/RSS-inl.h b/include/fcl/math/bv/RSS-inl.h
index a88d5cb..fc639dd 100644
--- a/include/fcl/math/bv/RSS-inl.h
+++ b/include/fcl/math/bv/RSS-inl.h
@@ -49,10 +49,12 @@ class FCL_EXPORT RSS<double>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void clipToRange(double& val, double a, double b);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void segCoords(
         double& t,
         double& u,
@@ -64,6 +66,7 @@ void segCoords(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool inVoronoi(
         double a,
         double b,
@@ -75,6 +78,7 @@ bool inVoronoi(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 double rectDistance(
     const Matrix3<double>& Rab,
     const Vector3<double>& Tab,
@@ -85,6 +89,7 @@ double rectDistance(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 double rectDistance(
     const Transform3<double>& tfab,
     const double a[2],
@@ -94,6 +99,7 @@ double rectDistance(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 RSS<double> translate(const RSS<double>& bv, const Vector3<double>& t);
 
 //==============================================================================
diff --git a/include/fcl/math/bv/RSS.h b/include/fcl/math/bv/RSS.h
index 125ca3d..bdb2d07 100644
--- a/include/fcl/math/bv/RSS.h
+++ b/include/fcl/math/bv/RSS.h
@@ -46,7 +46,7 @@ namespace fcl
 
 /// @brief A class for rectangle sphere-swept bounding volume
 template <typename S_>
-class FCL_EXPORT RSS
+class RSS
 {
 public:
 
@@ -123,7 +123,6 @@ using RSSd = RSS<double>;
 
 /// @brief Clip value between a and b
 template <typename S>
-FCL_EXPORT
 void clipToRange(S& val, S a, S b);
 
 /// @brief Finds the parameters t & u corresponding to the two closest points on
@@ -139,7 +138,6 @@ void clipToRange(S& val, S a, S b);
 /// Reference: "On fast computation of distance between line segments." Vladimir
 /// J. Lumelsky, in Information Processing Letters, no. 21, pages 55-61, 1985.
 template <typename S>
-FCL_EXPORT
 void segCoords(S& t, S& u, S a, S b,
                S A_dot_B, S A_dot_T, S B_dot_T);
 
@@ -149,7 +147,6 @@ void segCoords(S& t, S& u, S a, S b,
 /// determined by the point Pa and the direction Anorm.
 /// A,B, and Anorm are unit vectors. T is the vector between Pa and Pb.
 template <typename S>
-FCL_EXPORT
 bool inVoronoi(S a, S b,
                S Anorm_dot_B, S Anorm_dot_T,
                S A_dot_B, S A_dot_T, S B_dot_T);
@@ -158,7 +155,6 @@ bool inVoronoi(S a, S b,
 /// values) are the closest points in the rectangles, both are in the local
 /// frame of the first rectangle.
 template <typename S>
-FCL_EXPORT
 S rectDistance(
     const Matrix3<S>& Rab,
     const Vector3<S>& Tab,
@@ -171,7 +167,6 @@ S rectDistance(
 /// values) are the closest points in the rectangles, both are in the local
 /// frame of the first rectangle.
 template <typename S>
-FCL_EXPORT
 S rectDistance(
     const Transform3<S>& tfab,
     const S a[2],
@@ -185,7 +180,6 @@ S rectDistance(
 /// points. Notice that P and Q are both in the local frame of the first RSS
 /// (not global frame and not even the local frame of object 1)
 template <typename S, typename DerivedA, typename DerivedB>
-FCL_EXPORT
 S distance(
     const Eigen::MatrixBase<DerivedA>& R0,
     const Eigen::MatrixBase<DerivedB>& T0,
@@ -197,7 +191,6 @@ S distance(
 /// @brief Check collision between two RSSs, b1 is in configuration (R0, T0) and
 /// b2 is in identity.
 template <typename S, typename DerivedA, typename DerivedB>
-FCL_EXPORT
 bool overlap(
     const Eigen::MatrixBase<DerivedA>& R0,
     const Eigen::MatrixBase<DerivedB>& T0,
@@ -206,7 +199,6 @@ bool overlap(
 
 /// @brief Translate the RSS bv
 template <typename S>
-FCL_EXPORT
 RSS<S> translate(const RSS<S>& bv, const Vector3<S>& t);
 
 } // namespace fcl
diff --git a/include/fcl/math/bv/kDOP-inl.h b/include/fcl/math/bv/kDOP-inl.h
index 371fdb6..9301b32 100644
--- a/include/fcl/math/bv/kDOP-inl.h
+++ b/include/fcl/math/bv/kDOP-inl.h
@@ -59,27 +59,31 @@ class FCL_EXPORT KDOP<double, 24>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void minmax(double a, double b, double& minv, double& maxv);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void minmax(double p, double& minv, double& maxv);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void getDistances<double, 5>(const Vector3<double>& p, double* d);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void getDistances<double, 6>(const Vector3<double>& p, double* d);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void getDistances<double, 9>(const Vector3<double>& p, double* d);
 
 //==============================================================================
 template <typename S, std::size_t N>
-FCL_EXPORT
 KDOP<S, N>::KDOP()
 {
   static_assert(N == 16 || N == 18 || N == 24, "N should be 16, 18, or 24");
@@ -94,7 +98,6 @@ KDOP<S, N>::KDOP()
 
 //==============================================================================
 template <typename S, std::size_t N>
-FCL_EXPORT
 KDOP<S, N>::KDOP(const Vector3<S>& v)
 {
   for(std::size_t i = 0; i < 3; ++i)
@@ -112,7 +115,6 @@ KDOP<S, N>::KDOP(const Vector3<S>& v)
 
 //==============================================================================
 template <typename S, std::size_t N>
-FCL_EXPORT
 KDOP<S, N>::KDOP(const Vector3<S>& a, const Vector3<S>& b)
 {
   for(std::size_t i = 0; i < 3; ++i)
@@ -131,7 +133,6 @@ KDOP<S, N>::KDOP(const Vector3<S>& a, const Vector3<S>& b)
 
 //==============================================================================
 template <typename S, std::size_t N>
-FCL_EXPORT
 bool KDOP<S, N>::overlap(const KDOP<S, N>& other) const
 {
   for(std::size_t i = 0; i < N / 2; ++i)
@@ -145,7 +146,6 @@ bool KDOP<S, N>::overlap(const KDOP<S, N>& other) const
 
 //==============================================================================
 template <typename S, std::size_t N>
-FCL_EXPORT
 bool KDOP<S, N>::inside(const Vector3<S>& p) const
 {
   for(std::size_t i = 0; i < 3; ++i)
@@ -167,7 +167,6 @@ bool KDOP<S, N>::inside(const Vector3<S>& p) const
 
 //==============================================================================
 template <typename S, std::size_t N>
-FCL_EXPORT
 KDOP<S, N>& KDOP<S, N>::operator += (const Vector3<S>& p)
 {
   for(std::size_t i = 0; i < 3; ++i)
@@ -187,7 +186,6 @@ KDOP<S, N>& KDOP<S, N>::operator += (const Vector3<S>& p)
 
 //==============================================================================
 template <typename S, std::size_t N>
-FCL_EXPORT
 KDOP<S, N>& KDOP<S, N>::operator += (const KDOP<S, N>& other)
 {
   for(std::size_t i = 0; i < N / 2; ++i)
@@ -200,7 +198,6 @@ KDOP<S, N>& KDOP<S, N>::operator += (const KDOP<S, N>& other)
 
 //==============================================================================
 template <typename S, std::size_t N>
-FCL_EXPORT
 KDOP<S, N> KDOP<S, N>::operator + (const KDOP<S, N>& other) const
 {
   KDOP<S, N> res(*this);
@@ -209,7 +206,6 @@ KDOP<S, N> KDOP<S, N>::operator + (const KDOP<S, N>& other) const
 
 //==============================================================================
 template <typename S, std::size_t N>
-FCL_EXPORT
 S KDOP<S, N>::width() const
 {
   return dist_[N / 2] - dist_[0];
@@ -217,7 +213,6 @@ S KDOP<S, N>::width() const
 
 //==============================================================================
 template <typename S, std::size_t N>
-FCL_EXPORT
 S KDOP<S, N>::height() const
 {
   return dist_[N / 2 + 1] - dist_[1];
@@ -225,7 +220,6 @@ S KDOP<S, N>::height() const
 
 //==============================================================================
 template <typename S, std::size_t N>
-FCL_EXPORT
 S KDOP<S, N>::depth() const
 {
   return dist_[N / 2 + 2] - dist_[2];
@@ -233,7 +227,6 @@ S KDOP<S, N>::depth() const
 
 //==============================================================================
 template <typename S, std::size_t N>
-FCL_EXPORT
 S KDOP<S, N>::volume() const
 {
   return width() * height() * depth();
@@ -241,7 +234,6 @@ S KDOP<S, N>::volume() const
 
 //==============================================================================
 template <typename S, std::size_t N>
-FCL_EXPORT
 S KDOP<S, N>::size() const
 {
   return width() * width() + height() * height() + depth() * depth();
@@ -249,7 +241,6 @@ S KDOP<S, N>::size() const
 
 //==============================================================================
 template <typename S, std::size_t N>
-FCL_EXPORT
 Vector3<S> KDOP<S, N>::center() const
 {
   return Vector3<S>(dist_[0] + dist_[N / 2], dist_[1] + dist_[N / 2 + 1], dist_[2] + dist_[N / 2 + 2]) * 0.5;
@@ -257,7 +248,6 @@ Vector3<S> KDOP<S, N>::center() const
 
 //==============================================================================
 template <typename S, std::size_t N>
-FCL_EXPORT
 S KDOP<S, N>::distance(const KDOP<S, N>& other, Vector3<S>* P, Vector3<S>* Q) const
 {
   FCL_UNUSED(other);
@@ -270,7 +260,6 @@ S KDOP<S, N>::distance(const KDOP<S, N>& other, Vector3<S>* P, Vector3<S>* Q) co
 
 //==============================================================================
 template <typename S, std::size_t N>
-FCL_EXPORT
 S KDOP<S, N>::dist(std::size_t i) const
 {
   return dist_[i];
@@ -278,7 +267,6 @@ S KDOP<S, N>::dist(std::size_t i) const
 
 //==============================================================================
 template <typename S, std::size_t N>
-FCL_EXPORT
 S& KDOP<S, N>::dist(std::size_t i)
 {
   return dist_[i];
@@ -286,7 +274,6 @@ S& KDOP<S, N>::dist(std::size_t i)
 
 //==============================================================================
 template <typename S, std::size_t N, typename Derived>
-FCL_EXPORT
 KDOP<S, N> translate(
     const KDOP<S, N>& bv, const Eigen::MatrixBase<Derived>& t)
 {
@@ -310,7 +297,6 @@ KDOP<S, N> translate(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void minmax(S a, S b, S& minv, S& maxv)
 {
   if(a > b)
@@ -327,7 +313,6 @@ void minmax(S a, S b, S& minv, S& maxv)
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void minmax(S p, S& minv, S& maxv)
 {
   if(p > maxv) maxv = p;
@@ -346,7 +331,6 @@ struct GetDistancesImpl
 
 //==============================================================================
 template <typename S, std::size_t N>
-FCL_EXPORT
 void getDistances(const Vector3<S>& p, S* d)
 {
   GetDistancesImpl<S, N>::run(p, d);
@@ -354,7 +338,7 @@ void getDistances(const Vector3<S>& p, S* d)
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT GetDistancesImpl<S, 5>
+struct GetDistancesImpl<S, 5>
 {
   static void run(const Vector3<S>& p, S* d)
   {
@@ -368,7 +352,7 @@ struct FCL_EXPORT GetDistancesImpl<S, 5>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT GetDistancesImpl<S, 6>
+struct GetDistancesImpl<S, 6>
 {
   static void run(const Vector3<S>& p, S* d)
   {
@@ -383,7 +367,7 @@ struct FCL_EXPORT GetDistancesImpl<S, 6>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT GetDistancesImpl<S, 9>
+struct GetDistancesImpl<S, 9>
 {
   static void run(const Vector3<S>& p, S* d)
   {
diff --git a/include/fcl/math/bv/kDOP.h b/include/fcl/math/bv/kDOP.h
index 54b7e9c..31dc4ba 100644
--- a/include/fcl/math/bv/kDOP.h
+++ b/include/fcl/math/bv/kDOP.h
@@ -47,7 +47,7 @@ namespace fcl
 {
 
 /// @brief KDOP class describes the KDOP collision structures. K is set as the template parameter, which should be 16, 18, or 24
-///  The KDOP structure is defined by some pairs of parallel planes defined by some axes. 
+///  The KDOP structure is defined by some pairs of parallel planes defined by some axes.
 /// For K = 16, the planes are 6 AABB planes and 10 diagonal planes that cut off some space of the edges:
 /// (-1,0,0) and (1,0,0)  -> indices 0 and 8
 /// (0,-1,0) and (0,1,0)  -> indices 1 and 9
@@ -81,7 +81,7 @@ namespace fcl
 /// (-1, 1, -1) and (1, -1, 1) --> indices 10 and 22
 /// (1, -1, -1) and (-1, 1, 1) --> indices 11 and 23
 template <typename S_, std::size_t N>
-class FCL_EXPORT KDOP
+class KDOP
 {
 public:
 
@@ -95,7 +95,7 @@ public:
 
   /// @brief Creating kDOP containing two points
   KDOP(const Vector3<S>& a, const Vector3<S>& b);
-  
+
   /// @brief Check whether two KDOPs are overlapped
   bool overlap(const KDOP<S, N>& other) const;
 
@@ -152,23 +152,19 @@ using KDOPd = KDOP<double, N>;
 
 /// @brief Find the smaller and larger one of two values
 template <typename S>
-FCL_EXPORT
 void minmax(S a, S b, S& minv, S& maxv);
 
 /// @brief Merge the interval [minv, maxv] and value p/
 template <typename S>
-FCL_EXPORT
 void minmax(S p, S& minv, S& maxv);
 
 /// @brief Compute the distances to planes with normals from KDOP vectors except
 /// those of AABB face planes
 template <typename S, std::size_t N>
-FCL_EXPORT
 void getDistances(const Vector3<S>& p, S* d);
 
 /// @brief translate the KDOP BV
 template <typename S, std::size_t N, typename Derived>
-FCL_EXPORT
 KDOP<S, N> translate(
     const KDOP<S, N>& bv, const Eigen::MatrixBase<Derived>& t);
 
diff --git a/include/fcl/math/bv/kIOS.h b/include/fcl/math/bv/kIOS.h
index 85f8933..0ce7ba4 100644
--- a/include/fcl/math/bv/kIOS.h
+++ b/include/fcl/math/bv/kIOS.h
@@ -42,10 +42,10 @@
 
 namespace fcl
 {
- 
+
 /// @brief A class describing the kIOS collision structure, which is a set of spheres.
 template <typename S_>
-class FCL_EXPORT kIOS
+class kIOS
 {
   /// @brief One sphere in kIOS
   struct kIOS_Sphere
@@ -126,7 +126,6 @@ using kIOSd = kIOS<double>;
 
 /// @brief Translate the kIOS BV
 template <typename S, typename Derived>
-FCL_EXPORT
 kIOS<S> translate(
     const kIOS<S>& bv, const Eigen::MatrixBase<Derived>& t);
 
@@ -134,7 +133,6 @@ kIOS<S> translate(
 /// and b2 is in identity.
 /// @todo Not efficient
 template <typename S, typename DerivedA, typename DerivedB>
-FCL_EXPORT
 bool overlap(
     const Eigen::MatrixBase<DerivedA>& R0,
     const Eigen::MatrixBase<DerivedB>& T0,
@@ -144,7 +142,6 @@ bool overlap(
 /// and b2 is in identity.
 /// @todo Not efficient
 template <typename S>
-FCL_EXPORT
 bool overlap(
     const Transform3<S>& tf,
     const kIOS<S>& b1,
@@ -153,7 +150,6 @@ bool overlap(
 /// @brief Approximate distance between two kIOS bounding volumes
 /// @todo P and Q is not returned, need implementation
 template <typename S, typename DerivedA, typename DerivedB>
-FCL_EXPORT
 S distance(
     const Eigen::MatrixBase<DerivedA>& R0,
     const Eigen::MatrixBase<DerivedB>& T0,
@@ -165,7 +161,6 @@ S distance(
 /// @brief Approximate distance between two kIOS bounding volumes
 /// @todo P and Q is not returned, need implementation
 template <typename S>
-FCL_EXPORT
 S distance(
     const Transform3<S>& tf,
     const kIOS<S>& b1,
diff --git a/include/fcl/math/bv/utility-inl.h b/include/fcl/math/bv/utility-inl.h
index eb8653c..a795ff0 100644
--- a/include/fcl/math/bv/utility-inl.h
+++ b/include/fcl/math/bv/utility-inl.h
@@ -62,7 +62,6 @@ namespace OBB_fit_functions {
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void fit1(const Vector3<S>* const ps, OBB<S>& bv)
 {
   bv.To = ps[0];
@@ -72,7 +71,6 @@ void fit1(const Vector3<S>* const ps, OBB<S>& bv)
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void fit2(const Vector3<S>* const ps, OBB<S>& bv)
 {
   const Vector3<S>& p1 = ps[0];
@@ -90,7 +88,6 @@ void fit2(const Vector3<S>* const ps, OBB<S>& bv)
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void fit3(const Vector3<S>* const ps, OBB<S>& bv)
 {
   const Vector3<S>& p1 = ps[0];
@@ -120,7 +117,6 @@ void fit3(const Vector3<S>* const ps, OBB<S>& bv)
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void fit6(const Vector3<S>* const ps, OBB<S>& bv)
 {
   OBB<S> bv1, bv2;
@@ -131,7 +127,6 @@ void fit6(const Vector3<S>* const ps, OBB<S>& bv)
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void fitn(const Vector3<S>* const ps, int n, OBB<S>& bv)
 {
   Matrix3<S> M;
@@ -148,22 +143,27 @@ void fitn(const Vector3<S>* const ps, int n, OBB<S>& bv)
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void fit1(const Vector3d* const ps, OBB<double>& bv);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void fit2(const Vector3d* const ps, OBB<double>& bv);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void fit3(const Vector3d* const ps, OBB<double>& bv);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void fit6(const Vector3d* const ps, OBB<double>& bv);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void fitn(const Vector3d* const ps, int n, OBB<double>& bv);
 
 //==============================================================================
@@ -176,7 +176,6 @@ namespace RSS_fit_functions {
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void fit1(const Vector3<S>* const ps, RSS<S>& bv)
 {
   bv.To = ps[0];
@@ -188,7 +187,6 @@ void fit1(const Vector3<S>* const ps, RSS<S>& bv)
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void fit2(const Vector3<S>* const ps, RSS<S>& bv)
 {
   const Vector3<S>& p1 = ps[0];
@@ -208,7 +206,6 @@ void fit2(const Vector3<S>* const ps, RSS<S>& bv)
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void fit3(const Vector3<S>* const ps, RSS<S>& bv)
 {
   const Vector3<S>& p1 = ps[0];
@@ -236,7 +233,6 @@ void fit3(const Vector3<S>* const ps, RSS<S>& bv)
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void fit6(const Vector3<S>* const ps, RSS<S>& bv)
 {
   RSS<S> bv1, bv2;
@@ -247,7 +243,6 @@ void fit6(const Vector3<S>* const ps, RSS<S>& bv)
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void fitn(const Vector3<S>* const ps, int n, RSS<S>& bv)
 {
   Matrix3<S> M; // row first matrix
@@ -297,7 +292,6 @@ namespace kIOS_fit_functions {
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void fit1(const Vector3<S>* const ps, kIOS<S>& bv)
 {
   bv.num_spheres = 1;
@@ -311,7 +305,6 @@ void fit1(const Vector3<S>* const ps, kIOS<S>& bv)
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void fit2(const Vector3<S>* const ps, kIOS<S>& bv)
 {
   bv.num_spheres = 5;
@@ -349,7 +342,6 @@ void fit2(const Vector3<S>* const ps, kIOS<S>& bv)
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void fit3(const Vector3<S>* const ps, kIOS<S>& bv)
 {
   bv.num_spheres = 3;
@@ -395,7 +387,6 @@ void fit3(const Vector3<S>* const ps, kIOS<S>& bv)
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void fitn(const Vector3<S>* const ps, int n, kIOS<S>& bv)
 {
   Matrix3<S> M;
@@ -491,7 +482,6 @@ namespace OBBRSS_fit_functions {
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void fit1(const Vector3<S>* const ps, OBBRSS<S>& bv)
 {
   OBB_fit_functions::fit1(ps, bv.obb);
@@ -500,7 +490,6 @@ void fit1(const Vector3<S>* const ps, OBBRSS<S>& bv)
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void fit2(const Vector3<S>* const ps, OBBRSS<S>& bv)
 {
   OBB_fit_functions::fit2(ps, bv.obb);
@@ -509,7 +498,6 @@ void fit2(const Vector3<S>* const ps, OBBRSS<S>& bv)
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void fit3(const Vector3<S>* const ps, OBBRSS<S>& bv)
 {
   OBB_fit_functions::fit3(ps, bv.obb);
@@ -518,7 +506,6 @@ void fit3(const Vector3<S>* const ps, OBBRSS<S>& bv)
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void fitn(const Vector3<S>* const ps, int n, OBBRSS<S>& bv)
 {
   OBB_fit_functions::fitn(ps, n, bv.obb);
@@ -527,18 +514,22 @@ void fitn(const Vector3<S>* const ps, int n, OBBRSS<S>& bv)
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void fit1(const Vector3d* const ps, OBBRSS<double>& bv);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void fit2(const Vector3d* const ps, OBBRSS<double>& bv);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void fit3(const Vector3d* const ps, OBBRSS<double>& bv);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void fitn(const Vector3d* const ps, int n, OBBRSS<double>& bv);
 
 //==============================================================================
@@ -547,7 +538,7 @@ void fitn(const Vector3d* const ps, int n, OBBRSS<double>& bv);
 
 //==============================================================================
 template <typename S, typename BV>
-struct FCL_EXPORT Fitter
+struct Fitter
 {
   static void fit(const Vector3<S>* const ps, int n, BV& bv)
   {
@@ -558,7 +549,7 @@ struct FCL_EXPORT Fitter
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT Fitter<S, OBB<S>>
+struct Fitter<S, OBB<S>>
 {
   static void fit(const Vector3<S>* const ps, int n, OBB<S>& bv)
   {
@@ -584,7 +575,7 @@ struct FCL_EXPORT Fitter<S, OBB<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT Fitter<S, RSS<S>>
+struct Fitter<S, RSS<S>>
 {
   static void fit(const Vector3<S>* const ps, int n, RSS<S>& bv)
   {
@@ -607,7 +598,7 @@ struct FCL_EXPORT Fitter<S, RSS<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT Fitter<S, kIOS<S>>
+struct Fitter<S, kIOS<S>>
 {
   static void fit(const Vector3<S>* const ps, int n, kIOS<S>& bv)
   {
@@ -630,7 +621,7 @@ struct FCL_EXPORT Fitter<S, kIOS<S>>
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT Fitter<S, OBBRSS<S>>
+struct Fitter<S, OBBRSS<S>>
 {
   static void fit(const Vector3<S>* const ps, int n, OBBRSS<S>& bv)
   {
@@ -653,19 +644,19 @@ struct FCL_EXPORT Fitter<S, OBBRSS<S>>
 
 //==============================================================================
 extern template
-struct Fitter<double, OBB<double>>;
+struct FCL_EXPORT Fitter<double, OBB<double>>;
 
 //==============================================================================
 extern template
-struct Fitter<double, RSS<double>>;
+struct FCL_EXPORT Fitter<double, RSS<double>>;
 
 //==============================================================================
 extern template
-struct Fitter<double, kIOS<double>>;
+struct FCL_EXPORT Fitter<double, kIOS<double>>;
 
 //==============================================================================
 extern template
-struct Fitter<double, OBBRSS<double>>;
+struct FCL_EXPORT Fitter<double, OBBRSS<double>>;
 
 //==============================================================================
 } // namespace detail
@@ -673,7 +664,6 @@ struct Fitter<double, OBBRSS<double>>;
 
 //==============================================================================
 template <typename BV>
-FCL_EXPORT
 void fit(const Vector3<typename BV::S>* const ps, int n, BV& bv)
 {
   detail::Fitter<typename BV::S, BV>::fit(ps, n, bv);
@@ -686,7 +676,7 @@ namespace detail {
 /// @brief Convert a bounding volume of type BV1 in configuration tf1 to a
 /// bounding volume of type BV2 in I configuration.
 template <typename S, typename BV1, typename BV2>
-class FCL_EXPORT ConvertBVImpl
+class ConvertBVImpl
 {
 private:
   static void run(const BV1& bv1, const Transform3<S>& tf1, BV2& bv2)
@@ -702,7 +692,7 @@ private:
 //==============================================================================
 /// @brief Convert from AABB to AABB, not very tight but is fast.
 template <typename S>
-class FCL_EXPORT ConvertBVImpl<S, AABB<S>, AABB<S>>
+class ConvertBVImpl<S, AABB<S>, AABB<S>>
 {
 public:
   static void run(const AABB<S>& bv1, const Transform3<S>& tf1, AABB<S>& bv2)
@@ -718,7 +708,7 @@ public:
 
 //==============================================================================
 template <typename S>
-class FCL_EXPORT ConvertBVImpl<S, AABB<S>, OBB<S>>
+class ConvertBVImpl<S, AABB<S>, OBB<S>>
 {
 public:
   static void run(const AABB<S>& bv1, const Transform3<S>& tf1, OBB<S>& bv2)
@@ -767,7 +757,7 @@ public:
 
 //==============================================================================
 template <typename S>
-class FCL_EXPORT ConvertBVImpl<S, OBB<S>, OBB<S>>
+class ConvertBVImpl<S, OBB<S>, OBB<S>>
 {
 public:
   static void run(const OBB<S>& bv1, const Transform3<S>& tf1, OBB<S>& bv2)
@@ -780,7 +770,7 @@ public:
 
 //==============================================================================
 template <typename S>
-class FCL_EXPORT ConvertBVImpl<S, OBBRSS<S>, OBB<S>>
+class ConvertBVImpl<S, OBBRSS<S>, OBB<S>>
 {
 public:
   static void run(const OBBRSS<S>& bv1, const Transform3<S>& tf1, OBB<S>& bv2)
@@ -791,7 +781,7 @@ public:
 
 //==============================================================================
 template <typename S>
-class FCL_EXPORT ConvertBVImpl<S, RSS<S>, OBB<S>>
+class ConvertBVImpl<S, RSS<S>, OBB<S>>
 {
 public:
   static void run(const RSS<S>& bv1, const Transform3<S>& tf1, OBB<S>& bv2)
@@ -804,7 +794,7 @@ public:
 
 //==============================================================================
 template <typename S, typename BV1>
-class FCL_EXPORT ConvertBVImpl<S, BV1, AABB<S>>
+class ConvertBVImpl<S, BV1, AABB<S>>
 {
 public:
   static void run(const BV1& bv1, const Transform3<S>& tf1, AABB<S>& bv2)
@@ -820,7 +810,7 @@ public:
 
 //==============================================================================
 template <typename S, typename BV1>
-class FCL_EXPORT ConvertBVImpl<S, BV1, OBB<S>>
+class ConvertBVImpl<S, BV1, OBB<S>>
 {
 public:
   static void run(const BV1& bv1, const Transform3<S>& tf1, OBB<S>& bv2)
@@ -833,7 +823,7 @@ public:
 
 //==============================================================================
 template <typename S>
-class FCL_EXPORT ConvertBVImpl<S, OBB<S>, RSS<S>>
+class ConvertBVImpl<S, OBB<S>, RSS<S>>
 {
 public:
   static void run(const OBB<S>& bv1, const Transform3<S>& tf1, RSS<S>& bv2)
@@ -849,7 +839,7 @@ public:
 
 //==============================================================================
 template <typename S>
-class FCL_EXPORT ConvertBVImpl<S, RSS<S>, RSS<S>>
+class ConvertBVImpl<S, RSS<S>, RSS<S>>
 {
 public:
   static void run(const RSS<S>& bv1, const Transform3<S>& tf1, RSS<S>& bv2)
@@ -865,7 +855,7 @@ public:
 
 //==============================================================================
 template <typename S>
-class FCL_EXPORT ConvertBVImpl<S, OBBRSS<S>, RSS<S>>
+class ConvertBVImpl<S, OBBRSS<S>, RSS<S>>
 {
 public:
   static void run(const OBBRSS<S>& bv1, const Transform3<S>& tf1, RSS<S>& bv2)
@@ -876,7 +866,7 @@ public:
 
 //==============================================================================
 template <typename S>
-class FCL_EXPORT ConvertBVImpl<S, AABB<S>, RSS<S>>
+class ConvertBVImpl<S, AABB<S>, RSS<S>>
 {
 public:
   static void run(const AABB<S>& bv1, const Transform3<S>& tf1, RSS<S>& bv2)
@@ -965,7 +955,6 @@ class FCL_EXPORT ConvertBVImpl<double, AABB<double>, RSS<double>>;
 
 //==============================================================================
 template <typename BV1, typename BV2>
-FCL_EXPORT
 void convertBV(
     const BV1& bv1, const Transform3<typename BV1::S>& tf1, BV2& bv2)
 {
diff --git a/include/fcl/math/bv/utility.h b/include/fcl/math/bv/utility.h
index 2cea40c..c10ffde 100644
--- a/include/fcl/math/bv/utility.h
+++ b/include/fcl/math/bv/utility.h
@@ -46,13 +46,11 @@ namespace fcl
 
 /// @brief Compute a bounding volume that fits a set of n points.
 template <typename BV>
-FCL_EXPORT
 void fit(const Vector3<typename BV::S>* const ps, int n, BV& bv);
 
 /// @brief Convert a bounding volume of type BV1 in configuration tf1 to
 /// bounding volume of type BV2 in identity configuration.
 template <typename BV1, typename BV2>
-FCL_EXPORT
 void convertBV(
     const BV1& bv1, const Transform3<typename BV1::S>& tf1, BV2& bv2);
 
diff --git a/include/fcl/math/constants.h b/include/fcl/math/constants.h
index 27ce5e0..1f91be7 100644
--- a/include/fcl/math/constants.h
+++ b/include/fcl/math/constants.h
@@ -126,7 +126,7 @@ struct ScalarTrait<float> {
 ///
 /// \tparam S The scalar type for which constant values will be retrieved.
 template <typename S>
-struct FCL_EXPORT constants
+struct constants
 {
 typedef typename detail::ScalarTrait<S>::type Real;
 
diff --git a/include/fcl/math/detail/polysolver-inl.h b/include/fcl/math/detail/polysolver-inl.h
index c2c538c..dccc6a9 100644
--- a/include/fcl/math/detail/polysolver-inl.h
+++ b/include/fcl/math/detail/polysolver-inl.h
@@ -1,201 +1,201 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#ifndef FCL_NARROWPHASE_DETAIL_POLYSOLVER_INL_H
-#define FCL_NARROWPHASE_DETAIL_POLYSOLVER_INL_H
-
-#include "fcl/math/detail/polysolver.h"
-
-#include <cmath>
-#include "fcl/common/types.h"
-
-namespace fcl
-{
-
-namespace detail {
-
-//==============================================================================
-extern template
-class FCL_EXPORT PolySolver<double>;
-
-//==============================================================================
-template <typename S>
-int PolySolver<S>::solveLinear(S c[2], S s[1])
-{
-  if(isZero(c[1]))
-    return 0;
-  s[0] = - c[0] / c[1];
-  return 1;
-}
-
-//==============================================================================
-template <typename S>
-int PolySolver<S>::solveQuadric(S c[3], S s[2])
-{
-  S p, q, D;
-
-  // make sure we have a d2 equation
-
-  if(isZero(c[2]))
-    return solveLinear(c, s);
-
-  // normal for: x^2 + px + q
-  p = c[1] / (2.0 * c[2]);
-  q = c[0] / c[2];
-  D = p * p - q;
-
-  if(isZero(D))
-  {
-    // one S root
-    s[0] = s[1] = -p;
-    return 1;
-  }
-
-  if(D < 0.0)
-    // no real root
-    return 0;
-  else
-  {
-    // two real roots
-    S sqrt_D = sqrt(D);
-    s[0] = sqrt_D - p;
-    s[1] = -sqrt_D - p;
-    return 2;
-  }
-}
-
-//==============================================================================
-template <typename S>
-int PolySolver<S>::solveCubic(S c[4], S s[3])
-{
-  int i, num;
-  S sub, A, B, C, sq_A, p, q, cb_p, D;
-  const S ONE_OVER_THREE = 1 / 3.0;
-  const S PI = 3.14159265358979323846;
-
-  // make sure we have a d2 equation
-  if(isZero(c[3]))
-    return solveQuadric(c, s);
-
-  // normalize the equation:x ^ 3 + Ax ^ 2 + Bx  + C = 0
-  A = c[2] / c[3];
-  B = c[1] / c[3];
-  C = c[0] / c[3];
-
-  // substitute x = y - A / 3 to eliminate the quadratic term: x^3 + px + q = 0
-  sq_A = A * A;
-  p = (-ONE_OVER_THREE * sq_A + B) * ONE_OVER_THREE;
-  q = 0.5 * (2.0 / 27.0 * A * sq_A - ONE_OVER_THREE * A * B + C);
-
-  // use Cardano's formula
-  cb_p = p * p * p;
-  D = q * q + cb_p;
-
-  if(isZero(D))
-  {
-    if(isZero(q))
-    {
-      // one triple solution
-      s[0] = 0.0;
-      num = 1;
-    }
-    else
-    {
-      // one single and one S solution
-      S u = cbrt(-q);
-      s[0] = 2.0 * u;
-      s[1] = -u;
-      num = 2;
-    }
-  }
-  else
-  {
-    if(D < 0.0)
-    {
-      // three real solutions
-      S phi = ONE_OVER_THREE * acos(-q / sqrt(-cb_p));
-      S t = 2.0 * sqrt(-p);
-      s[0] = t * cos(phi);
-      s[1] = -t * cos(phi + PI / 3.0);
-      s[2] = -t * cos(phi - PI / 3.0);
-      num = 3;
-    }
-    else
-    {
-      // one real solution
-      S sqrt_D = sqrt(D);
-      S u = cbrt(sqrt_D + fabs(q));
-      if(q > 0.0)
-        s[0] = - u + p / u ;
-      else
-        s[0] = u - p / u;
-      num = 1;
-    }
-  }
-
-  // re-substitute
-  sub = ONE_OVER_THREE * A;
-  for(i = 0; i < num; i++)
-    s[i] -= sub;
-  return num;
-}
-
-//==============================================================================
-template <typename S>
-bool PolySolver<S>::isZero(S v)
-{
-  return (v < getNearZeroThreshold()) && (v > -getNearZeroThreshold());
-}
-
-//==============================================================================
-template <typename S>
-bool PolySolver<S>::cbrt(S v)
-{
-  return std::pow(v, 1.0 / 3.0);
-}
-
-//==============================================================================
-template <typename S>
-constexpr S PolySolver<S>::getNearZeroThreshold()
-{
-  return 1e-9;
-}
-
-} // namespace detail
-} // namespace fcl
-
-#endif
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#ifndef FCL_NARROWPHASE_DETAIL_POLYSOLVER_INL_H
+#define FCL_NARROWPHASE_DETAIL_POLYSOLVER_INL_H
+
+#include "fcl/math/detail/polysolver.h"
+
+#include <cmath>
+#include "fcl/common/types.h"
+
+namespace fcl
+{
+
+namespace detail {
+
+//==============================================================================
+extern template
+class FCL_EXPORT PolySolver<double>;
+
+//==============================================================================
+template <typename S>
+int PolySolver<S>::solveLinear(S c[2], S s[1])
+{
+  if(isZero(c[1]))
+    return 0;
+  s[0] = - c[0] / c[1];
+  return 1;
+}
+
+//==============================================================================
+template <typename S>
+int PolySolver<S>::solveQuadric(S c[3], S s[2])
+{
+  S p, q, D;
+
+  // make sure we have a d2 equation
+
+  if(isZero(c[2]))
+    return solveLinear(c, s);
+
+  // normal for: x^2 + px + q
+  p = c[1] / (2.0 * c[2]);
+  q = c[0] / c[2];
+  D = p * p - q;
+
+  if(isZero(D))
+  {
+    // one S root
+    s[0] = s[1] = -p;
+    return 1;
+  }
+
+  if(D < 0.0)
+    // no real root
+    return 0;
+  else
+  {
+    // two real roots
+    S sqrt_D = sqrt(D);
+    s[0] = sqrt_D - p;
+    s[1] = -sqrt_D - p;
+    return 2;
+  }
+}
+
+//==============================================================================
+template <typename S>
+int PolySolver<S>::solveCubic(S c[4], S s[3])
+{
+  int i, num;
+  S sub, A, B, C, sq_A, p, q, cb_p, D;
+  const S ONE_OVER_THREE = 1 / 3.0;
+  const S PI = 3.14159265358979323846;
+
+  // make sure we have a d2 equation
+  if(isZero(c[3]))
+    return solveQuadric(c, s);
+
+  // normalize the equation:x ^ 3 + Ax ^ 2 + Bx  + C = 0
+  A = c[2] / c[3];
+  B = c[1] / c[3];
+  C = c[0] / c[3];
+
+  // substitute x = y - A / 3 to eliminate the quadratic term: x^3 + px + q = 0
+  sq_A = A * A;
+  p = (-ONE_OVER_THREE * sq_A + B) * ONE_OVER_THREE;
+  q = 0.5 * (2.0 / 27.0 * A * sq_A - ONE_OVER_THREE * A * B + C);
+
+  // use Cardano's formula
+  cb_p = p * p * p;
+  D = q * q + cb_p;
+
+  if(isZero(D))
+  {
+    if(isZero(q))
+    {
+      // one triple solution
+      s[0] = 0.0;
+      num = 1;
+    }
+    else
+    {
+      // one single and one S solution
+      S u = cbrt(-q);
+      s[0] = 2.0 * u;
+      s[1] = -u;
+      num = 2;
+    }
+  }
+  else
+  {
+    if(D < 0.0)
+    {
+      // three real solutions
+      S phi = ONE_OVER_THREE * acos(-q / sqrt(-cb_p));
+      S t = 2.0 * sqrt(-p);
+      s[0] = t * cos(phi);
+      s[1] = -t * cos(phi + PI / 3.0);
+      s[2] = -t * cos(phi - PI / 3.0);
+      num = 3;
+    }
+    else
+    {
+      // one real solution
+      S sqrt_D = sqrt(D);
+      S u = cbrt(sqrt_D + fabs(q));
+      if(q > 0.0)
+        s[0] = - u + p / u ;
+      else
+        s[0] = u - p / u;
+      num = 1;
+    }
+  }
+
+  // re-substitute
+  sub = ONE_OVER_THREE * A;
+  for(i = 0; i < num; i++)
+    s[i] -= sub;
+  return num;
+}
+
+//==============================================================================
+template <typename S>
+bool PolySolver<S>::isZero(S v)
+{
+  return (v < getNearZeroThreshold()) && (v > -getNearZeroThreshold());
+}
+
+//==============================================================================
+template <typename S>
+bool PolySolver<S>::cbrt(S v)
+{
+  return std::pow(v, 1.0 / 3.0);
+}
+
+//==============================================================================
+template <typename S>
+constexpr S PolySolver<S>::getNearZeroThreshold()
+{
+  return 1e-9;
+}
+
+} // namespace detail
+} // namespace fcl
+
+#endif
diff --git a/include/fcl/math/detail/polysolver.h b/include/fcl/math/detail/polysolver.h
index 52808a9..d79217f 100644
--- a/include/fcl/math/detail/polysolver.h
+++ b/include/fcl/math/detail/polysolver.h
@@ -1,80 +1,80 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#ifndef FCL_NARROWPHASE_DETAIL_POLYSOLVER_H
-#define FCL_NARROWPHASE_DETAIL_POLYSOLVER_H
-
-#include "fcl/export.h"
-
-namespace fcl
-{
-
-namespace detail {
-
-/// @brief A class solves polynomial degree (1,2,3) equations 
-template <typename S>
-class FCL_EXPORT PolySolver
-{
-public:
-  /// @brief Solve a linear equation with coefficients c, return roots s and number of roots 
-  static int solveLinear(S c[2], S s[1]);
-
-  /// @brief Solve a quadratic function with coefficients c, return roots s and number of roots 
-  static int solveQuadric(S c[3], S s[2]);
-
-  /// @brief Solve a cubic function with coefficients c, return roots s and number of roots 
-  static int solveCubic(S c[4], S s[3]);
-
-private:
-  /// @brief Check whether v is zero 
-  static bool isZero(S v);
-
-  /// @brief Compute v^{1/3} 
-  static bool cbrt(S v);
-
-  static constexpr S getNearZeroThreshold();
-};
-
-using PolySolverf = PolySolver<float>;
-using PolySolverd = PolySolver<double>;
-
-} // namespace detail
-} // namespace fcl
-
-#include "fcl/math/detail/polysolver-inl.h"
-
-#endif
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#ifndef FCL_NARROWPHASE_DETAIL_POLYSOLVER_H
+#define FCL_NARROWPHASE_DETAIL_POLYSOLVER_H
+
+#include "fcl/export.h"
+
+namespace fcl
+{
+
+namespace detail {
+
+/// @brief A class solves polynomial degree (1,2,3) equations
+template <typename S>
+class PolySolver
+{
+public:
+  /// @brief Solve a linear equation with coefficients c, return roots s and number of roots
+  static int solveLinear(S c[2], S s[1]);
+
+  /// @brief Solve a quadratic function with coefficients c, return roots s and number of roots
+  static int solveQuadric(S c[3], S s[2]);
+
+  /// @brief Solve a cubic function with coefficients c, return roots s and number of roots
+  static int solveCubic(S c[4], S s[3]);
+
+private:
+  /// @brief Check whether v is zero
+  static bool isZero(S v);
+
+  /// @brief Compute v^{1/3}
+  static bool cbrt(S v);
+
+  static constexpr S getNearZeroThreshold();
+};
+
+using PolySolverf = PolySolver<float>;
+using PolySolverd = PolySolver<double>;
+
+} // namespace detail
+} // namespace fcl
+
+#include "fcl/math/detail/polysolver-inl.h"
+
+#endif
diff --git a/include/fcl/math/detail/project-inl.h b/include/fcl/math/detail/project-inl.h
index abe4df6..64923fd 100644
--- a/include/fcl/math/detail/project-inl.h
+++ b/include/fcl/math/detail/project-inl.h
@@ -1,320 +1,320 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#ifndef FCL_NARROWPHASE_DETAIL_PROJECT_INL_H
-#define FCL_NARROWPHASE_DETAIL_PROJECT_INL_H
-
-#include "fcl/math/detail/project.h"
-
-namespace fcl
-{
-
-namespace detail
-{
-
-//==============================================================================
-extern template
-class FCL_EXPORT Project<double>;
-
-//==============================================================================
-template <typename S>
-typename Project<S>::ProjectResult Project<S>::projectLine(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& p)
-{
-  ProjectResult res;
-
-  const Vector3<S> d = b - a;
-  const S l = d.squaredNorm();
-
-  if(l > 0)
-  {
-    const S t = (p - a).dot(d);
-    res.parameterization[1] = (t >= l) ? 1 : ((t <= 0) ? 0 : (t / l));
-    res.parameterization[0] = 1 - res.parameterization[1];
-    if(t >= l) { res.sqr_distance = (p - b).squaredNorm(); res.encode = 2; /* 0x10 */ }
-    else if(t <= 0) { res.sqr_distance = (p - a).squaredNorm(); res.encode = 1; /* 0x01 */ }
-    else { res.sqr_distance = (a + d * res.parameterization[1] - p).squaredNorm(); res.encode = 3; /* 0x00 */ }
-  }
-
-  return res;
-}
-
-//==============================================================================
-template <typename S>
-typename Project<S>::ProjectResult Project<S>::projectTriangle(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& p)
-{
-  ProjectResult res;
-
-  static const size_t nexti[3] = {1, 2, 0};
-  const Vector3<S>* vt[] = {&a, &b, &c};
-  const Vector3<S> dl[] = {a - b, b - c, c - a};
-  const Vector3<S>& n = dl[0].cross(dl[1]);
-  const S l = n.squaredNorm();
-
-  if(l > 0)
-  {
-    S mindist = -1;
-    for(size_t i = 0; i < 3; ++i)
-    {
-      if((*vt[i] - p).dot(dl[i].cross(n)) > 0) // origin is to the outside part of the triangle edge, then the optimal can only be on the edge
-      {
-        size_t j = nexti[i];
-        ProjectResult res_line = projectLine(*vt[i], *vt[j], p);
-
-        if(mindist < 0 || res_line.sqr_distance < mindist)
-        {
-          mindist = res_line.sqr_distance;
-          res.encode = static_cast<size_t>(((res_line.encode&1)?1<<i:0) + ((res_line.encode&2)?1<<j:0));
-          res.parameterization[i] = res_line.parameterization[0];
-          res.parameterization[j] = res_line.parameterization[1];
-          res.parameterization[nexti[j]] = 0;
-        }
-      }
-    }
-
-    if(mindist < 0) // the origin project is within the triangle
-    {
-      S d = (a - p).dot(n);
-      S s = sqrt(l);
-      Vector3<S> p_to_project = n * (d / l);
-      mindist = p_to_project.squaredNorm();
-      res.encode = 7; // m = 0x111
-      res.parameterization[0] = dl[1].cross(b - p -p_to_project).norm() / s;
-      res.parameterization[1] = dl[2].cross(c - p -p_to_project).norm() / s;
-      res.parameterization[2] = 1 - res.parameterization[0] - res.parameterization[1];
-    }
-
-    res.sqr_distance = mindist;
-  }
-
-  return  res;
-
-}
-
-//==============================================================================
-template <typename S>
-typename Project<S>::ProjectResult Project<S>::projectTetrahedra(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& d, const Vector3<S>& p)
-{
-  ProjectResult res;
-
-  static const size_t nexti[] = {1, 2, 0};
-  const Vector3<S>* vt[] = {&a, &b, &c, &d};
-  const Vector3<S> dl[3] = {a-d, b-d, c-d};
-  S vl = triple(dl[0], dl[1], dl[2]);
-  bool ng = (vl * (a-p).dot((b-c).cross(a-b))) <= 0;
-  if(ng && std::abs(vl) > 0) // abs(vl) == 0, the tetrahedron is degenerated; if ng is false, then the last vertex in the tetrahedron does not grow toward the origin (in fact origin is on the other side of the abc face)
-  {
-    S mindist = -1;
-
-    for(size_t i = 0; i < 3; ++i)
-    {
-      size_t j = nexti[i];
-      S s = vl * (d-p).dot(dl[i].cross(dl[j]));
-      if(s > 0) // the origin is to the outside part of a triangle face, then the optimal can only be on the triangle face
-      {
-        ProjectResult res_triangle = projectTriangle(*vt[i], *vt[j], d, p);
-        if(mindist < 0 || res_triangle.sqr_distance < mindist)
-        {
-          mindist = res_triangle.sqr_distance;
-          res.encode = static_cast<size_t>( (res_triangle.encode&1?1<<i:0) + (res_triangle.encode&2?1<<j:0) + (res_triangle.encode&4?8:0) );
-          res.parameterization[i] = res_triangle.parameterization[0];
-          res.parameterization[j] = res_triangle.parameterization[1];
-          res.parameterization[nexti[j]] = 0;
-          res.parameterization[3] = res_triangle.parameterization[2];
-        }
-      }
-    }
-
-    if(mindist < 0)
-    {
-      mindist = 0;
-      res.encode = 15;
-      res.parameterization[0] = triple(c - p, b - p, d - p) / vl;
-      res.parameterization[1] = triple(a - p, c - p, d - p) / vl;
-      res.parameterization[2] = triple(b - p, a - p, d - p) / vl;
-      res.parameterization[3] = 1 - (res.parameterization[0] + res.parameterization[1] + res.parameterization[2]);
-    }
-
-    res.sqr_distance = mindist;
-  }
-  else if(!ng)
-  {
-    res = projectTriangle(a, b, c, p);
-    res.parameterization[3] = 0;
-  }
-  return res;
-}
-
-//==============================================================================
-template <typename S>
-typename Project<S>::ProjectResult Project<S>::projectLineOrigin(const Vector3<S>& a, const Vector3<S>& b)
-{
-  ProjectResult res;
-
-  const Vector3<S> d = b - a;
-  const S l = d.squaredNorm();
-
-  if(l > 0)
-  {
-    const S t = - a.dot(d);
-    res.parameterization[1] = (t >= l) ? 1 : ((t <= 0) ? 0 : (t / l));
-    res.parameterization[0] = 1 - res.parameterization[1];
-    if(t >= l) { res.sqr_distance = b.squaredNorm(); res.encode = 2; /* 0x10 */ }
-    else if(t <= 0) { res.sqr_distance = a.squaredNorm(); res.encode = 1; /* 0x01 */ }
-    else { res.sqr_distance = (a + d * res.parameterization[1]).squaredNorm(); res.encode = 3; /* 0x00 */ }
-  }
-
-  return res;
-}
-
-//==============================================================================
-template <typename S>
-typename Project<S>::ProjectResult Project<S>::projectTriangleOrigin(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c)
-{
-  ProjectResult res;
-
-  static const size_t nexti[3] = {1, 2, 0};
-  const Vector3<S>* vt[] = {&a, &b, &c};
-  const Vector3<S> dl[] = {a - b, b - c, c - a};
-  const Vector3<S>& n = dl[0].cross(dl[1]);
-  const S l = n.squaredNorm();
-
-  if(l > 0)
-  {
-    S mindist = -1;
-    for(size_t i = 0; i < 3; ++i)
-    {
-      if(vt[i]->dot(dl[i].cross(n)) > 0) // origin is to the outside part of the triangle edge, then the optimal can only be on the edge
-      {
-        size_t j = nexti[i];
-        ProjectResult res_line = projectLineOrigin(*vt[i], *vt[j]);
-
-        if(mindist < 0 || res_line.sqr_distance < mindist)
-        {
-          mindist = res_line.sqr_distance;
-          res.encode = static_cast<size_t>(((res_line.encode&1)?1<<i:0) + ((res_line.encode&2)?1<<j:0));
-          res.parameterization[i] = res_line.parameterization[0];
-          res.parameterization[j] = res_line.parameterization[1];
-          res.parameterization[nexti[j]] = 0;
-        }
-      }
-    }
-
-    if(mindist < 0) // the origin project is within the triangle
-    {
-      S d = a.dot(n);
-      S s = sqrt(l);
-      Vector3<S> o_to_project = n * (d / l);
-      mindist = o_to_project.squaredNorm();
-      res.encode = 7; // m = 0x111
-      res.parameterization[0] = dl[1].cross(b - o_to_project).norm() / s;
-      res.parameterization[1] = dl[2].cross(c - o_to_project).norm() / s;
-      res.parameterization[2] = 1 - res.parameterization[0] - res.parameterization[1];
-    }
-
-    res.sqr_distance = mindist;
-  }
-
-  return  res;
-
-}
-
-//==============================================================================
-template <typename S>
-typename Project<S>::ProjectResult Project<S>::projectTetrahedraOrigin(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& d)
-{
-  ProjectResult res;
-
-  static const size_t nexti[] = {1, 2, 0};
-  const Vector3<S>* vt[] = {&a, &b, &c, &d};
-  const Vector3<S> dl[3] = {a-d, b-d, c-d};
-  S vl = triple(dl[0], dl[1], dl[2]);
-  bool ng = (vl * a.dot((b-c).cross(a-b))) <= 0;
-  if(ng && std::abs(vl) > 0) // abs(vl) == 0, the tetrahedron is degenerated; if ng is false, then the last vertex in the tetrahedron does not grow toward the origin (in fact origin is on the other side of the abc face)
-  {
-    S mindist = -1;
-
-    for(size_t i = 0; i < 3; ++i)
-    {
-      size_t j = nexti[i];
-      S s = vl * d.dot(dl[i].cross(dl[j]));
-      if(s > 0) // the origin is to the outside part of a triangle face, then the optimal can only be on the triangle face
-      {
-        ProjectResult res_triangle = projectTriangleOrigin(*vt[i], *vt[j], d);
-        if(mindist < 0 || res_triangle.sqr_distance < mindist)
-        {
-          mindist = res_triangle.sqr_distance;
-          res.encode = static_cast<size_t>( (res_triangle.encode&1?1<<i:0) + (res_triangle.encode&2?1<<j:0) + (res_triangle.encode&4?8:0) );
-          res.parameterization[i] = res_triangle.parameterization[0];
-          res.parameterization[j] = res_triangle.parameterization[1];
-          res.parameterization[nexti[j]] = 0;
-          res.parameterization[3] = res_triangle.parameterization[2];
-        }
-      }
-    }
-
-    if(mindist < 0)
-    {
-      mindist = 0;
-      res.encode = 15;
-      res.parameterization[0] = triple(c, b, d) / vl;
-      res.parameterization[1] = triple(a, c, d) / vl;
-      res.parameterization[2] = triple(b, a, d) / vl;
-      res.parameterization[3] = 1 - (res.parameterization[0] + res.parameterization[1] + res.parameterization[2]);
-    }
-
-    res.sqr_distance = mindist;
-  }
-  else if(!ng)
-  {
-    res = projectTriangleOrigin(a, b, c);
-    res.parameterization[3] = 0;
-  }
-  return res;
-}
-
-//==============================================================================
-template <typename S>
-Project<S>::ProjectResult::ProjectResult()
-  : parameterization{0.0, 0.0, 0.0, 0.0}, sqr_distance(-1), encode(0)
-{
-  // Do nothing
-}
-
-} // namespace detail
-} // namespace fcl
-
-#endif
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#ifndef FCL_NARROWPHASE_DETAIL_PROJECT_INL_H
+#define FCL_NARROWPHASE_DETAIL_PROJECT_INL_H
+
+#include "fcl/math/detail/project.h"
+
+namespace fcl
+{
+
+namespace detail
+{
+
+//==============================================================================
+extern template
+class FCL_EXPORT Project<double>;
+
+//==============================================================================
+template <typename S>
+typename Project<S>::ProjectResult Project<S>::projectLine(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& p)
+{
+  ProjectResult res;
+
+  const Vector3<S> d = b - a;
+  const S l = d.squaredNorm();
+
+  if(l > 0)
+  {
+    const S t = (p - a).dot(d);
+    res.parameterization[1] = (t >= l) ? 1 : ((t <= 0) ? 0 : (t / l));
+    res.parameterization[0] = 1 - res.parameterization[1];
+    if(t >= l) { res.sqr_distance = (p - b).squaredNorm(); res.encode = 2; /* 0x10 */ }
+    else if(t <= 0) { res.sqr_distance = (p - a).squaredNorm(); res.encode = 1; /* 0x01 */ }
+    else { res.sqr_distance = (a + d * res.parameterization[1] - p).squaredNorm(); res.encode = 3; /* 0x00 */ }
+  }
+
+  return res;
+}
+
+//==============================================================================
+template <typename S>
+typename Project<S>::ProjectResult Project<S>::projectTriangle(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& p)
+{
+  ProjectResult res;
+
+  static const size_t nexti[3] = {1, 2, 0};
+  const Vector3<S>* vt[] = {&a, &b, &c};
+  const Vector3<S> dl[] = {a - b, b - c, c - a};
+  const Vector3<S>& n = dl[0].cross(dl[1]);
+  const S l = n.squaredNorm();
+
+  if(l > 0)
+  {
+    S mindist = -1;
+    for(size_t i = 0; i < 3; ++i)
+    {
+      if((*vt[i] - p).dot(dl[i].cross(n)) > 0) // origin is to the outside part of the triangle edge, then the optimal can only be on the edge
+      {
+        size_t j = nexti[i];
+        ProjectResult res_line = projectLine(*vt[i], *vt[j], p);
+
+        if(mindist < 0 || res_line.sqr_distance < mindist)
+        {
+          mindist = res_line.sqr_distance;
+          res.encode = static_cast<size_t>(((res_line.encode&1)?1<<i:0) + ((res_line.encode&2)?1<<j:0));
+          res.parameterization[i] = res_line.parameterization[0];
+          res.parameterization[j] = res_line.parameterization[1];
+          res.parameterization[nexti[j]] = 0;
+        }
+      }
+    }
+
+    if(mindist < 0) // the origin project is within the triangle
+    {
+      S d = (a - p).dot(n);
+      S s = sqrt(l);
+      Vector3<S> p_to_project = n * (d / l);
+      mindist = p_to_project.squaredNorm();
+      res.encode = 7; // m = 0x111
+      res.parameterization[0] = dl[1].cross(b - p -p_to_project).norm() / s;
+      res.parameterization[1] = dl[2].cross(c - p -p_to_project).norm() / s;
+      res.parameterization[2] = 1 - res.parameterization[0] - res.parameterization[1];
+    }
+
+    res.sqr_distance = mindist;
+  }
+
+  return  res;
+
+}
+
+//==============================================================================
+template <typename S>
+typename Project<S>::ProjectResult Project<S>::projectTetrahedra(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& d, const Vector3<S>& p)
+{
+  ProjectResult res;
+
+  static const size_t nexti[] = {1, 2, 0};
+  const Vector3<S>* vt[] = {&a, &b, &c, &d};
+  const Vector3<S> dl[3] = {a-d, b-d, c-d};
+  S vl = triple(dl[0], dl[1], dl[2]);
+  bool ng = (vl * (a-p).dot((b-c).cross(a-b))) <= 0;
+  if(ng && std::abs(vl) > 0) // abs(vl) == 0, the tetrahedron is degenerated; if ng is false, then the last vertex in the tetrahedron does not grow toward the origin (in fact origin is on the other side of the abc face)
+  {
+    S mindist = -1;
+
+    for(size_t i = 0; i < 3; ++i)
+    {
+      size_t j = nexti[i];
+      S s = vl * (d-p).dot(dl[i].cross(dl[j]));
+      if(s > 0) // the origin is to the outside part of a triangle face, then the optimal can only be on the triangle face
+      {
+        ProjectResult res_triangle = projectTriangle(*vt[i], *vt[j], d, p);
+        if(mindist < 0 || res_triangle.sqr_distance < mindist)
+        {
+          mindist = res_triangle.sqr_distance;
+          res.encode = static_cast<size_t>( (res_triangle.encode&1?1<<i:0) + (res_triangle.encode&2?1<<j:0) + (res_triangle.encode&4?8:0) );
+          res.parameterization[i] = res_triangle.parameterization[0];
+          res.parameterization[j] = res_triangle.parameterization[1];
+          res.parameterization[nexti[j]] = 0;
+          res.parameterization[3] = res_triangle.parameterization[2];
+        }
+      }
+    }
+
+    if(mindist < 0)
+    {
+      mindist = 0;
+      res.encode = 15;
+      res.parameterization[0] = triple(c - p, b - p, d - p) / vl;
+      res.parameterization[1] = triple(a - p, c - p, d - p) / vl;
+      res.parameterization[2] = triple(b - p, a - p, d - p) / vl;
+      res.parameterization[3] = 1 - (res.parameterization[0] + res.parameterization[1] + res.parameterization[2]);
+    }
+
+    res.sqr_distance = mindist;
+  }
+  else if(!ng)
+  {
+    res = projectTriangle(a, b, c, p);
+    res.parameterization[3] = 0;
+  }
+  return res;
+}
+
+//==============================================================================
+template <typename S>
+typename Project<S>::ProjectResult Project<S>::projectLineOrigin(const Vector3<S>& a, const Vector3<S>& b)
+{
+  ProjectResult res;
+
+  const Vector3<S> d = b - a;
+  const S l = d.squaredNorm();
+
+  if(l > 0)
+  {
+    const S t = - a.dot(d);
+    res.parameterization[1] = (t >= l) ? 1 : ((t <= 0) ? 0 : (t / l));
+    res.parameterization[0] = 1 - res.parameterization[1];
+    if(t >= l) { res.sqr_distance = b.squaredNorm(); res.encode = 2; /* 0x10 */ }
+    else if(t <= 0) { res.sqr_distance = a.squaredNorm(); res.encode = 1; /* 0x01 */ }
+    else { res.sqr_distance = (a + d * res.parameterization[1]).squaredNorm(); res.encode = 3; /* 0x00 */ }
+  }
+
+  return res;
+}
+
+//==============================================================================
+template <typename S>
+typename Project<S>::ProjectResult Project<S>::projectTriangleOrigin(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c)
+{
+  ProjectResult res;
+
+  static const size_t nexti[3] = {1, 2, 0};
+  const Vector3<S>* vt[] = {&a, &b, &c};
+  const Vector3<S> dl[] = {a - b, b - c, c - a};
+  const Vector3<S>& n = dl[0].cross(dl[1]);
+  const S l = n.squaredNorm();
+
+  if(l > 0)
+  {
+    S mindist = -1;
+    for(size_t i = 0; i < 3; ++i)
+    {
+      if(vt[i]->dot(dl[i].cross(n)) > 0) // origin is to the outside part of the triangle edge, then the optimal can only be on the edge
+      {
+        size_t j = nexti[i];
+        ProjectResult res_line = projectLineOrigin(*vt[i], *vt[j]);
+
+        if(mindist < 0 || res_line.sqr_distance < mindist)
+        {
+          mindist = res_line.sqr_distance;
+          res.encode = static_cast<size_t>(((res_line.encode&1)?1<<i:0) + ((res_line.encode&2)?1<<j:0));
+          res.parameterization[i] = res_line.parameterization[0];
+          res.parameterization[j] = res_line.parameterization[1];
+          res.parameterization[nexti[j]] = 0;
+        }
+      }
+    }
+
+    if(mindist < 0) // the origin project is within the triangle
+    {
+      S d = a.dot(n);
+      S s = sqrt(l);
+      Vector3<S> o_to_project = n * (d / l);
+      mindist = o_to_project.squaredNorm();
+      res.encode = 7; // m = 0x111
+      res.parameterization[0] = dl[1].cross(b - o_to_project).norm() / s;
+      res.parameterization[1] = dl[2].cross(c - o_to_project).norm() / s;
+      res.parameterization[2] = 1 - res.parameterization[0] - res.parameterization[1];
+    }
+
+    res.sqr_distance = mindist;
+  }
+
+  return  res;
+
+}
+
+//==============================================================================
+template <typename S>
+typename Project<S>::ProjectResult Project<S>::projectTetrahedraOrigin(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& d)
+{
+  ProjectResult res;
+
+  static const size_t nexti[] = {1, 2, 0};
+  const Vector3<S>* vt[] = {&a, &b, &c, &d};
+  const Vector3<S> dl[3] = {a-d, b-d, c-d};
+  S vl = triple(dl[0], dl[1], dl[2]);
+  bool ng = (vl * a.dot((b-c).cross(a-b))) <= 0;
+  if(ng && std::abs(vl) > 0) // abs(vl) == 0, the tetrahedron is degenerated; if ng is false, then the last vertex in the tetrahedron does not grow toward the origin (in fact origin is on the other side of the abc face)
+  {
+    S mindist = -1;
+
+    for(size_t i = 0; i < 3; ++i)
+    {
+      size_t j = nexti[i];
+      S s = vl * d.dot(dl[i].cross(dl[j]));
+      if(s > 0) // the origin is to the outside part of a triangle face, then the optimal can only be on the triangle face
+      {
+        ProjectResult res_triangle = projectTriangleOrigin(*vt[i], *vt[j], d);
+        if(mindist < 0 || res_triangle.sqr_distance < mindist)
+        {
+          mindist = res_triangle.sqr_distance;
+          res.encode = static_cast<size_t>( (res_triangle.encode&1?1<<i:0) + (res_triangle.encode&2?1<<j:0) + (res_triangle.encode&4?8:0) );
+          res.parameterization[i] = res_triangle.parameterization[0];
+          res.parameterization[j] = res_triangle.parameterization[1];
+          res.parameterization[nexti[j]] = 0;
+          res.parameterization[3] = res_triangle.parameterization[2];
+        }
+      }
+    }
+
+    if(mindist < 0)
+    {
+      mindist = 0;
+      res.encode = 15;
+      res.parameterization[0] = triple(c, b, d) / vl;
+      res.parameterization[1] = triple(a, c, d) / vl;
+      res.parameterization[2] = triple(b, a, d) / vl;
+      res.parameterization[3] = 1 - (res.parameterization[0] + res.parameterization[1] + res.parameterization[2]);
+    }
+
+    res.sqr_distance = mindist;
+  }
+  else if(!ng)
+  {
+    res = projectTriangleOrigin(a, b, c);
+    res.parameterization[3] = 0;
+  }
+  return res;
+}
+
+//==============================================================================
+template <typename S>
+Project<S>::ProjectResult::ProjectResult()
+  : parameterization{0.0, 0.0, 0.0, 0.0}, sqr_distance(-1), encode(0)
+{
+  // Do nothing
+}
+
+} // namespace detail
+} // namespace fcl
+
+#endif
diff --git a/include/fcl/math/detail/project.h b/include/fcl/math/detail/project.h
index 39311f2..c08f065 100644
--- a/include/fcl/math/detail/project.h
+++ b/include/fcl/math/detail/project.h
@@ -1,96 +1,96 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#ifndef FCL_NARROWPHASE_DETAIL_PROJECT_H
-#define FCL_NARROWPHASE_DETAIL_PROJECT_H
-
-#include "fcl/common/types.h"
-#include "fcl/math/geometry.h"
-
-namespace fcl
-{
-
-namespace detail
-{
-
-/// @brief Project functions
-template <typename S>
-class FCL_EXPORT Project
-{
-public:
-  struct ProjectResult
-  {
-    /// @brief Parameterization of the projected point (based on the simplex to be projected, use 2 or 3 or 4 of the array)
-    S parameterization[4];
-
-    /// @brief square distance from the query point to the projected simplex
-    S sqr_distance;
-
-    /// @brief the code of the projection type
-    unsigned int encode;
-
-    ProjectResult();
-  };
-
-  /// @brief Project point p onto line a-b
-  static ProjectResult projectLine(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& p);
-
-  /// @brief Project point p onto triangle a-b-c
-  static ProjectResult projectTriangle(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& p);
-
-  /// @brief Project point p onto tetrahedra a-b-c-d
-  static ProjectResult projectTetrahedra(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& d, const Vector3<S>& p);
-
-  /// @brief Project origin (0) onto line a-b
-  static ProjectResult projectLineOrigin(const Vector3<S>& a, const Vector3<S>& b);
-
-  /// @brief Project origin (0) onto triangle a-b-c
-  static ProjectResult projectTriangleOrigin(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c);
-
-  /// @brief Project origin (0) onto tetrahedran a-b-c-d
-  static ProjectResult projectTetrahedraOrigin(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& d);
-};
-
-using Projectf = Project<float>;
-using Projectd = Project<double>;
-
-} // namespace detail
-} // namespace fcl
-
-#include "fcl/math/detail/project-inl.h"
-
-#endif
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#ifndef FCL_NARROWPHASE_DETAIL_PROJECT_H
+#define FCL_NARROWPHASE_DETAIL_PROJECT_H
+
+#include "fcl/common/types.h"
+#include "fcl/math/geometry.h"
+
+namespace fcl
+{
+
+namespace detail
+{
+
+/// @brief Project functions
+template <typename S>
+class Project
+{
+public:
+  struct ProjectResult
+  {
+    /// @brief Parameterization of the projected point (based on the simplex to be projected, use 2 or 3 or 4 of the array)
+    S parameterization[4];
+
+    /// @brief square distance from the query point to the projected simplex
+    S sqr_distance;
+
+    /// @brief the code of the projection type
+    unsigned int encode;
+
+    ProjectResult();
+  };
+
+  /// @brief Project point p onto line a-b
+  static ProjectResult projectLine(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& p);
+
+  /// @brief Project point p onto triangle a-b-c
+  static ProjectResult projectTriangle(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& p);
+
+  /// @brief Project point p onto tetrahedra a-b-c-d
+  static ProjectResult projectTetrahedra(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& d, const Vector3<S>& p);
+
+  /// @brief Project origin (0) onto line a-b
+  static ProjectResult projectLineOrigin(const Vector3<S>& a, const Vector3<S>& b);
+
+  /// @brief Project origin (0) onto triangle a-b-c
+  static ProjectResult projectTriangleOrigin(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c);
+
+  /// @brief Project origin (0) onto tetrahedran a-b-c-d
+  static ProjectResult projectTetrahedraOrigin(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& d);
+};
+
+using Projectf = Project<float>;
+using Projectd = Project<double>;
+
+} // namespace detail
+} // namespace fcl
+
+#include "fcl/math/detail/project-inl.h"
+
+#endif
diff --git a/include/fcl/math/geometry-inl.h b/include/fcl/math/geometry-inl.h
index 2aa5ffa..9c7e65a 100644
--- a/include/fcl/math/geometry-inl.h
+++ b/include/fcl/math/geometry-inl.h
@@ -44,41 +44,50 @@ namespace fcl {
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void normalize(Vector3d& v, bool* signal);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void hat(Matrix3d& mat, const Vector3d& vec);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void eigen(const Matrix3d& m, Vector3d& dout, Matrix3d& vout);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void eigen_old(const Matrix3d& m, Vector3d& dout, Matrix3d& vout);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void axisFromEigen(
     const Matrix3d& eigenV, const Vector3d& eigenS, Matrix3d& axis);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void axisFromEigen(const Matrix3d& eigenV,
                    const Vector3d& eigenS,
                    Transform3d& tf);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void generateCoordinateSystem(Matrix3d& axis);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void generateCoordinateSystem(Transform3d& tf);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void getRadiusAndOriginAndRectangleSize(
     const Vector3d* const ps,
     const Vector3d* const ps2,
@@ -92,6 +101,7 @@ void getRadiusAndOriginAndRectangleSize(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void getRadiusAndOriginAndRectangleSize(
     const Vector3d* const ps,
     const Vector3d* const ps2,
@@ -104,6 +114,7 @@ void getRadiusAndOriginAndRectangleSize(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void circumCircleComputation(
     const Vector3d& a,
     const Vector3d& b,
@@ -113,6 +124,7 @@ void circumCircleComputation(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 double maximumDistance(
     const Vector3d* const ps,
     const Vector3d* const ps2,
@@ -123,6 +135,7 @@ double maximumDistance(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void getExtentAndCenter(
     const Vector3d* const ps,
     const Vector3d* const ps2,
@@ -135,6 +148,7 @@ void getExtentAndCenter(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void getCovariance(
     const Vector3d* const ps,
     const Vector3d* const ps2,
@@ -148,7 +162,6 @@ namespace detail {
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 S maximumDistance_mesh(
     const Vector3<S>* const ps,
     const Vector3<S>* const ps2,
@@ -193,7 +206,6 @@ S maximumDistance_mesh(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 S maximumDistance_pointcloud(
     const Vector3<S>* const ps,
     const Vector3<S>* const ps2,
@@ -228,7 +240,6 @@ S maximumDistance_pointcloud(
 /// @brief Compute the bounding volume extent and center for a set or subset of
 /// points. The bounding volume axes are known.
 template <typename S>
-FCL_EXPORT
 void getExtentAndCenter_pointcloud(
     const Vector3<S>* const ps,
     const Vector3<S>* const ps2,
@@ -293,7 +304,6 @@ void getExtentAndCenter_pointcloud(
 /// @brief Compute the bounding volume extent and center for a set or subset of
 /// points. The bounding volume axes are known.
 template <typename S>
-FCL_EXPORT
 void getExtentAndCenter_mesh(
     const Vector3<S>* const ps,
     const Vector3<S>* const ps2,
@@ -366,6 +376,7 @@ void getExtentAndCenter_mesh(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 double maximumDistance_mesh(
     const Vector3d* const ps,
     const Vector3d* const ps2,
@@ -376,6 +387,7 @@ double maximumDistance_mesh(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 double maximumDistance_pointcloud(
     const Vector3d* const ps,
     const Vector3d* const ps2,
@@ -385,6 +397,7 @@ double maximumDistance_pointcloud(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void getExtentAndCenter_pointcloud(
     const Vector3d* const ps,
     const Vector3d* const ps2,
@@ -396,6 +409,7 @@ void getExtentAndCenter_pointcloud(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void getExtentAndCenter_mesh(
     const Vector3d* const ps,
     const Vector3d* const ps2,
@@ -412,7 +426,6 @@ void getExtentAndCenter_mesh(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void normalize(Vector3<S>& v, bool* signal)
 {
   S sqr_length = v.squaredNorm();
@@ -430,7 +443,6 @@ void normalize(Vector3<S>& v, bool* signal)
 
 //==============================================================================
 template <typename Derived>
-FCL_EXPORT
 typename Derived::RealScalar triple(const Eigen::MatrixBase<Derived>& x,
                                     const Eigen::MatrixBase<Derived>& y,
                                     const Eigen::MatrixBase<Derived>& z)
@@ -440,7 +452,6 @@ typename Derived::RealScalar triple(const Eigen::MatrixBase<Derived>& x,
 
 //==============================================================================
 template <typename Derived>
-FCL_EXPORT
 void generateCoordinateSystem(
     const Eigen::MatrixBase<Derived>& w,
     Eigen::MatrixBase<Derived>& u,
@@ -472,7 +483,6 @@ void generateCoordinateSystem(
 
 //==============================================================================
 template <typename S, int M, int N>
-FCL_EXPORT
 VectorN<S, M+N> combine(
     const VectorN<S, M>& v1, const VectorN<S, N>& v2)
 {
@@ -484,7 +494,6 @@ VectorN<S, M+N> combine(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void hat(Matrix3<S>& mat, const Vector3<S>& vec)
 {
   mat << 0, -vec[2], vec[1], vec[2], 0, -vec[0], -vec[1], vec[0], 0;
@@ -492,7 +501,6 @@ void hat(Matrix3<S>& mat, const Vector3<S>& vec)
 
 //==============================================================================
 template<typename S>
-FCL_EXPORT
 void eigen(const Matrix3<S>& m, Vector3<S>& dout, Matrix3<S>& vout)
 {
   // We assume that m is symmetric matrix.
@@ -508,7 +516,6 @@ void eigen(const Matrix3<S>& m, Vector3<S>& dout, Matrix3<S>& vout)
 
 //==============================================================================
 template<typename S>
-FCL_EXPORT
 void eigen_old(const Matrix3<S>& m, Vector3<S>& dout, Matrix3<S>& vout)
 {
   Matrix3<S> R(m);
@@ -598,7 +605,6 @@ void eigen_old(const Matrix3<S>& m, Vector3<S>& dout, Matrix3<S>& vout)
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void axisFromEigen(const Matrix3<S>& eigenV,
                    const Vector3<S>& eigenS,
                    Matrix3<S>& axis)
@@ -638,7 +644,6 @@ void axisFromEigen(const Matrix3<S>& eigenV,
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void axisFromEigen(const Matrix3<S>& eigenV,
                    const Vector3<S>& eigenS,
                    Transform3<S>& tf)
@@ -678,7 +683,6 @@ void axisFromEigen(const Matrix3<S>& eigenV,
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void generateCoordinateSystem(Matrix3<S>& axis)
 {
   // Assum axis.col(0) is closest to z-axis
@@ -724,7 +728,6 @@ void generateCoordinateSystem(Matrix3<S>& axis)
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void generateCoordinateSystem(Transform3<S>& tf)
 {
   // Assum axis.col(0) is closest to z-axis
@@ -770,7 +773,6 @@ void generateCoordinateSystem(Transform3<S>& tf)
 
 //==============================================================================
 template <typename DerivedA, typename DerivedB, typename DerivedC, typename DerivedD>
-FCL_EXPORT
 void relativeTransform(
     const Eigen::MatrixBase<DerivedA>& R1, const Eigen::MatrixBase<DerivedB>& t1,
     const Eigen::MatrixBase<DerivedA>& R2, const Eigen::MatrixBase<DerivedB>& t2,
@@ -802,7 +804,6 @@ void relativeTransform(
 
 //==============================================================================
 template <typename S, typename DerivedA, typename DerivedB>
-FCL_EXPORT
 void relativeTransform(
     const Transform3<S>& T1,
     const Transform3<S>& T2,
@@ -824,7 +825,6 @@ void relativeTransform(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void getRadiusAndOriginAndRectangleSize(
     const Vector3<S>* const ps,
     const Vector3<S>* const ps2,
@@ -1107,7 +1107,6 @@ void getRadiusAndOriginAndRectangleSize(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void getRadiusAndOriginAndRectangleSize(
     const Vector3<S>* const ps,
     const Vector3<S>* const ps2,
@@ -1389,7 +1388,6 @@ void getRadiusAndOriginAndRectangleSize(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void circumCircleComputation(
     const Vector3<S>& a,
     const Vector3<S>& b,
@@ -1414,7 +1412,6 @@ void circumCircleComputation(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 S maximumDistance(
     const Vector3<S>* const ps,
     const Vector3<S>* const ps2,
@@ -1431,7 +1428,6 @@ S maximumDistance(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void getExtentAndCenter(
     const Vector3<S>* const ps,
     const Vector3<S>* const ps2,
@@ -1450,7 +1446,6 @@ void getExtentAndCenter(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void getCovariance(
     const Vector3<S>* const ps,
     const Vector3<S>* const ps2,
diff --git a/include/fcl/math/geometry.h b/include/fcl/math/geometry.h
index c119c74..4a1162b 100644
--- a/include/fcl/math/geometry.h
+++ b/include/fcl/math/geometry.h
@@ -49,72 +49,59 @@
 namespace fcl {
 
 template <typename S>
-FCL_EXPORT
 void normalize(Vector3<S>& v, bool* signal);
 
 template <typename Derived>
-FCL_EXPORT
 typename Derived::RealScalar triple(const Eigen::MatrixBase<Derived>& x,
                                     const Eigen::MatrixBase<Derived>& y,
                                     const Eigen::MatrixBase<Derived>& z);
 
 template <typename Derived>
-FCL_EXPORT
 void generateCoordinateSystem(
     const Eigen::MatrixBase<Derived>& w,
     Eigen::MatrixBase<Derived>& u,
     Eigen::MatrixBase<Derived>& v);
 
 template <typename S, int M, int N>
-FCL_EXPORT
 VectorN<S, M+N> combine(
     const VectorN<S, M>& v1, const VectorN<S, N>& v2);
 
 template <typename S>
-FCL_EXPORT
 void hat(Matrix3<S>& mat, const Vector3<S>& vec);
 
 /// @brief compute the eigen vector and eigen vector of a matrix. dout is the
 /// eigen values, vout is the eigen vectors
 template <typename S>
-FCL_EXPORT
 void eigen(const Matrix3<S>& m, Vector3<S>& dout, Matrix3<S>& vout);
 
 /// @brief compute the eigen vector and eigen vector of a matrix. dout is the
 /// eigen values, vout is the eigen vectors
 template<typename S>
-FCL_EXPORT
 void eigen_old(const Matrix3<S>& m, Vector3<S>& dout, Matrix3<S>& vout);
 
 template <typename S>
-FCL_EXPORT
 void axisFromEigen(const Matrix3<S>& eigenV,
                    const Vector3<S>& eigenS,
                    Matrix3<S>& axis);
 
 template <typename S>
-FCL_EXPORT
 void axisFromEigen(const Matrix3<S>& eigenV,
                    const Vector3<S>& eigenS,
                    Transform3<S>& tf);
 
 template <typename S>
-FCL_EXPORT
 void generateCoordinateSystem(Matrix3<S>& axis);
 
 template <typename S>
-FCL_EXPORT
 void generateCoordinateSystem(Transform3<S>& tf);
 
 template <typename DerivedA, typename DerivedB, typename DerivedC, typename DerivedD>
-FCL_EXPORT
 void relativeTransform(
     const Eigen::MatrixBase<DerivedA>& R1, const Eigen::MatrixBase<DerivedB>& t1,
     const Eigen::MatrixBase<DerivedA>& R2, const Eigen::MatrixBase<DerivedB>& t2,
     Eigen::MatrixBase<DerivedC>& R, Eigen::MatrixBase<DerivedD>& t);
 
 template <typename S, typename DerivedA, typename DerivedB>
-FCL_EXPORT
 void relativeTransform(
     const Eigen::Transform<S, 3, Eigen::Isometry>& T1,
     const Eigen::Transform<S, 3, Eigen::Isometry>& T2,
@@ -123,7 +110,6 @@ void relativeTransform(
 /// @brief Compute the RSS bounding volume parameters: radius, rectangle size
 /// and the origin, given the BV axises.
 template <typename S>
-FCL_EXPORT
 void getRadiusAndOriginAndRectangleSize(
     const Vector3<S>* const ps,
     const Vector3<S>* const ps2,
@@ -138,7 +124,6 @@ void getRadiusAndOriginAndRectangleSize(
 /// @brief Compute the RSS bounding volume parameters: radius, rectangle size
 /// and the origin, given the BV axises.
 template <typename S>
-FCL_EXPORT
 void getRadiusAndOriginAndRectangleSize(
     const Vector3<S>* const ps,
     const Vector3<S>* const ps2,
@@ -151,7 +136,6 @@ void getRadiusAndOriginAndRectangleSize(
 
 /// @brief Compute the center and radius for a triangle's circumcircle
 template <typename S>
-FCL_EXPORT
 void circumCircleComputation(
     const Vector3<S>& a,
     const Vector3<S>& b,
@@ -161,7 +145,6 @@ void circumCircleComputation(
 
 /// @brief Compute the maximum distance from a given center point to a point cloud
 template <typename S>
-FCL_EXPORT
 S maximumDistance(
     const Vector3<S>* const ps,
     const Vector3<S>* const ps2,
@@ -173,7 +156,6 @@ S maximumDistance(
 /// @brief Compute the bounding volume extent and center for a set or subset of
 /// points, given the BV axises.
 template <typename S>
-FCL_EXPORT
 void getExtentAndCenter(
     const Vector3<S>* const ps,
     const Vector3<S>* const ps2,
@@ -187,7 +169,6 @@ void getExtentAndCenter(
 /// @brief Compute the bounding volume extent and center for a set or subset of
 /// points, given the BV axises.
 template <typename S>
-FCL_EXPORT
 void getExtentAndCenter(
     const Vector3<S>* const ps,
     const Vector3<S>* const ps2,
@@ -201,7 +182,6 @@ void getExtentAndCenter(
 /// ts = null, then indices refer to points directly; otherwise refer to
 /// triangles
 template <typename S>
-FCL_EXPORT
 void getCovariance(
     const Vector3<S>* const ps,
     const Vector3<S>* const ps2,
diff --git a/include/fcl/math/motion/bv_motion_bound_visitor.h b/include/fcl/math/motion/bv_motion_bound_visitor.h
index cecfe06..e60d3c2 100644
--- a/include/fcl/math/motion/bv_motion_bound_visitor.h
+++ b/include/fcl/math/motion/bv_motion_bound_visitor.h
@@ -59,7 +59,7 @@ class TranslationMotion;
 /// @brief Compute the motion bound for a bounding volume, given the closest
 /// direction n between two query objects
 template <typename S>
-class FCL_EXPORT BVMotionBoundVisitor
+class BVMotionBoundVisitor
 {
 public:
   virtual S visit(const MotionBase<S>& motion) const = 0;
diff --git a/include/fcl/math/motion/interp_motion.h b/include/fcl/math/motion/interp_motion.h
index a7f58eb..55ec717 100644
--- a/include/fcl/math/motion/interp_motion.h
+++ b/include/fcl/math/motion/interp_motion.h
@@ -55,7 +55,7 @@ namespace fcl
 ///            T(0) = T0 + R0 p_ref - p_ref
 ///            T(1) = T1 + R1 p_ref - p_ref
 template <typename S>
-class FCL_EXPORT InterpMotion : public MotionBase<S>
+class InterpMotion : public MotionBase<S>
 {
 public:
   /// @brief Default transformations are all identities
@@ -81,7 +81,7 @@ public:
   /// @brief Compute the motion bound for a bounding volume along a given direction n, which is defined in the visitor
   S computeMotionBound(const BVMotionBoundVisitor<S>& mb_visitor) const;
 
-  /// @brief Compute the motion bound for a triangle along a given direction n, which is defined in the visitor 
+  /// @brief Compute the motion bound for a triangle along a given direction n, which is defined in the visitor
   S computeMotionBound(const TriangleMotionBoundVisitor<S>& mb_visitor) const;
 
   /// @brief Get the rotation and translation in current step
@@ -94,9 +94,9 @@ protected:
   void computeVelocity();
 
   Quaternion<S> deltaRotation(S dt) const;
-  
+
   Quaternion<S> absoluteRotation(S dt) const;
-  
+
   /// @brief The transformation at time 0
   Transform3<S> tf1;
 
diff --git a/include/fcl/math/motion/screw_motion.h b/include/fcl/math/motion/screw_motion.h
index fce3387..0adb7fa 100644
--- a/include/fcl/math/motion/screw_motion.h
+++ b/include/fcl/math/motion/screw_motion.h
@@ -49,7 +49,7 @@ namespace fcl
 {
 
 template <typename S>
-class FCL_EXPORT ScrewMotion : public MotionBase<S>
+class ScrewMotion : public MotionBase<S>
 {
 public:
   /// @brief Default transformations are all identities
diff --git a/include/fcl/math/motion/spline_motion.h b/include/fcl/math/motion/spline_motion.h
index 96f2eba..7267f4d 100644
--- a/include/fcl/math/motion/spline_motion.h
+++ b/include/fcl/math/motion/spline_motion.h
@@ -50,7 +50,7 @@ namespace fcl
 {
 
 template <typename S>
-class FCL_EXPORT SplineMotion : public MotionBase<S>
+class SplineMotion : public MotionBase<S>
 {
 public:
   /// @brief Construct motion from 4 deBoor points
@@ -63,7 +63,7 @@ public:
 
   SplineMotion(const Transform3<S>& tf1,
                const Transform3<S>& tf2);
-  
+
   /// @brief Integrate the motion from 0 to dt
   /// We compute the current transformation from zero point instead of from last integrate time, for precision.
   bool integrate(S dt) const override;
@@ -86,7 +86,7 @@ protected:
   S getWeight1(S t) const;
   S getWeight2(S t) const;
   S getWeight3(S t) const;
-  
+
   Vector3<S> Td[4];
   Vector3<S> Rd[4];
 
@@ -102,7 +102,7 @@ protected:
 
 public:
   S computeTBound(const Vector3<S>& n) const;
-  
+
   S computeDWMax() const;
 
   S getCurrentTime() const;
diff --git a/include/fcl/math/motion/taylor_model/interval-inl.h b/include/fcl/math/motion/taylor_model/interval-inl.h
index 2e2dbb1..5170645 100644
--- a/include/fcl/math/motion/taylor_model/interval-inl.h
+++ b/include/fcl/math/motion/taylor_model/interval-inl.h
@@ -46,14 +46,16 @@ namespace fcl
 
 //==============================================================================
 extern template
-struct Interval<double>;
+struct FCL_EXPORT Interval<double>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 Interval<double> bound(const Interval<double>& i, double v);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 Interval<double> bound(const Interval<double>& i, const Interval<double>& other);
 
 //==============================================================================
diff --git a/include/fcl/math/motion/taylor_model/interval.h b/include/fcl/math/motion/taylor_model/interval.h
index cda1aa7..5aa2dc5 100644
--- a/include/fcl/math/motion/taylor_model/interval.h
+++ b/include/fcl/math/motion/taylor_model/interval.h
@@ -47,7 +47,7 @@ namespace fcl
 
 /// @brief Interval class for [a, b]
 template <typename S>
-struct FCL_EXPORT Interval
+struct Interval
 {
   S i_[2];
 
@@ -125,11 +125,9 @@ struct FCL_EXPORT Interval
 };
 
 template <typename S>
-FCL_EXPORT
 Interval<S> bound(const Interval<S>& i, S v);
 
 template <typename S>
-FCL_EXPORT
 Interval<S> bound(const Interval<S>& i, const Interval<S>& other);
 
 } // namespace fcl
diff --git a/include/fcl/math/motion/taylor_model/interval_matrix-inl.h b/include/fcl/math/motion/taylor_model/interval_matrix-inl.h
index bda8fc0..27c2d17 100644
--- a/include/fcl/math/motion/taylor_model/interval_matrix-inl.h
+++ b/include/fcl/math/motion/taylor_model/interval_matrix-inl.h
@@ -45,10 +45,11 @@ namespace fcl
 
 //==============================================================================
 extern template
-struct IMatrix3<double>;
+struct FCL_EXPORT IMatrix3<double>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 IMatrix3<double> rotationConstrain(const IMatrix3<double>& m);
 
 //==============================================================================
diff --git a/include/fcl/math/motion/taylor_model/interval_matrix.h b/include/fcl/math/motion/taylor_model/interval_matrix.h
index eab03c2..3f16c3e 100644
--- a/include/fcl/math/motion/taylor_model/interval_matrix.h
+++ b/include/fcl/math/motion/taylor_model/interval_matrix.h
@@ -45,7 +45,7 @@ namespace fcl
 {
 
 template <typename S>
-struct FCL_EXPORT IMatrix3
+struct IMatrix3
 {
   IVector3<S> v_[3];
 
@@ -95,7 +95,6 @@ struct FCL_EXPORT IMatrix3
 };
 
 template <typename S>
-FCL_EXPORT
 IMatrix3<S> rotationConstrain(const IMatrix3<S>& m);
 
 } // namespace fcl
diff --git a/include/fcl/math/motion/taylor_model/interval_vector-inl.h b/include/fcl/math/motion/taylor_model/interval_vector-inl.h
index 5755f76..f50266b 100644
--- a/include/fcl/math/motion/taylor_model/interval_vector-inl.h
+++ b/include/fcl/math/motion/taylor_model/interval_vector-inl.h
@@ -45,14 +45,16 @@ namespace fcl
 
 //==============================================================================
 extern template
-struct IVector3<double>;
+struct FCL_EXPORT IVector3<double>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 IVector3<double> bound(const IVector3<double>& i, const Vector3<double>& v);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 IVector3<double> bound(const IVector3<double>& i, const IVector3<double>& v);
 
 //==============================================================================
diff --git a/include/fcl/math/motion/taylor_model/interval_vector.h b/include/fcl/math/motion/taylor_model/interval_vector.h
index d5e5a94..d4d3473 100644
--- a/include/fcl/math/motion/taylor_model/interval_vector.h
+++ b/include/fcl/math/motion/taylor_model/interval_vector.h
@@ -44,7 +44,7 @@ namespace fcl
 {
 
 template <typename S>
-struct FCL_EXPORT IVector3
+struct IVector3
 {
   Interval<S> i_[3];
 
@@ -72,7 +72,7 @@ struct FCL_EXPORT IVector3
   void setValue(const Vector3<S>& v);
 
   void setValue(S v[3]);
-  
+
   IVector3 operator + (const IVector3& other) const;
   IVector3& operator += (const IVector3& other);
 
@@ -90,7 +90,7 @@ struct FCL_EXPORT IVector3
   Interval<S>& operator [] (size_t i);
 
   Vector3<S> getLow() const;
-  
+
   Vector3<S> getHigh() const;
 
   void print() const;
@@ -106,11 +106,9 @@ struct FCL_EXPORT IVector3
 };
 
 template <typename S>
-FCL_EXPORT
 IVector3<S> bound(const IVector3<S>& i, const Vector3<S>& v);
 
 template <typename S>
-FCL_EXPORT
 IVector3<S> bound(const IVector3<S>& i, const IVector3<S>& v);
 
 } // namespace fcl
diff --git a/include/fcl/math/motion/taylor_model/taylor_matrix-inl.h b/include/fcl/math/motion/taylor_model/taylor_matrix-inl.h
index f5b1843..2f5fc63 100644
--- a/include/fcl/math/motion/taylor_model/taylor_matrix-inl.h
+++ b/include/fcl/math/motion/taylor_model/taylor_matrix-inl.h
@@ -49,30 +49,37 @@ class FCL_EXPORT TMatrix3<double>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 TMatrix3<double> rotationConstrain(const TMatrix3<double>& m);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 TMatrix3<double> operator * (const Matrix3<double>& m, const TaylorModel<double>& a);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 TMatrix3<double> operator * (const TaylorModel<double>& a, const Matrix3<double>& m);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 TMatrix3<double> operator * (const TaylorModel<double>& a, const TMatrix3<double>& m);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 TMatrix3<double> operator * (double d, const TMatrix3<double>& m);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 TMatrix3<double> operator + (const Matrix3<double>& m1, const TMatrix3<double>& m2);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 TMatrix3<double> operator - (const Matrix3<double>& m1, const TMatrix3<double>& m2);
 
 //==============================================================================
diff --git a/include/fcl/math/motion/taylor_model/taylor_matrix.h b/include/fcl/math/motion/taylor_model/taylor_matrix.h
index c26f533..eb11805 100644
--- a/include/fcl/math/motion/taylor_model/taylor_matrix.h
+++ b/include/fcl/math/motion/taylor_model/taylor_matrix.h
@@ -45,10 +45,10 @@ namespace fcl
 {
 
 template <typename S>
-class FCL_EXPORT TMatrix3
+class TMatrix3
 {
   TVector3<S> v_[3];
-  
+
 public:
   TMatrix3();
   TMatrix3(const std::shared_ptr<TimeInterval<S>>& time_interval);
@@ -106,31 +106,24 @@ public:
 };
 
 template <typename S>
-FCL_EXPORT
 TMatrix3<S> rotationConstrain(const TMatrix3<S>& m);
 
 template <typename S>
-FCL_EXPORT
 TMatrix3<S> operator * (const Matrix3<S>& m, const TaylorModel<S>& a);
 
 template <typename S>
-FCL_EXPORT
 TMatrix3<S> operator * (const TaylorModel<S>& a, const Matrix3<S>& m);
 
 template <typename S>
-FCL_EXPORT
 TMatrix3<S> operator * (const TaylorModel<S>& a, const TMatrix3<S>& m);
 
 template <typename S>
-FCL_EXPORT
 TMatrix3<S> operator * (S d, const TMatrix3<S>& m);
 
 template <typename S>
-FCL_EXPORT
 TMatrix3<S> operator + (const Matrix3<S>& m1, const TMatrix3<S>& m2);
 
 template <typename S>
-FCL_EXPORT
 TMatrix3<S> operator - (const Matrix3<S>& m1, const TMatrix3<S>& m2);
 
 } // namespace fcl
diff --git a/include/fcl/math/motion/taylor_model/taylor_model-inl.h b/include/fcl/math/motion/taylor_model/taylor_model-inl.h
index 861f72d..f6cd367 100644
--- a/include/fcl/math/motion/taylor_model/taylor_model-inl.h
+++ b/include/fcl/math/motion/taylor_model/taylor_model-inl.h
@@ -52,26 +52,32 @@ class FCL_EXPORT TaylorModel<double>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 TaylorModel<double> operator * (double d, const TaylorModel<double>& a);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 TaylorModel<double> operator + (double d, const TaylorModel<double>& a);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 TaylorModel<double> operator - (double d, const TaylorModel<double>& a);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void generateTaylorModelForCosFunc(TaylorModel<double>& tm, double w, double q0);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void generateTaylorModelForSinFunc(TaylorModel<double>& tm, double w, double q0);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void generateTaylorModelForLinearFunc(TaylorModel<double>& tm, double p, double v);
 
 //==============================================================================
diff --git a/include/fcl/math/motion/taylor_model/taylor_model.h b/include/fcl/math/motion/taylor_model/taylor_model.h
index b8c1999..8b51203 100644
--- a/include/fcl/math/motion/taylor_model/taylor_model.h
+++ b/include/fcl/math/motion/taylor_model/taylor_model.h
@@ -55,7 +55,7 @@ namespace fcl
 /// remainder. All the operations on two Taylor models assume their time
 /// intervals are the same.
 template <typename S>
-class FCL_EXPORT TaylorModel
+class TaylorModel
 {
   /// @brief time interval
   std::shared_ptr<TimeInterval<S>> time_interval_;
@@ -69,7 +69,7 @@ class FCL_EXPORT TaylorModel
 public:
 
   void setTimeInterval(S l, S r);
-  
+
   void setTimeInterval(const std::shared_ptr<TimeInterval<S>>& time_interval);
 
   const std::shared_ptr<TimeInterval<S>>& getTimeInterval() const;
@@ -78,7 +78,7 @@ public:
   S& coeff(std::size_t i);
   const Interval<S>& remainder() const;
   Interval<S>& remainder();
-  
+
   TaylorModel();
   TaylorModel(const std::shared_ptr<TimeInterval<S>>& time_interval);
   TaylorModel(S coeff, const std::shared_ptr<TimeInterval<S>>& time_interval);
@@ -118,30 +118,24 @@ public:
 };
 
 template <typename S>
-FCL_EXPORT
 TaylorModel<S> operator * (S d, const TaylorModel<S>& a);
 
 template <typename S>
-FCL_EXPORT
 TaylorModel<S> operator + (S d, const TaylorModel<S>& a);
 
 template <typename S>
-FCL_EXPORT
 TaylorModel<S> operator - (S d, const TaylorModel<S>& a);
 
 /// @brief Generate Taylor model for cos(w t + q0)
 template <typename S>
-FCL_EXPORT
 void generateTaylorModelForCosFunc(TaylorModel<S>& tm, S w, S q0);
 
 /// @brief Generate Taylor model for sin(w t + q0)
 template <typename S>
-FCL_EXPORT
 void generateTaylorModelForSinFunc(TaylorModel<S>& tm, S w, S q0);
 
 /// @brief Generate Taylor model for p + v t
 template <typename S>
-FCL_EXPORT
 void generateTaylorModelForLinearFunc(TaylorModel<S>& tm, S p, S v);
 
 } // namespace fcl
diff --git a/include/fcl/math/motion/taylor_model/taylor_vector-inl.h b/include/fcl/math/motion/taylor_model/taylor_vector-inl.h
index 1ce2b36..a6e1d3c 100644
--- a/include/fcl/math/motion/taylor_model/taylor_vector-inl.h
+++ b/include/fcl/math/motion/taylor_model/taylor_vector-inl.h
@@ -49,18 +49,22 @@ class FCL_EXPORT TVector3<double>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void generateTVector3ForLinearFunc(TVector3<double>& v, const Vector3<double>& position, const Vector3<double>& velocity);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 TVector3<double> operator * (const Vector3<double>& v, const TaylorModel<double>& a);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 TVector3<double> operator + (const Vector3<double>& v1, const TVector3<double>& v2);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 TVector3<double> operator - (const Vector3<double>& v1, const TVector3<double>& v2);
 
 //==============================================================================
diff --git a/include/fcl/math/motion/taylor_model/taylor_vector.h b/include/fcl/math/motion/taylor_model/taylor_vector.h
index 7df662f..72a1817 100644
--- a/include/fcl/math/motion/taylor_model/taylor_vector.h
+++ b/include/fcl/math/motion/taylor_model/taylor_vector.h
@@ -45,18 +45,18 @@ namespace fcl
 {
 
 template <typename S>
-class FCL_EXPORT TVector3
+class TVector3
 {
   TaylorModel<S> i_[3];
 
 public:
-  
+
   TVector3();
   TVector3(const std::shared_ptr<TimeInterval<S>>& time_interval);
   TVector3(TaylorModel<S> v[3]);
   TVector3(const TaylorModel<S>& v0, const TaylorModel<S>& v1, const TaylorModel<S>& v2);
   TVector3(const Vector3<S>& v, const std::shared_ptr<TimeInterval<S>>& time_interval);
-  
+
   TVector3 operator + (const TVector3& other) const;
   TVector3& operator += (const TVector3& other);
 
@@ -104,19 +104,15 @@ public:
 };
 
 template <typename S>
-FCL_EXPORT
 void generateTVector3ForLinearFunc(TVector3<S>& v, const Vector3<S>& position, const Vector3<S>& velocity);
 
 template <typename S>
-FCL_EXPORT
 TVector3<S> operator * (const Vector3<S>& v, const TaylorModel<S>& a);
 
 template <typename S>
-FCL_EXPORT
 TVector3<S> operator + (const Vector3<S>& v1, const TVector3<S>& v2);
 
 template <typename S>
-FCL_EXPORT
 TVector3<S> operator - (const Vector3<S>& v1, const TVector3<S>& v2);
 
 } // namespace fcl
diff --git a/include/fcl/math/motion/taylor_model/time_interval-inl.h b/include/fcl/math/motion/taylor_model/time_interval-inl.h
index 62d83d0..236e9ca 100644
--- a/include/fcl/math/motion/taylor_model/time_interval-inl.h
+++ b/include/fcl/math/motion/taylor_model/time_interval-inl.h
@@ -45,7 +45,7 @@ namespace fcl
 
 //==============================================================================
 extern template
-struct TimeInterval<double>;
+struct FCL_EXPORT TimeInterval<double>;
 
 //==============================================================================
 template <typename S>
diff --git a/include/fcl/math/motion/taylor_model/time_interval.h b/include/fcl/math/motion/taylor_model/time_interval.h
index 1320d9c..49c686a 100644
--- a/include/fcl/math/motion/taylor_model/time_interval.h
+++ b/include/fcl/math/motion/taylor_model/time_interval.h
@@ -47,7 +47,7 @@ namespace fcl
 {
 
 template <typename S>
-struct FCL_EXPORT TimeInterval
+struct TimeInterval
 {
   /// @brief time Interval<S> and different powers
   Interval<S> t_; // [t1, t2]
diff --git a/include/fcl/math/motion/tbv_motion_bound_visitor.h b/include/fcl/math/motion/tbv_motion_bound_visitor.h
index 515fef8..05c947c 100644
--- a/include/fcl/math/motion/tbv_motion_bound_visitor.h
+++ b/include/fcl/math/motion/tbv_motion_bound_visitor.h
@@ -62,7 +62,7 @@ template <typename S>
 class TranslationMotion;
 
 template<typename BV>
-class FCL_EXPORT TBVMotionBoundVisitor : public BVMotionBoundVisitor<typename BV::S>
+class TBVMotionBoundVisitor : public BVMotionBoundVisitor<typename BV::S>
 {
 public:
   using S = typename BV::S;
diff --git a/include/fcl/math/motion/translation_motion.h b/include/fcl/math/motion/translation_motion.h
index 37b77b4..ff2a1ff 100644
--- a/include/fcl/math/motion/translation_motion.h
+++ b/include/fcl/math/motion/translation_motion.h
@@ -46,7 +46,7 @@ namespace fcl
 {
 
 template <typename S>
-class FCL_EXPORT TranslationMotion : public MotionBase<S>
+class TranslationMotion : public MotionBase<S>
 {
 public:
   /// @brief Construct motion from intial and goal transform
diff --git a/include/fcl/math/motion/triangle_motion_bound_visitor.h b/include/fcl/math/motion/triangle_motion_bound_visitor.h
index e6a3b7d..c37a206 100644
--- a/include/fcl/math/motion/triangle_motion_bound_visitor.h
+++ b/include/fcl/math/motion/triangle_motion_bound_visitor.h
@@ -71,7 +71,7 @@ template <typename, typename>
 struct TriangleMotionBoundVisitorVisitImpl;
 
 template <typename S>
-class FCL_EXPORT TriangleMotionBoundVisitor
+class TriangleMotionBoundVisitor
 {
 public:
   TriangleMotionBoundVisitor(
diff --git a/include/fcl/math/rng.h b/include/fcl/math/rng.h
index 782cf48..827c0ea 100644
--- a/include/fcl/math/rng.h
+++ b/include/fcl/math/rng.h
@@ -55,7 +55,7 @@ namespace fcl
 /// threads. It is also guaranteed that all created instances will
 /// have a different random seed.
 template <typename S>
-class FCL_EXPORT RNG
+class RNG
 {
 public:
   /// @brief Constructor. Always sets a different random seed
diff --git a/include/fcl/math/sampler/sampler_base.h b/include/fcl/math/sampler/sampler_base.h
index d49d8c9..30bd153 100644
--- a/include/fcl/math/sampler/sampler_base.h
+++ b/include/fcl/math/sampler/sampler_base.h
@@ -44,7 +44,7 @@ namespace fcl
 {
 
 template <typename S>
-class FCL_EXPORT SamplerBase
+class SamplerBase
 {
 public:
   mutable RNG<S> rng;
diff --git a/include/fcl/math/sampler/sampler_r.h b/include/fcl/math/sampler/sampler_r.h
index 9b19776..44eed46 100644
--- a/include/fcl/math/sampler/sampler_r.h
+++ b/include/fcl/math/sampler/sampler_r.h
@@ -46,7 +46,7 @@ namespace fcl
 {
 
 template <typename S, std::size_t N>
-class FCL_EXPORT SamplerR : public SamplerBase<S>
+class SamplerR : public SamplerBase<S>
 {
 public:
   SamplerR();
diff --git a/include/fcl/math/sampler/sampler_se2.h b/include/fcl/math/sampler/sampler_se2.h
index ff321e7..be626a5 100644
--- a/include/fcl/math/sampler/sampler_se2.h
+++ b/include/fcl/math/sampler/sampler_se2.h
@@ -45,7 +45,7 @@ namespace fcl
 {
 
 template <typename S>
-class FCL_EXPORT SamplerSE2 : public SamplerBase<S>
+class SamplerSE2 : public SamplerBase<S>
 {
 public:
   SamplerSE2();
diff --git a/include/fcl/math/sampler/sampler_se2_disk.h b/include/fcl/math/sampler/sampler_se2_disk.h
index 154110b..eed432d 100644
--- a/include/fcl/math/sampler/sampler_se2_disk.h
+++ b/include/fcl/math/sampler/sampler_se2_disk.h
@@ -45,7 +45,7 @@ namespace fcl
 {
 
 template <typename S>
-class FCL_EXPORT SamplerSE2_disk : public SamplerBase<S>
+class SamplerSE2_disk : public SamplerBase<S>
 {
 public:
   SamplerSE2_disk();
diff --git a/include/fcl/math/sampler/sampler_se3_euler.h b/include/fcl/math/sampler/sampler_se3_euler.h
index 487e22a..5ec8d92 100644
--- a/include/fcl/math/sampler/sampler_se3_euler.h
+++ b/include/fcl/math/sampler/sampler_se3_euler.h
@@ -45,7 +45,7 @@ namespace fcl
 {
 
 template <typename S>
-class FCL_EXPORT SamplerSE3Euler : public SamplerBase<S>
+class SamplerSE3Euler : public SamplerBase<S>
 {
 public:
   SamplerSE3Euler();
diff --git a/include/fcl/math/sampler/sampler_se3_euler_ball.h b/include/fcl/math/sampler/sampler_se3_euler_ball.h
index 616e0b7..610908a 100644
--- a/include/fcl/math/sampler/sampler_se3_euler_ball.h
+++ b/include/fcl/math/sampler/sampler_se3_euler_ball.h
@@ -45,7 +45,7 @@ namespace fcl
 {
 
 template <typename S>
-class FCL_EXPORT SamplerSE3Euler_ball : public SamplerBase<S>
+class SamplerSE3Euler_ball : public SamplerBase<S>
 {
 public:
   SamplerSE3Euler_ball();
@@ -53,7 +53,7 @@ public:
   SamplerSE3Euler_ball(S r_);
 
   void setBound(const S& r_);
-  
+
   void getBound(S& r_) const;
 
   Vector6<S> sample() const;
diff --git a/include/fcl/math/sampler/sampler_se3_quat.h b/include/fcl/math/sampler/sampler_se3_quat.h
index 3c2ae98..0f0a9b4 100644
--- a/include/fcl/math/sampler/sampler_se3_quat.h
+++ b/include/fcl/math/sampler/sampler_se3_quat.h
@@ -45,7 +45,7 @@ namespace fcl
 {
 
 template <typename S>
-class FCL_EXPORT SamplerSE3Quat : public SamplerBase<S>
+class SamplerSE3Quat : public SamplerBase<S>
 {
 public:
   SamplerSE3Quat();
diff --git a/include/fcl/math/sampler/sampler_se3_quat_ball.h b/include/fcl/math/sampler/sampler_se3_quat_ball.h
index 9fef44c..42a527d 100644
--- a/include/fcl/math/sampler/sampler_se3_quat_ball.h
+++ b/include/fcl/math/sampler/sampler_se3_quat_ball.h
@@ -45,7 +45,7 @@ namespace fcl
 {
 
 template <typename S>
-class FCL_EXPORT SamplerSE3Quat_ball : public SamplerBase<S>
+class SamplerSE3Quat_ball : public SamplerBase<S>
 {
 public:
   SamplerSE3Quat_ball();
diff --git a/include/fcl/math/variance3.h b/include/fcl/math/variance3.h
index b593820..0bdb905 100644
--- a/include/fcl/math/variance3.h
+++ b/include/fcl/math/variance3.h
@@ -48,7 +48,7 @@ namespace fcl
 
 /// @brief Class for variance matrix in 3d
 template <typename S>
-class FCL_EXPORT Variance3
+class Variance3
 {
 public:
   /// @brief Variation matrix
diff --git a/include/fcl/narrowphase/collision-inl.h b/include/fcl/narrowphase/collision-inl.h
index 81dc22d..9d5095c 100644
--- a/include/fcl/narrowphase/collision-inl.h
+++ b/include/fcl/narrowphase/collision-inl.h
@@ -77,7 +77,6 @@ detail::CollisionFunctionMatrix<GJKSolver>& getCollisionFunctionLookTable()
 
 //==============================================================================
 template <typename S, typename NarrowPhaseSolver>
-FCL_EXPORT
 std::size_t collide(
     const CollisionObject<S>* o1,
     const CollisionObject<S>* o2,
@@ -91,7 +90,6 @@ std::size_t collide(
 
 //==============================================================================
 template <typename S, typename NarrowPhaseSolver>
-FCL_EXPORT
 std::size_t collide(
     const CollisionGeometry<S>* o1,
     const Transform3<S>& tf1,
@@ -150,7 +148,6 @@ std::size_t collide(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 std::size_t collide(const CollisionObject<S>* o1, const CollisionObject<S>* o2,
                     const CollisionRequest<S>& request, CollisionResult<S>& result)
 {
@@ -176,7 +173,6 @@ std::size_t collide(const CollisionObject<S>* o1, const CollisionObject<S>* o2,
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 std::size_t collide(
     const CollisionGeometry<S>* o1,
     const Transform3<S>& tf1,
diff --git a/include/fcl/narrowphase/collision.h b/include/fcl/narrowphase/collision.h
index f6e361e..960e624 100644
--- a/include/fcl/narrowphase/collision.h
+++ b/include/fcl/narrowphase/collision.h
@@ -53,13 +53,11 @@ namespace fcl
 /// performs the collision between them. Return value is the number of contacts
 /// generated between the two objects.
 template <typename S>
-FCL_EXPORT
 std::size_t collide(const CollisionObject<S>* o1, const CollisionObject<S>* o2,
                     const CollisionRequest<S>& request,
                     CollisionResult<S>& result);
 
 template <typename S>
-FCL_EXPORT
 std::size_t collide(const CollisionGeometry<S>* o1, const Transform3<S>& tf1,
                     const CollisionGeometry<S>* o2, const Transform3<S>& tf2,
                     const CollisionRequest<S>& request,
diff --git a/include/fcl/narrowphase/collision_object.h b/include/fcl/narrowphase/collision_object.h
index bef211a..120bcbc 100644
--- a/include/fcl/narrowphase/collision_object.h
+++ b/include/fcl/narrowphase/collision_object.h
@@ -48,7 +48,7 @@ namespace fcl
 /// @brief the object for collision or distance computation, contains the
 /// geometry and the transform information
 template <typename S>
-class FCL_EXPORT CollisionObject
+class CollisionObject
 {
 public:
   CollisionObject(const std::shared_ptr<CollisionGeometry<S>>& cgeom);
diff --git a/include/fcl/narrowphase/collision_request-inl.h b/include/fcl/narrowphase/collision_request-inl.h
index eb77901..7894b91 100644
--- a/include/fcl/narrowphase/collision_request-inl.h
+++ b/include/fcl/narrowphase/collision_request-inl.h
@@ -47,7 +47,7 @@ namespace fcl
 
 //==============================================================================
 extern template
-struct CollisionRequest<double>;
+struct FCL_EXPORT CollisionRequest<double>;
 
 //==============================================================================
 template <typename S>
diff --git a/include/fcl/narrowphase/collision_request.h b/include/fcl/narrowphase/collision_request.h
index 3341714..fa85ac1 100644
--- a/include/fcl/narrowphase/collision_request.h
+++ b/include/fcl/narrowphase/collision_request.h
@@ -49,7 +49,7 @@ struct CollisionResult;
 
 /// @brief Parameters for performing collision request.
 template <typename S>
-struct FCL_EXPORT CollisionRequest
+struct CollisionRequest
 {
   /// The underlying numerical representation of the request's scalar (e.g.,
   /// float or double).
@@ -81,7 +81,7 @@ struct FCL_EXPORT CollisionRequest
   // single std::optional<Vector3<S>>.
   /// @brief If true, uses the provided initial guess for the GJK algorithm.
   bool enable_cached_gjk_guess;
-  
+
   /// @brief The initial guess to use in the GJK algorithm.
   Vector3<S> cached_gjk_guess;
 
diff --git a/include/fcl/narrowphase/collision_result-inl.h b/include/fcl/narrowphase/collision_result-inl.h
index e8829be..d47ed1f 100644
--- a/include/fcl/narrowphase/collision_result-inl.h
+++ b/include/fcl/narrowphase/collision_result-inl.h
@@ -45,7 +45,7 @@ namespace fcl
 
 //==============================================================================
 extern template
-struct CollisionResult<double>;
+struct FCL_EXPORT CollisionResult<double>;
 
 //==============================================================================
 template <typename S>
diff --git a/include/fcl/narrowphase/collision_result.h b/include/fcl/narrowphase/collision_result.h
index a0d3677..b7f3631 100644
--- a/include/fcl/narrowphase/collision_result.h
+++ b/include/fcl/narrowphase/collision_result.h
@@ -49,7 +49,7 @@ namespace fcl
 
 /// @brief collision result
 template <typename S>
-struct FCL_EXPORT CollisionResult
+struct CollisionResult
 {
 private:
   /// @brief contact information
@@ -85,7 +85,7 @@ public:
   /// @brief get all the contacts
   void getContacts(std::vector<Contact<S>>& contacts_);
 
-  /// @brief get all the cost sources 
+  /// @brief get all the cost sources
   void getCostSources(std::vector<CostSource<S>>& cost_sources_);
 
   /// @brief clear the results obtained
diff --git a/include/fcl/narrowphase/contact-inl.h b/include/fcl/narrowphase/contact-inl.h
index 88d26e5..fdd28e1 100644
--- a/include/fcl/narrowphase/contact-inl.h
+++ b/include/fcl/narrowphase/contact-inl.h
@@ -45,7 +45,7 @@ namespace fcl
 
 //==============================================================================
 extern template
-struct Contact<double>;
+struct FCL_EXPORT Contact<double>;
 
 //==============================================================================
 template <typename S>
diff --git a/include/fcl/narrowphase/contact.h b/include/fcl/narrowphase/contact.h
index 0994036..a726cb9 100644
--- a/include/fcl/narrowphase/contact.h
+++ b/include/fcl/narrowphase/contact.h
@@ -45,7 +45,7 @@ namespace fcl
 
 /// @brief Contact information returned by collision
 template <typename S>
-struct FCL_EXPORT Contact
+struct Contact
 {
   /// @brief collision object 1
   const CollisionGeometry<S>* o1;
@@ -64,7 +64,7 @@ struct FCL_EXPORT Contact
   /// if object 2 is geometry shape, it is NONE (-1),
   /// if object 2 is octree, it is the id of the cell
   int b2;
- 
+
   /// @brief contact normal, pointing from o1 to o2
   Vector3<S> normal;
 
@@ -74,7 +74,7 @@ struct FCL_EXPORT Contact
   /// @brief penetration depth
   S penetration_depth;
 
- 
+
   /// @brief invalid contact primitive information
   static const int NONE = -1;
 
diff --git a/include/fcl/narrowphase/contact_point-inl.h b/include/fcl/narrowphase/contact_point-inl.h
index 74ab8ca..c26ad7a 100644
--- a/include/fcl/narrowphase/contact_point-inl.h
+++ b/include/fcl/narrowphase/contact_point-inl.h
@@ -45,15 +45,17 @@ namespace fcl
 
 //==============================================================================
 extern template
-struct ContactPoint<double>;
+struct FCL_EXPORT ContactPoint<double>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool comparePenDepth(
     const ContactPoint<double>& _cp1, const ContactPoint<double>& _cp2);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void flipNormal(std::vector<ContactPoint<double>>& contacts);
 
 //==============================================================================
diff --git a/include/fcl/narrowphase/contact_point.h b/include/fcl/narrowphase/contact_point.h
index bca98e6..c917d69 100644
--- a/include/fcl/narrowphase/contact_point.h
+++ b/include/fcl/narrowphase/contact_point.h
@@ -45,7 +45,7 @@ namespace fcl
 
 /// @brief Minimal contact information returned by collision
 template <typename S>
-struct FCL_EXPORT ContactPoint
+struct ContactPoint
 {
   /// @brief Contact normal, pointing from o1 to o2
   Vector3<S> normal;
@@ -68,12 +68,10 @@ using ContactPointd = ContactPoint<double>;
 
 /// @brief Return true if _cp1's penentration depth is less than _cp2's.
 template <typename S>
-FCL_EXPORT
 bool comparePenDepth(
     const ContactPoint<S>& _cp1, const ContactPoint<S>& _cp2);
 
 template <typename S>
-FCL_EXPORT
 void flipNormal(std::vector<ContactPoint<S>>& contacts);
 
 } // namespace fcl
diff --git a/include/fcl/narrowphase/continuous_collision-inl.h b/include/fcl/narrowphase/continuous_collision-inl.h
index 1adfb6e..a444bdc 100644
--- a/include/fcl/narrowphase/continuous_collision-inl.h
+++ b/include/fcl/narrowphase/continuous_collision-inl.h
@@ -56,6 +56,7 @@ namespace fcl
 
 //==============================================================================
 extern template
+FCL_EXPORT
 double continuousCollide(
     const CollisionGeometry<double>* o1,
     const MotionBase<double>* motion1,
@@ -66,6 +67,7 @@ double continuousCollide(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 double continuousCollide(
     const CollisionGeometry<double>* o1,
     const Transform3<double>& tf1_beg,
@@ -78,6 +80,7 @@ double continuousCollide(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 double continuousCollide(
     const CollisionObject<double>* o1,
     const Transform3<double>& tf1_end,
@@ -88,6 +91,7 @@ double continuousCollide(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 double collide(
     const ContinuousCollisionObject<double>* o1,
     const ContinuousCollisionObject<double>* o2,
@@ -105,7 +109,6 @@ getConservativeAdvancementFunctionLookTable()
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 MotionBasePtr<S> getMotionBase(
     const Transform3<S>& tf_beg,
     const Transform3<S>& tf_end,
@@ -132,7 +135,6 @@ MotionBasePtr<S> getMotionBase(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 S continuousCollideNaive(
     const CollisionGeometry<S>* o1,
     const MotionBase<S>* motion1,
@@ -175,7 +177,6 @@ namespace detail
 
 //==============================================================================
 template<typename BV>
-FCL_EXPORT
 typename BV::S continuousCollideBVHPolynomial(
     const CollisionGeometry<typename BV::S>* o1_,
     const TranslationMotion<typename BV::S>* motion1,
@@ -244,7 +245,6 @@ typename BV::S continuousCollideBVHPolynomial(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 S continuousCollideBVHPolynomial(
     const CollisionGeometry<S>* o1,
     const TranslationMotion<S>* motion1,
@@ -301,7 +301,6 @@ namespace detail
 
 //==============================================================================
 template<typename NarrowPhaseSolver>
-FCL_EXPORT
 typename NarrowPhaseSolver::S continuousCollideConservativeAdvancement(
     const CollisionGeometry<typename NarrowPhaseSolver::S>* o1,
     const MotionBase<typename NarrowPhaseSolver::S>* motion1,
@@ -355,7 +354,6 @@ typename NarrowPhaseSolver::S continuousCollideConservativeAdvancement(
 } // namespace detail
 
 template <typename S>
-FCL_EXPORT
 S continuousCollideConservativeAdvancement(
     const CollisionGeometry<S>* o1,
     const MotionBase<S>* motion1,
@@ -383,7 +381,6 @@ S continuousCollideConservativeAdvancement(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 S continuousCollide(
     const CollisionGeometry<S>* o1,
     const MotionBase<S>* motion1,
@@ -433,7 +430,6 @@ S continuousCollide(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 S continuousCollide(
     const CollisionGeometry<S>* o1,
     const Transform3<S>& tf1_beg,
@@ -452,7 +448,6 @@ S continuousCollide(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 S continuousCollide(
     const CollisionObject<S>* o1,
     const Transform3<S>& tf1_end,
@@ -468,7 +463,6 @@ S continuousCollide(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 S collide(
     const ContinuousCollisionObject<S>* o1,
     const ContinuousCollisionObject<S>* o2,
diff --git a/include/fcl/narrowphase/continuous_collision.h b/include/fcl/narrowphase/continuous_collision.h
index fb1cab6..fe02b38 100644
--- a/include/fcl/narrowphase/continuous_collision.h
+++ b/include/fcl/narrowphase/continuous_collision.h
@@ -51,7 +51,6 @@ namespace fcl
 
 /// @brief continous collision checking between two objects
 template <typename S>
-FCL_EXPORT
 S continuousCollide(
     const CollisionGeometry<S>* o1,
     const MotionBase<S>* motion1,
@@ -61,7 +60,6 @@ S continuousCollide(
     ContinuousCollisionResult<S>& result);
 
 template <typename S>
-FCL_EXPORT
 S continuousCollide(
     const CollisionGeometry<S>* o1,
     const Transform3<S>& tf1_beg,
@@ -73,7 +71,6 @@ S continuousCollide(
     ContinuousCollisionResult<S>& result);
 
 template <typename S>
-FCL_EXPORT
 S continuousCollide(
     const CollisionObject<S>* o1,
     const Transform3<S>& tf1_end,
@@ -83,7 +80,6 @@ S continuousCollide(
     ContinuousCollisionResult<S>& result);
 
 template <typename S>
-FCL_EXPORT
 S collide(
     const ContinuousCollisionObject<S>* o1,
     const ContinuousCollisionObject<S>* o2,
diff --git a/include/fcl/narrowphase/continuous_collision_object.h b/include/fcl/narrowphase/continuous_collision_object.h
index ecb12c4..60b8741 100644
--- a/include/fcl/narrowphase/continuous_collision_object.h
+++ b/include/fcl/narrowphase/continuous_collision_object.h
@@ -48,7 +48,7 @@ namespace fcl
 /// @brief the object for continuous collision or distance computation, contains
 /// the geometry and the motion information
 template <typename S>
-class FCL_EXPORT ContinuousCollisionObject
+class ContinuousCollisionObject
 {
 public:
   ContinuousCollisionObject(
diff --git a/include/fcl/narrowphase/continuous_collision_request-inl.h b/include/fcl/narrowphase/continuous_collision_request-inl.h
index cd08e7f..46dd5a5 100644
--- a/include/fcl/narrowphase/continuous_collision_request-inl.h
+++ b/include/fcl/narrowphase/continuous_collision_request-inl.h
@@ -45,7 +45,7 @@ namespace fcl
 
 //==============================================================================
 extern template
-struct ContinuousCollisionRequest<double>;
+struct FCL_EXPORT ContinuousCollisionRequest<double>;
 
 //==============================================================================
 template <typename S>
diff --git a/include/fcl/narrowphase/continuous_collision_request.h b/include/fcl/narrowphase/continuous_collision_request.h
index 356be14..f1a0f67 100644
--- a/include/fcl/narrowphase/continuous_collision_request.h
+++ b/include/fcl/narrowphase/continuous_collision_request.h
@@ -49,7 +49,7 @@ enum CCDMotionType {CCDM_TRANS, CCDM_LINEAR, CCDM_SCREW, CCDM_SPLINE};
 enum CCDSolverType {CCDC_NAIVE, CCDC_CONSERVATIVE_ADVANCEMENT, CCDC_RAY_SHOOTING, CCDC_POLYNOMIAL_SOLVER};
 
 template <typename S>
-struct FCL_EXPORT ContinuousCollisionRequest
+struct ContinuousCollisionRequest
 {
   /// @brief maximum num of iterations
   std::size_t num_max_iterations;
@@ -65,13 +65,13 @@ struct FCL_EXPORT ContinuousCollisionRequest
 
   /// @brief ccd solver type
   CCDSolverType ccd_solver_type;
-  
+
   ContinuousCollisionRequest(std::size_t num_max_iterations_ = 10,
                              S toc_err_ = 0.0001,
                              CCDMotionType ccd_motion_type_ = CCDM_TRANS,
                              GJKSolverType gjk_solver_type_ = GST_LIBCCD,
                              CCDSolverType ccd_solver_type_ = CCDC_NAIVE);
-  
+
 };
 
 using ContinuousCollisionRequestf = ContinuousCollisionRequest<float>;
diff --git a/include/fcl/narrowphase/continuous_collision_result-inl.h b/include/fcl/narrowphase/continuous_collision_result-inl.h
index a34d168..6f1a44d 100644
--- a/include/fcl/narrowphase/continuous_collision_result-inl.h
+++ b/include/fcl/narrowphase/continuous_collision_result-inl.h
@@ -45,7 +45,7 @@ namespace fcl
 
 //==============================================================================
 extern template
-struct ContinuousCollisionResult<double>;
+struct FCL_EXPORT ContinuousCollisionResult<double>;
 
 //==============================================================================
 template <typename S>
diff --git a/include/fcl/narrowphase/continuous_collision_result.h b/include/fcl/narrowphase/continuous_collision_result.h
index e19bf69..473a856 100644
--- a/include/fcl/narrowphase/continuous_collision_result.h
+++ b/include/fcl/narrowphase/continuous_collision_result.h
@@ -45,18 +45,18 @@ namespace fcl
 
 /// @brief continuous collision result
 template <typename S>
-struct FCL_EXPORT ContinuousCollisionResult
+struct ContinuousCollisionResult
 {
   /// @brief collision or not
   bool is_collide;
-  
+
   /// @brief time of contact in [0, 1]
   S time_of_contact;
 
   Transform3<S> contact_tf1;
 
   Transform3<S> contact_tf2;
-  
+
   ContinuousCollisionResult();
 
   EIGEN_MAKE_ALIGNED_OPERATOR_NEW
diff --git a/include/fcl/narrowphase/cost_source-inl.h b/include/fcl/narrowphase/cost_source-inl.h
index abadfc9..725affd 100644
--- a/include/fcl/narrowphase/cost_source-inl.h
+++ b/include/fcl/narrowphase/cost_source-inl.h
@@ -45,7 +45,7 @@ namespace fcl
 
 //==============================================================================
 extern template
-struct CostSource<double>;
+struct FCL_EXPORT CostSource<double>;
 
 //==============================================================================
 template <typename S>
diff --git a/include/fcl/narrowphase/cost_source.h b/include/fcl/narrowphase/cost_source.h
index 15bc111..66f072a 100644
--- a/include/fcl/narrowphase/cost_source.h
+++ b/include/fcl/narrowphase/cost_source.h
@@ -46,7 +46,7 @@ namespace fcl
 
 /// @brief Cost source describes an area with a cost. The area is described by an AABB<S> region.
 template <typename S>
-struct FCL_EXPORT CostSource
+struct CostSource
 {
   /// @brief aabb lower bound
   Vector3<S> aabb_min;
diff --git a/include/fcl/narrowphase/detail/convexity_based_algorithm/epa-inl.h b/include/fcl/narrowphase/detail/convexity_based_algorithm/epa-inl.h
index e9c667d..0b2c01f 100644
--- a/include/fcl/narrowphase/detail/convexity_based_algorithm/epa-inl.h
+++ b/include/fcl/narrowphase/detail/convexity_based_algorithm/epa-inl.h
@@ -48,7 +48,7 @@ namespace detail
 
 //==============================================================================
 extern template
-struct EPA<double>;
+struct FCL_EXPORT EPA<double>;
 
 //==============================================================================
 template <typename S>
diff --git a/include/fcl/narrowphase/detail/convexity_based_algorithm/epa.h b/include/fcl/narrowphase/detail/convexity_based_algorithm/epa.h
index eb7efa4..8d81137 100644
--- a/include/fcl/narrowphase/detail/convexity_based_algorithm/epa.h
+++ b/include/fcl/narrowphase/detail/convexity_based_algorithm/epa.h
@@ -54,7 +54,7 @@ namespace detail
 
 /// @brief class for EPA algorithm
 template <typename S>
-struct FCL_EXPORT EPA
+struct EPA
 {
 private:
   using SimplexV = typename GJK<S>::SimplexV;
@@ -101,7 +101,7 @@ private:
 public:
 
   enum Status {Valid, Touching, Degenerated, NonConvex, InvalidHull, OutOfFaces, OutOfVertices, AccuracyReached, FallBack, Failed};
-  
+
   Status status;
   typename GJK<S>::Simplex result;
   Vector3<S> normal;
@@ -130,8 +130,8 @@ public:
 
   Status evaluate(GJK<S>& gjk, const Vector3<S>& guess);
 
-  /// @brief the goal is to add a face connecting vertex w and face edge f[e] 
-  bool expand(size_t pass, SimplexV* w, SimplexF* f, size_t e, SimplexHorizon& horizon);  
+  /// @brief the goal is to add a face connecting vertex w and face edge f[e]
+  bool expand(size_t pass, SimplexV* w, SimplexF* f, size_t e, SimplexHorizon& horizon);
 };
 
 using EPAf = EPA<float>;
diff --git a/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk-inl.h b/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk-inl.h
index fa01dc3..add09a1 100644
--- a/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk-inl.h
+++ b/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk-inl.h
@@ -48,7 +48,7 @@ namespace detail
 
 //==============================================================================
 extern template
-struct GJK<double>;
+struct FCL_EXPORT GJK<double>;
 
 //==============================================================================
 template <typename S>
diff --git a/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk.h b/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk.h
index f5bbc21..5fb481f 100644
--- a/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk.h
+++ b/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk.h
@@ -49,7 +49,7 @@ namespace detail
 
 /// @brief class for GJK algorithm
 template <typename S>
-struct FCL_EXPORT GJK
+struct GJK
 {
   struct SimplexV
   {
@@ -63,7 +63,7 @@ struct FCL_EXPORT GJK
   {
     /// @brief simplex vertex
     SimplexV* c[4];
-    /// @brief weight 
+    /// @brief weight
     S p[4];
     /// @brief size of simplex (number of vertices)
     size_t rank;
@@ -79,7 +79,7 @@ struct FCL_EXPORT GJK
   Simplex simplices[2];
 
   GJK(unsigned int max_iterations_, S tolerance_);
-  
+
   void initialize();
 
   /// @brief GJK algorithm, given the initial value guess
diff --git a/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk_libccd-inl.h b/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk_libccd-inl.h
index 98368bf..1f3bb5d 100644
--- a/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk_libccd-inl.h
+++ b/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk_libccd-inl.h
@@ -84,11 +84,13 @@ class FCL_EXPORT GJKInitializer<double, Convex<double>>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void* triCreateGJKObject(
     const Vector3d& P1, const Vector3d& P2, const Vector3d& P3);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void* triCreateGJKObject(
     const Vector3d& P1,
     const Vector3d& P2,
@@ -97,6 +99,7 @@ void* triCreateGJKObject(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool GJKCollide(
     void* obj1,
     ccd_support_fn supp1,
@@ -112,6 +115,7 @@ bool GJKCollide(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool GJKDistance(
     void* obj1,
     ccd_support_fn supp1,
@@ -124,6 +128,7 @@ bool GJKDistance(
     Vector3d* p2);
 
 extern template
+FCL_EXPORT
 bool GJKSignedDistance(
     void* obj1,
     ccd_support_fn supp1,
diff --git a/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk_libccd.h b/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk_libccd.h
index 2917729..ae38320 100644
--- a/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk_libccd.h
+++ b/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk_libccd.h
@@ -74,7 +74,7 @@ using GJKCenterFunction = void (*)(const void* obj, ccd_vec3_t* c);
 
 /// @brief initialize GJK stuffs
 template <typename S, typename T>
-class FCL_EXPORT GJKInitializer
+class GJKInitializer
 {
 public:
   /// @brief Get GJK support function
@@ -94,7 +94,7 @@ public:
 
 /// @brief initialize GJK Cylinder<S>
 template <typename S>
-class FCL_EXPORT GJKInitializer<S, Cylinder<S>>
+class GJKInitializer<S, Cylinder<S>>
 {
 public:
   static GJKSupportFunction getSupportFunction();
@@ -105,7 +105,7 @@ public:
 
 /// @brief initialize GJK Sphere<S>
 template <typename S>
-class FCL_EXPORT GJKInitializer<S, Sphere<S>>
+class GJKInitializer<S, Sphere<S>>
 {
 public:
   static GJKSupportFunction getSupportFunction();
@@ -116,7 +116,7 @@ public:
 
 /// @brief initialize GJK Ellipsoid<S>
 template <typename S>
-class FCL_EXPORT GJKInitializer<S, Ellipsoid<S>>
+class GJKInitializer<S, Ellipsoid<S>>
 {
 public:
   static GJKSupportFunction getSupportFunction();
@@ -127,7 +127,7 @@ public:
 
 /// @brief initialize GJK Box<S>
 template <typename S>
-class FCL_EXPORT GJKInitializer<S, Box<S>>
+class GJKInitializer<S, Box<S>>
 {
 public:
   static GJKSupportFunction getSupportFunction();
@@ -138,7 +138,7 @@ public:
 
 /// @brief initialize GJK Capsule<S>
 template <typename S>
-class FCL_EXPORT GJKInitializer<S, Capsule<S>>
+class GJKInitializer<S, Capsule<S>>
 {
 public:
   static GJKSupportFunction getSupportFunction();
@@ -149,7 +149,7 @@ public:
 
 /// @brief initialize GJK Cone<S>
 template <typename S>
-class FCL_EXPORT GJKInitializer<S, Cone<S>>
+class GJKInitializer<S, Cone<S>>
 {
 public:
   static GJKSupportFunction getSupportFunction();
@@ -160,7 +160,7 @@ public:
 
 /// @brief initialize GJK Convex<S>
 template <typename S>
-class FCL_EXPORT GJKInitializer<S, Convex<S>>
+class GJKInitializer<S, Convex<S>>
 {
 public:
   static GJKSupportFunction getSupportFunction();
@@ -177,11 +177,9 @@ FCL_EXPORT
 GJKCenterFunction triGetCenterFunction();
 
 template <typename S>
-FCL_EXPORT
 void* triCreateGJKObject(const Vector3<S>& P1, const Vector3<S>& P2, const Vector3<S>& P3);
 
 template <typename S>
-FCL_EXPORT
 void* triCreateGJKObject(const Vector3<S>& P1, const Vector3<S>& P2, const Vector3<S>& P3, const Transform3<S>& tf);
 
 FCL_EXPORT
@@ -189,7 +187,6 @@ void triDeleteGJKObject(void* o);
 
 /// @brief GJK collision algorithm
 template <typename S>
-FCL_EXPORT
 bool GJKCollide(
     void* obj1,
     ccd_support_fn supp1,
@@ -222,7 +219,6 @@ bool GJKCollide(
  * @retval is_separated True if the objects are separated, false otherwise.
  */
 template <typename S>
-FCL_EXPORT
 bool GJKDistance(void* obj1, ccd_support_fn supp1,
                  void* obj2, ccd_support_fn supp2,
                  unsigned int max_iterations, S tolerance,
@@ -248,7 +244,6 @@ bool GJKDistance(void* obj1, ccd_support_fn supp1,
  * @retval is_separated True if the objects are separated, false otherwise.
  */
 template <typename S>
-FCL_EXPORT
 bool GJKSignedDistance(void* obj1, ccd_support_fn supp1,
                        void* obj2, ccd_support_fn supp2,
                        unsigned int max_iterations, S tolerance,
diff --git a/include/fcl/narrowphase/detail/convexity_based_algorithm/minkowski_diff-inl.h b/include/fcl/narrowphase/detail/convexity_based_algorithm/minkowski_diff-inl.h
index 9f1309e..6355e80 100644
--- a/include/fcl/narrowphase/detail/convexity_based_algorithm/minkowski_diff-inl.h
+++ b/include/fcl/narrowphase/detail/convexity_based_algorithm/minkowski_diff-inl.h
@@ -59,11 +59,10 @@ namespace detail
 
 //==============================================================================
 extern template
-struct MinkowskiDiff<double>;
+struct FCL_EXPORT MinkowskiDiff<double>;
 
 //==============================================================================
 template <typename S, typename Derived>
-FCL_EXPORT
 Vector3<S> getSupport(
     const ShapeBase<S>* shape,
     const Eigen::MatrixBase<Derived>& dir)
diff --git a/include/fcl/narrowphase/detail/convexity_based_algorithm/minkowski_diff.h b/include/fcl/narrowphase/detail/convexity_based_algorithm/minkowski_diff.h
index a1ee9c7..d3f967d 100644
--- a/include/fcl/narrowphase/detail/convexity_based_algorithm/minkowski_diff.h
+++ b/include/fcl/narrowphase/detail/convexity_based_algorithm/minkowski_diff.h
@@ -55,7 +55,7 @@ Vector3<S> getSupport(
 
 /// @brief Minkowski difference class of two shapes
 template <typename S>
-struct FCL_EXPORT MinkowskiDiff
+struct MinkowskiDiff
 {
   /// @brief points to two shapes
   const ShapeBase<S>* shapes[2];
@@ -63,14 +63,14 @@ struct FCL_EXPORT MinkowskiDiff
   /// @brief rotation from shape0 to shape1
   Matrix3<S> toshape1;
 
-  /// @brief transform from shape1 to shape0 
+  /// @brief transform from shape1 to shape0
   Transform3<S> toshape0;
 
   MinkowskiDiff();
 
   /// @brief support function for shape0
   Vector3<S> support0(const Vector3<S>& d) const;
-  
+
   /// @brief support function for shape1
   Vector3<S> support1(const Vector3<S>& d) const;
 
diff --git a/include/fcl/narrowphase/detail/gjk_solver_indep-inl.h b/include/fcl/narrowphase/detail/gjk_solver_indep-inl.h
index ef9f8b1..9cc456a 100755
--- a/include/fcl/narrowphase/detail/gjk_solver_indep-inl.h
+++ b/include/fcl/narrowphase/detail/gjk_solver_indep-inl.h
@@ -67,7 +67,7 @@ namespace detail
 
 //==============================================================================
 extern template
-struct GJKSolver_indep<double>;
+struct FCL_EXPORT GJKSolver_indep<double>;
 
 //==============================================================================
 template <typename S>
diff --git a/include/fcl/narrowphase/detail/gjk_solver_indep.h b/include/fcl/narrowphase/detail/gjk_solver_indep.h
index 14eb10a..0f3fade 100755
--- a/include/fcl/narrowphase/detail/gjk_solver_indep.h
+++ b/include/fcl/narrowphase/detail/gjk_solver_indep.h
@@ -51,7 +51,7 @@ namespace detail
 
 /// @brief collision and distance solver based on GJK algorithm implemented in fcl (rewritten the code from the GJK in bullet)
 template <typename S_>
-struct FCL_EXPORT GJKSolver_indep
+struct GJKSolver_indep
 {
   using S = S_;
 
diff --git a/include/fcl/narrowphase/detail/gjk_solver_libccd-inl.h b/include/fcl/narrowphase/detail/gjk_solver_libccd-inl.h
index 3cef4d6..a22501e 100755
--- a/include/fcl/narrowphase/detail/gjk_solver_libccd-inl.h
+++ b/include/fcl/narrowphase/detail/gjk_solver_libccd-inl.h
@@ -64,7 +64,7 @@ namespace detail
 
 //==============================================================================
 extern template
-struct GJKSolver_libccd<double>;
+struct FCL_EXPORT GJKSolver_libccd<double>;
 
 //==============================================================================
 template<typename S>
diff --git a/include/fcl/narrowphase/detail/gjk_solver_libccd.h b/include/fcl/narrowphase/detail/gjk_solver_libccd.h
index 218a894..1b6b2c3 100755
--- a/include/fcl/narrowphase/detail/gjk_solver_libccd.h
+++ b/include/fcl/narrowphase/detail/gjk_solver_libccd.h
@@ -51,7 +51,7 @@ namespace detail
 
 /// @brief collision and distance solver based on libccd library.
 template <typename S_>
-struct FCL_EXPORT GJKSolver_libccd
+struct GJKSolver_libccd
 {
   using S = S_;
 
diff --git a/include/fcl/narrowphase/detail/primitive_shape_algorithm/box_box-inl.h b/include/fcl/narrowphase/detail/primitive_shape_algorithm/box_box-inl.h
index 91ffeca..a9fb0a3 100644
--- a/include/fcl/narrowphase/detail/primitive_shape_algorithm/box_box-inl.h
+++ b/include/fcl/narrowphase/detail/primitive_shape_algorithm/box_box-inl.h
@@ -50,20 +50,24 @@ namespace detail
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void lineClosestApproach(const Vector3<double>& pa, const Vector3<double>& ua,
                          const Vector3<double>& pb, const Vector3<double>& ub,
                          double* alpha, double* beta);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 int intersectRectQuad2(double h[2], double p[8], double ret[16]);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void cullPoints2(int n, double p[], int m, int i0, int iret[]);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 int boxBox2(
     const Vector3<double>& side1,
     const Transform3<double>& tf1,
@@ -77,6 +81,7 @@ int boxBox2(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool boxBoxIntersect(const Box<double>& s1, const Transform3<double>& tf1,
                      const Box<double>& s2, const Transform3<double>& tf2,
                      std::vector<ContactPoint<double>>* contacts_);
diff --git a/include/fcl/narrowphase/detail/primitive_shape_algorithm/box_box.h b/include/fcl/narrowphase/detail/primitive_shape_algorithm/box_box.h
index 87a6084..d7be734 100755
--- a/include/fcl/narrowphase/detail/primitive_shape_algorithm/box_box.h
+++ b/include/fcl/narrowphase/detail/primitive_shape_algorithm/box_box.h
@@ -49,7 +49,6 @@ namespace detail
 {
 
 template <typename S>
-FCL_EXPORT
 void lineClosestApproach(const Vector3<S>& pa, const Vector3<S>& ua,
                          const Vector3<S>& pb, const Vector3<S>& ub,
                          S* alpha, S* beta);
@@ -62,7 +61,6 @@ void lineClosestApproach(const Vector3<S>& pa, const Vector3<S>& ua,
 // the number of intersection points is returned by the function (this will
 // be in the range 0 to 8).
 template <typename S>
-FCL_EXPORT
 int intersectRectQuad2(S h[2], S p[8], S ret[16]);
 
 // given n points in the plane (array p, of size 2*n), generate m points that
@@ -73,11 +71,9 @@ int intersectRectQuad2(S h[2], S p[8], S ret[16]);
 // n must be in the range [1..8]. m must be in the range [1..n]. i0 must be
 // in the range [0..n-1].
 template <typename S>
-FCL_EXPORT
 void cullPoints2(int n, S p[], int m, int i0, int iret[]);
 
 template <typename S, typename DerivedA, typename DerivedB>
-FCL_EXPORT
 int boxBox2(
     const Vector3<S>& side1,
     const Eigen::MatrixBase<DerivedA>& R1,
@@ -92,7 +88,6 @@ int boxBox2(
     std::vector<ContactPoint<S>>& contacts);
 
 template <typename S>
-FCL_EXPORT
 int boxBox2(
     const Vector3<S>& side1,
     const Transform3<S>& tf1,
@@ -105,7 +100,6 @@ int boxBox2(
     std::vector<ContactPoint<S>>& contacts);
 
 template <typename S>
-FCL_EXPORT
 bool boxBoxIntersect(const Box<S>& s1, const Transform3<S>& tf1,
                      const Box<S>& s2, const Transform3<S>& tf2,
                      std::vector<ContactPoint<S>>* contacts_);
diff --git a/include/fcl/narrowphase/detail/primitive_shape_algorithm/capsule_capsule-inl.h b/include/fcl/narrowphase/detail/primitive_shape_algorithm/capsule_capsule-inl.h
index b316c95..03206ca 100644
--- a/include/fcl/narrowphase/detail/primitive_shape_algorithm/capsule_capsule-inl.h
+++ b/include/fcl/narrowphase/detail/primitive_shape_algorithm/capsule_capsule-inl.h
@@ -48,18 +48,22 @@ namespace detail
 
 //==============================================================================
 extern template
+FCL_EXPORT
 double clamp(double n, double min, double max);
 
 //==============================================================================
-extern template double closestPtSegmentSegment(const Vector3d& p_FP1,
-                                               const Vector3d& p_FQ1,
-                                               const Vector3d& p_FP2,
-                                               const Vector3d& p_FQ2, double* s,
-                                               double* t, Vector3d* p_FC1,
-                                               Vector3d* p_FC2);
+extern template
+FCL_EXPORT
+double closestPtSegmentSegment(const Vector3d& p_FP1,
+                               const Vector3d& p_FQ1,
+                               const Vector3d& p_FP2,
+                               const Vector3d& p_FQ2, double* s,
+                               double* t, Vector3d* p_FC1,
+                               Vector3d* p_FC2);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool capsuleCapsuleDistance(
     const Capsule<double>& s1, const Transform3<double>& tf1,
     const Capsule<double>& s2, const Transform3<double>& tf2,
diff --git a/include/fcl/narrowphase/detail/primitive_shape_algorithm/capsule_capsule.h b/include/fcl/narrowphase/detail/primitive_shape_algorithm/capsule_capsule.h
index c391736..a1303fc 100644
--- a/include/fcl/narrowphase/detail/primitive_shape_algorithm/capsule_capsule.h
+++ b/include/fcl/narrowphase/detail/primitive_shape_algorithm/capsule_capsule.h
@@ -49,7 +49,6 @@ namespace detail
 
 // Clamp n to lie within the range [min, max]
 template <typename S>
-FCL_EXPORT
 S clamp(S n, S min, S max);
 
 /** Computes the pair of closest points `(p_FC1, p_FC2)` between two line
@@ -73,11 +72,11 @@ S clamp(S n, S min, S max);
  @tparam S  The scalar type for computation.
  */
 template <typename S>
-FCL_EXPORT S closestPtSegmentSegment(const Vector3<S>& p_FP1,
-                                     const Vector3<S>& p_FQ1,
-                                     const Vector3<S>& p_FP2,
-                                     const Vector3<S>& p_FQ2, S* s, S* t,
-                                     Vector3<S>* p_FC1, Vector3<S>* p_FC2);
+S closestPtSegmentSegment(const Vector3<S>& p_FP1,
+                          const Vector3<S>& p_FQ1,
+                          const Vector3<S>& p_FP2,
+                          const Vector3<S>& p_FQ2, S* s, S* t,
+                          Vector3<S>* p_FC1, Vector3<S>* p_FC2);
 
 /** Computes the signed distance between two capsules `s1` and `s2` (with
  given poses `X_FC1` and `X_FC2` of the two capsules in a common frame `F`).
@@ -104,7 +103,6 @@ FCL_EXPORT S closestPtSegmentSegment(const Vector3<S>& p_FP1,
  @tparam S  The scalar type for computation.
  */
 template <typename S>
-FCL_EXPORT
 bool capsuleCapsuleDistance(const Capsule<S>& s1, const Transform3<S>& X_FC1,
           const Capsule<S>& s2, const Transform3<S>& X_FC2,
           S* dist, Vector3<S>* p_FW1, Vector3<S>* p_FW2);
diff --git a/include/fcl/narrowphase/detail/primitive_shape_algorithm/halfspace-inl.h b/include/fcl/narrowphase/detail/primitive_shape_algorithm/halfspace-inl.h
index 70a9a87..8f2b05a 100755
--- a/include/fcl/narrowphase/detail/primitive_shape_algorithm/halfspace-inl.h
+++ b/include/fcl/narrowphase/detail/primitive_shape_algorithm/halfspace-inl.h
@@ -48,6 +48,7 @@ namespace detail
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool sphereHalfspaceIntersect(
     const Sphere<double>& s1, const Transform3<double>& tf1,
     const Halfspace<double>& s2, const Transform3<double>& tf2,
@@ -55,6 +56,7 @@ bool sphereHalfspaceIntersect(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool ellipsoidHalfspaceIntersect(
     const Ellipsoid<double>& s1, const Transform3<double>& tf1,
     const Halfspace<double>& s2, const Transform3<double>& tf2,
@@ -62,12 +64,14 @@ bool ellipsoidHalfspaceIntersect(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool boxHalfspaceIntersect(
     const Box<double>& s1, const Transform3<double>& tf1,
     const Halfspace<double>& s2, const Transform3<double>& tf2);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool boxHalfspaceIntersect(
     const Box<double>& s1, const Transform3<double>& tf1,
     const Halfspace<double>& s2, const Transform3<double>& tf2,
@@ -75,6 +79,7 @@ bool boxHalfspaceIntersect(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool capsuleHalfspaceIntersect(
     const Capsule<double>& s1, const Transform3<double>& tf1,
     const Halfspace<double>& s2, const Transform3<double>& tf2,
@@ -82,6 +87,7 @@ bool capsuleHalfspaceIntersect(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool cylinderHalfspaceIntersect(
     const Cylinder<double>& s1, const Transform3<double>& tf1,
     const Halfspace<double>& s2, const Transform3<double>& tf2,
@@ -89,6 +95,7 @@ bool cylinderHalfspaceIntersect(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool coneHalfspaceIntersect(
     const Cone<double>& s1, const Transform3<double>& tf1,
     const Halfspace<double>& s2, const Transform3<double>& tf2,
@@ -96,6 +103,7 @@ bool coneHalfspaceIntersect(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool convexHalfspaceIntersect(
     const Convex<double>& s1, const Transform3<double>& tf1,
     const Halfspace<double>& s2, const Transform3<double>& tf2,
@@ -103,6 +111,7 @@ bool convexHalfspaceIntersect(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool halfspaceTriangleIntersect(
     const Halfspace<double>& s1, const Transform3<double>& tf1,
     const Vector3<double>& P1, const Vector3<double>& P2, const Vector3<double>& P3, const Transform3<double>& tf2,
@@ -110,6 +119,7 @@ bool halfspaceTriangleIntersect(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool planeHalfspaceIntersect(
     const Plane<double>& s1, const Transform3<double>& tf1,
     const Halfspace<double>& s2, const Transform3<double>& tf2,
@@ -120,6 +130,7 @@ bool planeHalfspaceIntersect(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool halfspacePlaneIntersect(
     const Halfspace<double>& s1, const Transform3<double>& tf1,
     const Plane<double>& s2, const Transform3<double>& tf2,
@@ -129,6 +140,7 @@ bool halfspacePlaneIntersect(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool halfspaceIntersect(
     const Halfspace<double>& s1, const Transform3<double>& tf1,
     const Halfspace<double>& s2, const Transform3<double>& tf2,
diff --git a/include/fcl/narrowphase/detail/primitive_shape_algorithm/halfspace.h b/include/fcl/narrowphase/detail/primitive_shape_algorithm/halfspace.h
index c8339f7..cc294c1 100755
--- a/include/fcl/narrowphase/detail/primitive_shape_algorithm/halfspace.h
+++ b/include/fcl/narrowphase/detail/primitive_shape_algorithm/halfspace.h
@@ -56,7 +56,6 @@ namespace detail
 {
 
 template <typename S>
-FCL_EXPORT
 S halfspaceIntersectTolerance();
 
 template <>
@@ -68,13 +67,11 @@ FCL_EXPORT
 double halfspaceIntersectTolerance();
 
 template <typename S>
-FCL_EXPORT
 bool sphereHalfspaceIntersect(const Sphere<S>& s1, const Transform3<S>& tf1,
                               const Halfspace<S>& s2, const Transform3<S>& tf2,
                               std::vector<ContactPoint<S>>* contacts);
 
 template <typename S>
-FCL_EXPORT
 bool ellipsoidHalfspaceIntersect(const Ellipsoid<S>& s1, const Transform3<S>& tf1,
                                  const Halfspace<S>& s2, const Transform3<S>& tf2,
                                  std::vector<ContactPoint<S>>* contacts);
@@ -85,42 +82,35 @@ bool ellipsoidHalfspaceIntersect(const Ellipsoid<S>& s1, const Transform3<S>& tf
 /// check whether d - n * T - (R^T n) (a v1 + b v2 + c v3) >= 0 for some a, b, c
 /// the max value of left side is d - n * T + |(R^T n) (a v1 + b v2 + c v3)|, check that is enough
 template <typename S>
-FCL_EXPORT
 bool boxHalfspaceIntersect(const Box<S>& s1, const Transform3<S>& tf1,
                            const Halfspace<S>& s2, const Transform3<S>& tf2);
 
 template <typename S>
-FCL_EXPORT
 bool boxHalfspaceIntersect(const Box<S>& s1, const Transform3<S>& tf1,
                            const Halfspace<S>& s2, const Transform3<S>& tf2,
                            std::vector<ContactPoint<S>>* contacts);
 
 template <typename S>
-FCL_EXPORT
 bool capsuleHalfspaceIntersect(const Capsule<S>& s1, const Transform3<S>& tf1,
                                const Halfspace<S>& s2, const Transform3<S>& tf2,
                                std::vector<ContactPoint<S>>* contacts);
 
 template <typename S>
-FCL_EXPORT
 bool cylinderHalfspaceIntersect(const Cylinder<S>& s1, const Transform3<S>& tf1,
                                 const Halfspace<S>& s2, const Transform3<S>& tf2,
                                 std::vector<ContactPoint<S>>* contacts);
 
 template <typename S>
-FCL_EXPORT
 bool coneHalfspaceIntersect(const Cone<S>& s1, const Transform3<S>& tf1,
                             const Halfspace<S>& s2, const Transform3<S>& tf2,
                             std::vector<ContactPoint<S>>* contacts);
 
 template <typename S>
-FCL_EXPORT
 bool convexHalfspaceIntersect(const Convex<S>& s1, const Transform3<S>& tf1,
                               const Halfspace<S>& s2, const Transform3<S>& tf2,
                               Vector3<S>* contact_points, S* penetration_depth, Vector3<S>* normal);
 
 template <typename S>
-FCL_EXPORT
 bool halfspaceTriangleIntersect(const Halfspace<S>& s1, const Transform3<S>& tf1,
                                 const Vector3<S>& P1, const Vector3<S>& P2, const Vector3<S>& P3, const Transform3<S>& tf2,
                                 Vector3<S>* contact_points, S* penetration_depth, Vector3<S>* normal);
@@ -133,7 +123,6 @@ bool halfspaceTriangleIntersect(const Halfspace<S>& s1, const Transform3<S>& tf1
 /// if not parallel
 ///     return the intersection ray, return code 3. ray origin is p and direction is d
 template <typename S>
-FCL_EXPORT
 bool planeHalfspaceIntersect(const Plane<S>& s1, const Transform3<S>& tf1,
                              const Halfspace<S>& s2, const Transform3<S>& tf2,
                              Plane<S>& pl,
@@ -142,7 +131,6 @@ bool planeHalfspaceIntersect(const Plane<S>& s1, const Transform3<S>& tf1,
                              int& ret);
 
 template <typename S>
-FCL_EXPORT
 bool halfspacePlaneIntersect(const Halfspace<S>& s1, const Transform3<S>& tf1,
                              const Plane<S>& s2, const Transform3<S>& tf2,
                              Plane<S>& pl, Vector3<S>& p, Vector3<S>& d,
@@ -158,7 +146,6 @@ bool halfspacePlaneIntersect(const Halfspace<S>& s1, const Transform3<S>& tf1,
 /// if the separation planes of the two halfspaces are not parallel, return intersection ray, return code 4. ray origin is p and direction is d
 /// collision free return code 0
 template <typename S>
-FCL_EXPORT
 bool halfspaceIntersect(const Halfspace<S>& s1, const Transform3<S>& tf1,
                         const Halfspace<S>& s2, const Transform3<S>& tf2,
                         Vector3<S>& p, Vector3<S>& d,
diff --git a/include/fcl/narrowphase/detail/primitive_shape_algorithm/plane-inl.h b/include/fcl/narrowphase/detail/primitive_shape_algorithm/plane-inl.h
index 1373dce..fcdd277 100755
--- a/include/fcl/narrowphase/detail/primitive_shape_algorithm/plane-inl.h
+++ b/include/fcl/narrowphase/detail/primitive_shape_algorithm/plane-inl.h
@@ -48,64 +48,75 @@ namespace detail
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool spherePlaneIntersect(const Sphere<double>& s1, const Transform3<double>& tf1,
                           const Plane<double>& s2, const Transform3<double>& tf2,
                           std::vector<ContactPoint<double>>* contacts);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool ellipsoidPlaneIntersect(const Ellipsoid<double>& s1, const Transform3<double>& tf1,
                              const Plane<double>& s2, const Transform3<double>& tf2,
                              std::vector<ContactPoint<double>>* contacts);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool boxPlaneIntersect(const Box<double>& s1, const Transform3<double>& tf1,
                        const Plane<double>& s2, const Transform3<double>& tf2,
                        std::vector<ContactPoint<double>>* contacts);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool capsulePlaneIntersect(const Capsule<double>& s1, const Transform3<double>& tf1,
                            const Plane<double>& s2, const Transform3<double>& tf2);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool capsulePlaneIntersect(const Capsule<double>& s1, const Transform3<double>& tf1,
                            const Plane<double>& s2, const Transform3<double>& tf2,
                            std::vector<ContactPoint<double>>* contacts);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool cylinderPlaneIntersect(const Cylinder<double>& s1, const Transform3<double>& tf1,
                             const Plane<double>& s2, const Transform3<double>& tf2);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool cylinderPlaneIntersect(const Cylinder<double>& s1, const Transform3<double>& tf1,
                             const Plane<double>& s2, const Transform3<double>& tf2,
                             std::vector<ContactPoint<double>>* contacts);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool conePlaneIntersect(const Cone<double>& s1, const Transform3<double>& tf1,
                         const Plane<double>& s2, const Transform3<double>& tf2,
                         std::vector<ContactPoint<double>>* contacts);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool convexPlaneIntersect(const Convex<double>& s1, const Transform3<double>& tf1,
                           const Plane<double>& s2, const Transform3<double>& tf2,
                           Vector3<double>* contact_points, double* penetration_depth, Vector3<double>* normal);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool planeTriangleIntersect(const Plane<double>& s1, const Transform3<double>& tf1,
                             const Vector3<double>& P1, const Vector3<double>& P2, const Vector3<double>& P3, const Transform3<double>& tf2,
                             Vector3<double>* contact_points, double* penetration_depth, Vector3<double>* normal);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool planeIntersect(const Plane<double>& s1, const Transform3<double>& tf1,
                     const Plane<double>& s2, const Transform3<double>& tf2,
                     std::vector<ContactPoint<double>>* contacts);
diff --git a/include/fcl/narrowphase/detail/primitive_shape_algorithm/plane.h b/include/fcl/narrowphase/detail/primitive_shape_algorithm/plane.h
index 86b141f..6014567 100755
--- a/include/fcl/narrowphase/detail/primitive_shape_algorithm/plane.h
+++ b/include/fcl/narrowphase/detail/primitive_shape_algorithm/plane.h
@@ -55,7 +55,6 @@ namespace detail
 {
 
 template <typename S>
-FCL_EXPORT
 S planeIntersectTolerance();
 
 template <>
@@ -67,13 +66,11 @@ FCL_EXPORT
 float planeIntersectTolerance();
 
 template <typename S>
-FCL_EXPORT
 bool spherePlaneIntersect(const Sphere<S>& s1, const Transform3<S>& tf1,
                           const Plane<S>& s2, const Transform3<S>& tf2,
                           std::vector<ContactPoint<S>>* contacts);
 
 template <typename S>
-FCL_EXPORT
 bool ellipsoidPlaneIntersect(const Ellipsoid<S>& s1, const Transform3<S>& tf1,
                              const Plane<S>& s2, const Transform3<S>& tf2,
                              std::vector<ContactPoint<S>>* contacts);
@@ -86,18 +83,15 @@ bool ellipsoidPlaneIntersect(const Ellipsoid<S>& s1, const Transform3<S>& tf1,
 /// (R^T n) (a v1 + b v2 + c v3) can get |(R^T n) (a v1 + b v2 + c v3)| for one a, b, c.
 /// if |d - n * T| <= |(R^T n)(a v1 + b v2 + c v3)| then can get both positive and negative value on the right side.
 template <typename S>
-FCL_EXPORT
 bool boxPlaneIntersect(const Box<S>& s1, const Transform3<S>& tf1,
                        const Plane<S>& s2, const Transform3<S>& tf2,
                        std::vector<ContactPoint<S>>* contacts);
 
 template <typename S>
-FCL_EXPORT
 bool capsulePlaneIntersect(const Capsule<S>& s1, const Transform3<S>& tf1,
                            const Plane<S>& s2, const Transform3<S>& tf2);
 
 template <typename S>
-FCL_EXPORT
 bool capsulePlaneIntersect(const Capsule<S>& s1, const Transform3<S>& tf1,
                            const Plane<S>& s2, const Transform3<S>& tf2,
                            std::vector<ContactPoint<S>>* contacts);
@@ -108,36 +102,30 @@ bool capsulePlaneIntersect(const Capsule<S>& s1, const Transform3<S>& tf1,
 /// (n^T * v3) * h + n * T -d + r * (cosa * (n^T * R * v1) + sina * (n^T * R * v2)) ~ 0
 /// (n^T * v3) * h + r * (cosa * (n^T * R * v1) + sina * (n^T * R * v2)) + n * T - d ~ 0
 template <typename S>
-FCL_EXPORT
 bool cylinderPlaneIntersect(const Cylinder<S>& s1, const Transform3<S>& tf1,
                             const Plane<S>& s2, const Transform3<S>& tf2);
 
 template <typename S>
-FCL_EXPORT
 bool cylinderPlaneIntersect(const Cylinder<S>& s1, const Transform3<S>& tf1,
                             const Plane<S>& s2, const Transform3<S>& tf2,
                             std::vector<ContactPoint<S>>* contacts);
 
 template <typename S>
-FCL_EXPORT
 bool conePlaneIntersect(const Cone<S>& s1, const Transform3<S>& tf1,
                         const Plane<S>& s2, const Transform3<S>& tf2,
                         std::vector<ContactPoint<S>>* contacts);
 
 template <typename S>
-FCL_EXPORT
 bool convexPlaneIntersect(const Convex<S>& s1, const Transform3<S>& tf1,
                           const Plane<S>& s2, const Transform3<S>& tf2,
                           Vector3<S>* contact_points, S* penetration_depth, Vector3<S>* normal);
 
 template <typename S>
-FCL_EXPORT
 bool planeTriangleIntersect(const Plane<S>& s1, const Transform3<S>& tf1,
                             const Vector3<S>& P1, const Vector3<S>& P2, const Vector3<S>& P3, const Transform3<S>& tf2,
                             Vector3<S>* contact_points, S* penetration_depth, Vector3<S>* normal);
 
 template <typename S>
-FCL_EXPORT
 bool planeIntersect(const Plane<S>& s1, const Transform3<S>& tf1,
                     const Plane<S>& s2, const Transform3<S>& tf2,
                     std::vector<ContactPoint<S>>* contacts);
diff --git a/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_box-inl.h b/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_box-inl.h
index 53cdace..219392e 100644
--- a/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_box-inl.h
+++ b/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_box-inl.h
@@ -42,18 +42,20 @@
 namespace fcl {
 namespace detail {
 
-extern template FCL_EXPORT bool
-sphereBoxIntersect(const Sphere<double>& sphere, const Transform3<double>& X_FS,
-                   const Box<double>& box, const Transform3<double>& X_FB,
-                   std::vector<ContactPoint<double>>* contacts);
+extern template
+FCL_EXPORT
+bool sphereBoxIntersect(const Sphere<double>& sphere, const Transform3<double>& X_FS,
+                        const Box<double>& box, const Transform3<double>& X_FB,
+                        std::vector<ContactPoint<double>>* contacts);
 
 //==============================================================================
 
-extern template FCL_EXPORT bool
-sphereBoxDistance(const Sphere<double>& sphere, const Transform3<double>& X_FS,
-                  const Box<double>& box, const Transform3<double>& X_FB,
-                  double* distance, Vector3<double>* p_FSb,
-                  Vector3<double>* p_FBs);
+extern template
+FCL_EXPORT
+bool sphereBoxDistance(const Sphere<double>& sphere, const Transform3<double>& X_FS,
+                       const Box<double>& box, const Transform3<double>& X_FB,
+                       double* distance, Vector3<double>* p_FSb,
+                       Vector3<double>* p_FBs);
 
 //==============================================================================
 
@@ -95,10 +97,10 @@ bool nearestPointInBox(const Vector3<S>& size, const Vector3<S>& p_BQ,
 //==============================================================================
 
 template <typename S>
-FCL_EXPORT bool sphereBoxIntersect(const Sphere<S>& sphere,
-                                   const Transform3<S>& X_FS, const Box<S>& box,
-                                   const Transform3<S>& X_FB,
-                                   std::vector<ContactPoint<S>>* contacts) {
+bool sphereBoxIntersect(const Sphere<S>& sphere,
+                        const Transform3<S>& X_FS, const Box<S>& box,
+                        const Transform3<S>& X_FB,
+                        std::vector<ContactPoint<S>>* contacts) {
   const S r = sphere.radius;
   // Find the sphere center C in the box's frame.
   const Transform3<S> X_BS = X_FB.inverse() * X_FS;
@@ -180,10 +182,10 @@ FCL_EXPORT bool sphereBoxIntersect(const Sphere<S>& sphere,
 //==============================================================================
 
 template <typename S>
-FCL_EXPORT bool sphereBoxDistance(const Sphere<S>& sphere,
-                                  const Transform3<S>& X_FS, const Box<S>& box,
-                                  const Transform3<S>& X_FB, S* distance,
-                                  Vector3<S>* p_FSb, Vector3<S>* p_FBs) {
+bool sphereBoxDistance(const Sphere<S>& sphere,
+                       const Transform3<S>& X_FS, const Box<S>& box,
+                       const Transform3<S>& X_FB, S* distance,
+                       Vector3<S>* p_FSb, Vector3<S>* p_FBs) {
   // Find the sphere center C in the box's frame.
   const Transform3<S> X_BS = X_FB.inverse() * X_FS;
   const Vector3<S> p_BC = X_BS.translation();
diff --git a/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_box.h b/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_box.h
index 87fabf8..478774b 100644
--- a/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_box.h
+++ b/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_box.h
@@ -107,10 +107,10 @@ namespace detail {
  @return True if the objects are colliding (including touching).
  @tparam S The scalar parameter (must be a valid Eigen scalar).  */
 template <typename S>
-FCL_EXPORT bool sphereBoxIntersect(const Sphere<S>& sphere,
-                                   const Transform3<S>& X_FS, const Box<S>& box,
-                                   const Transform3<S>& X_FB,
-                                   std::vector<ContactPoint<S>>* contacts);
+bool sphereBoxIntersect(const Sphere<S>& sphere,
+                        const Transform3<S>& X_FS, const Box<S>& box,
+                        const Transform3<S>& X_FB,
+                        std::vector<ContactPoint<S>>* contacts);
 
 /** Evaluate the minimum separating distance between a sphere and box. If
  separated, the nearest points on each shape will be returned in frame F.
@@ -127,10 +127,10 @@ FCL_EXPORT bool sphereBoxIntersect(const Sphere<S>& sphere,
  @return True if the objects are separated.
  @tparam S The scalar parameter (must be a valid Eigen scalar).  */
 template <typename S>
-FCL_EXPORT bool sphereBoxDistance(const Sphere<S>& sphere,
-                                  const Transform3<S>& X_FS, const Box<S>& box,
-                                  const Transform3<S>& X_FB, S* distance,
-                                  Vector3<S>* p_FSb, Vector3<S>* p_FBs);
+bool sphereBoxDistance(const Sphere<S>& sphere,
+                       const Transform3<S>& X_FS, const Box<S>& box,
+                       const Transform3<S>& X_FB, S* distance,
+                       Vector3<S>* p_FSb, Vector3<S>* p_FBs);
 
 //@}
 
diff --git a/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_capsule-inl.h b/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_capsule-inl.h
index c85d569..5d17649 100755
--- a/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_capsule-inl.h
+++ b/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_capsule-inl.h
@@ -48,6 +48,7 @@ namespace detail
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void lineSegmentPointClosestToPoint(
     const Vector3<double> &p,
     const Vector3<double> &s1,
@@ -56,12 +57,14 @@ void lineSegmentPointClosestToPoint(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool sphereCapsuleIntersect(const Sphere<double>& s1, const Transform3<double>& tf1,
                             const Capsule<double>& s2, const Transform3<double>& tf2,
                             std::vector<ContactPoint<double>>* contacts);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool sphereCapsuleDistance(const Sphere<double>& s1, const Transform3<double>& tf1,
                            const Capsule<double>& s2, const Transform3<double>& tf2,
                            double* dist, Vector3<double>* p1, Vector3<double>* p2);
diff --git a/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_capsule.h b/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_capsule.h
index 2820b32..81061f3 100755
--- a/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_capsule.h
+++ b/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_capsule.h
@@ -53,7 +53,6 @@ namespace detail
 // given by Dan Sunday's page:
 //   http://geomalgorithms.com/a02-_lines.html
 template <typename S>
-FCL_EXPORT
 void lineSegmentPointClosestToPoint(
     const Vector3<S> &p,
     const Vector3<S> &s1,
@@ -61,13 +60,11 @@ void lineSegmentPointClosestToPoint(
     Vector3<S> &sp);
 
 template <typename S>
-FCL_EXPORT
 bool sphereCapsuleIntersect(const Sphere<S>& s1, const Transform3<S>& tf1,
                             const Capsule<S>& s2, const Transform3<S>& tf2,
                             std::vector<ContactPoint<S>>* contacts);
 
 template <typename S>
-FCL_EXPORT
 bool sphereCapsuleDistance(const Sphere<S>& s1, const Transform3<S>& tf1,
                            const Capsule<S>& s2, const Transform3<S>& tf2,
                            S* dist, Vector3<S>* p1, Vector3<S>* p2);
diff --git a/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_cylinder-inl.h b/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_cylinder-inl.h
index 44070c0..cc8257a 100644
--- a/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_cylinder-inl.h
+++ b/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_cylinder-inl.h
@@ -42,22 +42,24 @@
 namespace fcl {
 namespace detail {
 
-extern template FCL_EXPORT bool
-sphereCylinderIntersect(const Sphere<double>& sphere,
-                        const Transform3<double>& X_FS,
-                        const Cylinder<double>& cylinder,
-                        const Transform3<double>& X_FC,
-                        std::vector<ContactPoint<double>>* contacts);
+extern template
+FCL_EXPORT
+bool sphereCylinderIntersect(const Sphere<double>& sphere,
+                             const Transform3<double>& X_FS,
+                             const Cylinder<double>& cylinder,
+                             const Transform3<double>& X_FC,
+                             std::vector<ContactPoint<double>>* contacts);
 
 //==============================================================================
 
-extern template FCL_EXPORT bool
-sphereCylinderDistance(const Sphere<double>& sphere,
-                       const Transform3<double>& X_FS,
-                       const Cylinder<double>& cylinder,
-                       const Transform3<double>& X_FC,
-                       double* distance, Vector3<double>* p_FSc,
-                       Vector3<double>* p_FCs);
+extern template
+FCL_EXPORT
+bool sphereCylinderDistance(const Sphere<double>& sphere,
+                            const Transform3<double>& X_FS,
+                            const Cylinder<double>& cylinder,
+                            const Transform3<double>& X_FC,
+                            double* distance, Vector3<double>* p_FSc,
+                            Vector3<double>* p_FCs);
 
 //==============================================================================
 
@@ -111,7 +113,7 @@ bool nearestPointInCylinder(const S& height, const S& radius,
 //==============================================================================
 
 template <typename S>
-FCL_EXPORT bool sphereCylinderIntersect(
+bool sphereCylinderIntersect(
     const Sphere<S>& sphere, const Transform3<S>& X_FS,
     const Cylinder<S>& cylinder, const Transform3<S>& X_FC,
     std::vector<ContactPoint<S>>* contacts) {
@@ -223,11 +225,11 @@ FCL_EXPORT bool sphereCylinderIntersect(
 //==============================================================================
 
 template <typename S>
-FCL_EXPORT bool sphereCylinderDistance(const Sphere<S>& sphere,
-                                       const Transform3<S>& X_FS,
-                                       const Cylinder<S>& cylinder,
-                                       const Transform3<S>& X_FC, S* distance,
-                                       Vector3<S>* p_FSc, Vector3<S>* p_FCs) {
+bool sphereCylinderDistance(const Sphere<S>& sphere,
+                            const Transform3<S>& X_FS,
+                            const Cylinder<S>& cylinder,
+                            const Transform3<S>& X_FC, S* distance,
+                            Vector3<S>* p_FSc, Vector3<S>* p_FCs) {
   // Find the sphere center S in the cylinder's frame.
   const Transform3<S> X_CS = X_FC.inverse() * X_FS;
   const Vector3<S> p_CS = X_CS.translation();
diff --git a/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_cylinder.h b/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_cylinder.h
index 4209b03..7f4fe6d 100644
--- a/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_cylinder.h
+++ b/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_cylinder.h
@@ -102,11 +102,11 @@ namespace detail {
  @return True if the objects are colliding (including touching).
  @tparam S The scalar parameter (must be a valid Eigen scalar).  */
 template <typename S>
-FCL_EXPORT bool sphereCylinderIntersect(const Sphere<S>& sphere,
-                                        const Transform3<S>& X_FS,
-                                        const Cylinder<S>& cylinder,
-                                        const Transform3<S>& X_FC,
-                                        std::vector<ContactPoint<S>>* contacts);
+bool sphereCylinderIntersect(const Sphere<S>& sphere,
+                             const Transform3<S>& X_FS,
+                             const Cylinder<S>& cylinder,
+                             const Transform3<S>& X_FC,
+                             std::vector<ContactPoint<S>>* contacts);
 
 /** Evaluate the minimum separating distance between a sphere and cylinder. If
  separated, the nearest points on each shape will be returned in frame F.
@@ -123,11 +123,11 @@ FCL_EXPORT bool sphereCylinderIntersect(const Sphere<S>& sphere,
  @return True if the objects are separated.
  @tparam S The scalar parameter (must be a valid Eigen scalar).  */
 template <typename S>
-FCL_EXPORT bool sphereCylinderDistance(const Sphere<S>& sphere,
-                                       const Transform3<S>& X_FS,
-                                       const Cylinder<S>& cylinder,
-                                       const Transform3<S>& X_FC, S* distance,
-                                       Vector3<S>* p_FSc, Vector3<S>* p_FCs);
+bool sphereCylinderDistance(const Sphere<S>& sphere,
+                            const Transform3<S>& X_FS,
+                            const Cylinder<S>& cylinder,
+                            const Transform3<S>& X_FC, S* distance,
+                            Vector3<S>* p_FSc, Vector3<S>* p_FCs);
 
 //@}
 
diff --git a/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_sphere-inl.h b/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_sphere-inl.h
index d12671c..2712aa9 100755
--- a/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_sphere-inl.h
+++ b/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_sphere-inl.h
@@ -62,7 +62,6 @@ bool sphereSphereDistance(const Sphere<double>& s1, const Transform3<double>& tf
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool sphereSphereIntersect(const Sphere<S>& s1, const Transform3<S>& tf1,
                            const Sphere<S>& s2, const Transform3<S>& tf2,
                            std::vector<ContactPoint<S>>* contacts)
@@ -87,7 +86,6 @@ bool sphereSphereIntersect(const Sphere<S>& s1, const Transform3<S>& tf1,
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 bool sphereSphereDistance(const Sphere<S>& s1, const Transform3<S>& tf1,
                           const Sphere<S>& s2, const Transform3<S>& tf2,
                           S* dist, Vector3<S>* p1, Vector3<S>* p2)
diff --git a/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_triangle-inl.h b/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_triangle-inl.h
index 0078900..64efd51 100755
--- a/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_triangle-inl.h
+++ b/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_triangle-inl.h
@@ -50,31 +50,37 @@ namespace detail
 
 //==============================================================================
 extern template
+FCL_EXPORT
 double segmentSqrDistance(const Vector3<double>& from, const Vector3<double>& to,const Vector3<double>& p, Vector3<double>& nearest);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool projectInTriangle(const Vector3<double>& p1, const Vector3<double>& p2, const Vector3<double>& p3, const Vector3<double>& normal, const Vector3<double>& p);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool sphereTriangleIntersect(const Sphere<double>& s, const Transform3<double>& tf,
                              const Vector3<double>& P1, const Vector3<double>& P2, const Vector3<double>& P3, Vector3<double>* contact_points, double* penetration_depth, Vector3<double>* normal_);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool sphereTriangleDistance(const Sphere<double>& sp, const Transform3<double>& tf,
                             const Vector3<double>& P1, const Vector3<double>& P2, const Vector3<double>& P3,
                             double* dist);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool sphereTriangleDistance(const Sphere<double>& sp, const Transform3<double>& tf,
                             const Vector3<double>& P1, const Vector3<double>& P2, const Vector3<double>& P3,
                             double* dist, Vector3<double>* p1, Vector3<double>* p2);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool sphereTriangleDistance(const Sphere<double>& sp, const Transform3<double>& tf1,
                             const Vector3<double>& P1, const Vector3<double>& P2, const Vector3<double>& P3, const Transform3<double>& tf2,
                             double* dist, Vector3<double>* p1, Vector3<double>* p2);
diff --git a/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_triangle.h b/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_triangle.h
index 15a2a70..61da0d5 100755
--- a/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_triangle.h
+++ b/include/fcl/narrowphase/detail/primitive_shape_algorithm/sphere_triangle.h
@@ -49,33 +49,27 @@ namespace detail
 
 /** @brief the minimum distance from a point to a line */
 template <typename S>
-FCL_EXPORT
 S segmentSqrDistance(const Vector3<S>& from, const Vector3<S>& to,const Vector3<S>& p, Vector3<S>& nearest);
 
 /// @brief Whether a point's projection is in a triangle
 template <typename S>
-FCL_EXPORT
 bool projectInTriangle(const Vector3<S>& p1, const Vector3<S>& p2, const Vector3<S>& p3, const Vector3<S>& normal, const Vector3<S>& p);
 
 template <typename S>
-FCL_EXPORT
 bool sphereTriangleIntersect(const Sphere<S>& s, const Transform3<S>& tf,
                              const Vector3<S>& P1, const Vector3<S>& P2, const Vector3<S>& P3, Vector3<S>* contact_points, S* penetration_depth, Vector3<S>* normal_);
 
 template <typename S>
-FCL_EXPORT
 bool sphereTriangleDistance(const Sphere<S>& sp, const Transform3<S>& tf,
                             const Vector3<S>& P1, const Vector3<S>& P2, const Vector3<S>& P3,
                             S* dist);
 
 template <typename S>
-FCL_EXPORT
 bool sphereTriangleDistance(const Sphere<S>& sp, const Transform3<S>& tf,
                             const Vector3<S>& P1, const Vector3<S>& P2, const Vector3<S>& P3,
                             S* dist, Vector3<S>* p1, Vector3<S>* p2);
 
 template <typename S>
-FCL_EXPORT
 bool sphereTriangleDistance(const Sphere<S>& sp, const Transform3<S>& tf1,
                             const Vector3<S>& P1, const Vector3<S>& P2, const Vector3<S>& P3, const Transform3<S>& tf2,
                             S* dist, Vector3<S>* p1, Vector3<S>* p2);
diff --git a/include/fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance-inl.h b/include/fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance-inl.h
index 33a1d4f..c6f6502 100644
--- a/include/fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance-inl.h
+++ b/include/fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance-inl.h
@@ -1,467 +1,467 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#ifndef FCL_NARROWPHASE_DETAIL_TRIANGLEDISTANCE_INL_H
-#define FCL_NARROWPHASE_DETAIL_TRIANGLEDISTANCE_INL_H
-
-#include "fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance.h"
-
-namespace fcl
-{
-
-namespace detail
-{
-
-//==============================================================================
-extern template
-class FCL_EXPORT TriangleDistance<double>;
-
-//==============================================================================
-template <typename S>
-void TriangleDistance<S>::segPoints(const Vector3<S>& P, const Vector3<S>& A, const Vector3<S>& Q, const Vector3<S>& B,
-                                 Vector3<S>& VEC, Vector3<S>& X, Vector3<S>& Y)
-{
-  Vector3<S> T;
-  S A_dot_A, B_dot_B, A_dot_B, A_dot_T, B_dot_T;
-  Vector3<S> TMP;
-
-  T = Q - P;
-  A_dot_A = A.dot(A);
-  B_dot_B = B.dot(B);
-  A_dot_B = A.dot(B);
-  A_dot_T = A.dot(T);
-  B_dot_T = B.dot(T);
-
-  // t parameterizes ray P,A
-  // u parameterizes ray Q,B
-
-  S t, u;
-
-  // compute t for the closest point on ray P,A to
-  // ray Q,B
-
-  S denom = A_dot_A*B_dot_B - A_dot_B*A_dot_B;
-
-  t = (A_dot_T*B_dot_B - B_dot_T*A_dot_B) / denom;
-
-  // clamp result so t is on the segment P,A
-
-  if((t < 0) || std::isnan(t)) t = 0; else if(t > 1) t = 1;
-
-  // find u for point on ray Q,B closest to point at t
-
-  u = (t*A_dot_B - B_dot_T) / B_dot_B;
-
-  // if u is on segment Q,B, t and u correspond to
-  // closest points, otherwise, clamp u, recompute and
-  // clamp t
-
-  if((u <= 0) || std::isnan(u))
-  {
-    Y = Q;
-
-    t = A_dot_T / A_dot_A;
-
-    if((t <= 0) || std::isnan(t))
-    {
-      X = P;
-      VEC = Q - P;
-    }
-    else if(t >= 1)
-    {
-      X = P + A;
-      VEC = Q - X;
-    }
-    else
-    {
-      X = P + A * t;
-      TMP = T.cross(A);
-      VEC = A.cross(TMP);
-    }
-  }
-  else if (u >= 1)
-  {
-    Y = Q + B;
-
-    t = (A_dot_B + A_dot_T) / A_dot_A;
-
-    if((t <= 0) || std::isnan(t))
-    {
-      X = P;
-      VEC = Y - P;
-    }
-    else if(t >= 1)
-    {
-      X = P + A;
-      VEC = Y - X;
-    }
-    else
-    {
-      X = P + A * t;
-      T = Y - P;
-      TMP = T.cross(A);
-      VEC= A.cross(TMP);
-    }
-  }
-  else
-  {
-    Y = Q + B * u;
-
-    if((t <= 0) || std::isnan(t))
-    {
-      X = P;
-      TMP = T.cross(B);
-      VEC = B.cross(TMP);
-    }
-    else if(t >= 1)
-    {
-      X = P + A;
-      T = Q - X;
-      TMP = T.cross(B);
-      VEC = B.cross(TMP);
-    }
-    else
-    {
-      X = P + A * t;
-      VEC = A.cross(B);
-      if(VEC.dot(T) < 0)
-      {
-        VEC = VEC * (-1);
-      }
-    }
-  }
-}
-
-//==============================================================================
-template <typename S>
-S TriangleDistance<S>::triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3], Vector3<S>& P, Vector3<S>& Q)
-{
-  // Compute vectors along the 6 sides
-
-  Vector3<S> Sv[3];
-  Vector3<S> Tv[3];
-  Vector3<S> VEC;
-
-  Sv[0] = T1[1] - T1[0];
-  Sv[1] = T1[2] - T1[1];
-  Sv[2] = T1[0] - T1[2];
-
-  Tv[0] = T2[1] - T2[0];
-  Tv[1] = T2[2] - T2[1];
-  Tv[2] = T2[0] - T2[2];
-
-  // For each edge pair, the vector connecting the closest points
-  // of the edges defines a slab (parallel planes at head and tail
-  // enclose the slab). If we can show that the off-edge vertex of
-  // each triangle is outside of the slab, then the closest points
-  // of the edges are the closest points for the triangles.
-  // Even if these tests fail, it may be helpful to know the closest
-  // points found, and whether the triangles were shown disjoint
-
-  Vector3<S> V;
-  Vector3<S> Z;
-  Vector3<S> minP = Vector3<S>::Zero();
-  Vector3<S> minQ = Vector3<S>::Zero();
-  S mindd;
-  int shown_disjoint = 0;
-
-  mindd = (T1[0] - T2[0]).squaredNorm() + 1; // Set first minimum safely high
-
-  for(int i = 0; i < 3; ++i)
-  {
-    for(int j = 0; j < 3; ++j)
-    {
-      // Find closest points on edges i & j, plus the
-      // vector (and distance squared) between these points
-      segPoints(T1[i], Sv[i], T2[j], Tv[j], VEC, P, Q);
-
-      V = Q - P;
-      S dd = V.dot(V);
-
-      // Verify this closest point pair only if the distance
-      // squared is less than the minimum found thus far.
-
-      if(dd <= mindd)
-      {
-        minP = P;
-        minQ = Q;
-        mindd = dd;
-
-        Z = T1[(i+2)%3] - P;
-        S a = Z.dot(VEC);
-        Z = T2[(j+2)%3] - Q;
-        S b = Z.dot(VEC);
-
-        if((a <= 0) && (b >= 0)) return sqrt(dd);
-
-        S p = V.dot(VEC);
-
-        if(a < 0) a = 0;
-        if(b > 0) b = 0;
-        if((p - a + b) > 0) shown_disjoint = 1;
-      }
-    }
-  }
-
-  // No edge pairs contained the closest points.
-  // either:
-  // 1. one of the closest points is a vertex, and the
-  //    other point is interior to a face.
-  // 2. the triangles are overlapping.
-  // 3. an edge of one triangle is parallel to the other's face. If
-  //    cases 1 and 2 are not true, then the closest points from the 9
-  //    edge pairs checks above can be taken as closest points for the
-  //    triangles.
-  // 4. possibly, the triangles were degenerate.  When the
-  //    triangle points are nearly colinear or coincident, one
-  //    of above tests might fail even though the edges tested
-  //    contain the closest points.
-
-  // First check for case 1
-
-  Vector3<S> Sn;
-  S Snl;
-
-  Sn = Sv[0].cross(Sv[1]); // Compute normal to T1 triangle
-  Snl = Sn.dot(Sn);        // Compute square of length of normal
-
-  // If cross product is long enough,
-
-  if(Snl > 1e-15)
-  {
-    // Get projection lengths of T2 points
-
-    Vector3<S> Tp;
-
-    V = T1[0] - T2[0];
-    Tp[0] = V.dot(Sn);
-
-    V = T1[0] - T2[1];
-    Tp[1] = V.dot(Sn);
-
-    V = T1[0] - T2[2];
-    Tp[2] = V.dot(Sn);
-
-    // If Sn is a separating direction,
-    // find point with smallest projection
-
-    int point = -1;
-    if((Tp[0] > 0) && (Tp[1] > 0) && (Tp[2] > 0))
-    {
-      if(Tp[0] < Tp[1]) point = 0; else point = 1;
-      if(Tp[2] < Tp[point]) point = 2;
-    }
-    else if((Tp[0] < 0) && (Tp[1] < 0) && (Tp[2] < 0))
-    {
-      if(Tp[0] > Tp[1]) point = 0; else point = 1;
-      if(Tp[2] > Tp[point]) point = 2;
-    }
-
-    // If Sn is a separating direction,
-
-    if(point >= 0)
-    {
-      shown_disjoint = 1;
-
-      // Test whether the point found, when projected onto the
-      // other triangle, lies within the face.
-
-      V = T2[point] - T1[0];
-      Z = Sn.cross(Sv[0]);
-      if(V.dot(Z) > 0)
-      {
-        V = T2[point] - T1[1];
-        Z = Sn.cross(Sv[1]);
-        if(V.dot(Z) > 0)
-        {
-          V = T2[point] - T1[2];
-          Z = Sn.cross(Sv[2]);
-          if(V.dot(Z) > 0)
-          {
-            // T[point] passed the test - it's a closest point for
-            // the T2 triangle; the other point is on the face of T1
-            P = T2[point] + Sn * (Tp[point] / Snl);
-            Q = T2[point];
-            return (P - Q).norm();
-          }
-        }
-      }
-    }
-  }
-
-  Vector3<S> Tn;
-  S Tnl;
-
-  Tn = Tv[0].cross(Tv[1]);
-  Tnl = Tn.dot(Tn);
-
-  if(Tnl > 1e-15)
-  {
-    Vector3<S> Sp;
-
-    V = T2[0] - T1[0];
-    Sp[0] = V.dot(Tn);
-
-    V = T2[0] - T1[1];
-    Sp[1] = V.dot(Tn);
-
-    V = T2[0] - T1[2];
-    Sp[2] = V.dot(Tn);
-
-    int point = -1;
-    if((Sp[0] > 0) && (Sp[1] > 0) && (Sp[2] > 0))
-    {
-      if(Sp[0] < Sp[1]) point = 0; else point = 1;
-      if(Sp[2] < Sp[point]) point = 2;
-    }
-    else if((Sp[0] < 0) && (Sp[1] < 0) && (Sp[2] < 0))
-    {
-      if(Sp[0] > Sp[1]) point = 0; else point = 1;
-      if(Sp[2] > Sp[point]) point = 2;
-    }
-
-    if(point >= 0)
-    {
-      shown_disjoint = 1;
-
-      V = T1[point] - T2[0];
-      Z = Tn.cross(Tv[0]);
-      if(V.dot(Z) > 0)
-      {
-        V = T1[point] - T2[1];
-        Z = Tn.cross(Tv[1]);
-        if(V.dot(Z) > 0)
-        {
-          V = T1[point] - T2[2];
-          Z = Tn.cross(Tv[2]);
-          if(V.dot(Z) > 0)
-          {
-            P = T1[point];
-            Q = T1[point] + Tn * (Sp[point] / Tnl);
-            return (P - Q).norm();
-          }
-        }
-      }
-    }
-  }
-
-  // Case 1 can't be shown.
-  // If one of these tests showed the triangles disjoint,
-  // we assume case 3 or 4, otherwise we conclude case 2,
-  // that the triangles overlap.
-
-  if(shown_disjoint)
-  {
-    P = minP;
-    Q = minQ;
-    return sqrt(mindd);
-  }
-  else return 0;
-}
-
-//==============================================================================
-template <typename S>
-S TriangleDistance<S>::triDistance(const Vector3<S>& S1, const Vector3<S>& S2, const Vector3<S>& S3,
-                                       const Vector3<S>& T1, const Vector3<S>& T2, const Vector3<S>& T3,
-                                       Vector3<S>& P, Vector3<S>& Q)
-{
-  Vector3<S> U[3];
-  Vector3<S> T[3];
-  U[0] = S1; U[1] = S2; U[2] = S3;
-  T[0] = T1; T[1] = T2; T[2] = T3;
-
-  return triDistance(U, T, P, Q);
-}
-
-//==============================================================================
-template <typename S>
-S TriangleDistance<S>::triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3],
-                                       const Matrix3<S>& R, const Vector3<S>& Tl,
-                                       Vector3<S>& P, Vector3<S>& Q)
-{
-  Vector3<S> T_transformed[3];
-  T_transformed[0] = R * T2[0] + Tl;
-  T_transformed[1] = R * T2[1] + Tl;
-  T_transformed[2] = R * T2[2] + Tl;
-
-  return triDistance(T1, T_transformed, P, Q);
-}
-
-//==============================================================================
-template <typename S>
-S TriangleDistance<S>::triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3],
-                                       const Transform3<S>& tf,
-                                       Vector3<S>& P, Vector3<S>& Q)
-{
-  Vector3<S> T_transformed[3];
-  T_transformed[0] = tf * T2[0];
-  T_transformed[1] = tf * T2[1];
-  T_transformed[2] = tf * T2[2];
-
-  return triDistance(T1, T_transformed, P, Q);
-}
-
-//==============================================================================
-template <typename S>
-S TriangleDistance<S>::triDistance(const Vector3<S>& S1, const Vector3<S>& S2, const Vector3<S>& S3,
-                                       const Vector3<S>& T1, const Vector3<S>& T2, const Vector3<S>& T3,
-                                       const Matrix3<S>& R, const Vector3<S>& Tl,
-                                       Vector3<S>& P, Vector3<S>& Q)
-{
-  Vector3<S> T1_transformed = R * T1 + Tl;
-  Vector3<S> T2_transformed = R * T2 + Tl;
-  Vector3<S> T3_transformed = R * T3 + Tl;
-  return triDistance(S1, S2, S3, T1_transformed, T2_transformed, T3_transformed, P, Q);
-}
-
-//==============================================================================
-template <typename S>
-S TriangleDistance<S>::triDistance(const Vector3<S>& S1, const Vector3<S>& S2, const Vector3<S>& S3,
-                                       const Vector3<S>& T1, const Vector3<S>& T2, const Vector3<S>& T3,
-                                       const Transform3<S>& tf,
-                                       Vector3<S>& P, Vector3<S>& Q)
-{
-  Vector3<S> T1_transformed = tf * T1;
-  Vector3<S> T2_transformed = tf * T2;
-  Vector3<S> T3_transformed = tf * T3;
-  return triDistance(S1, S2, S3, T1_transformed, T2_transformed, T3_transformed, P, Q);
-}
-
-} // namespace detail
-} // namespace fcl
-
-#endif
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#ifndef FCL_NARROWPHASE_DETAIL_TRIANGLEDISTANCE_INL_H
+#define FCL_NARROWPHASE_DETAIL_TRIANGLEDISTANCE_INL_H
+
+#include "fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance.h"
+
+namespace fcl
+{
+
+namespace detail
+{
+
+//==============================================================================
+extern template
+class FCL_EXPORT TriangleDistance<double>;
+
+//==============================================================================
+template <typename S>
+void TriangleDistance<S>::segPoints(const Vector3<S>& P, const Vector3<S>& A, const Vector3<S>& Q, const Vector3<S>& B,
+                                 Vector3<S>& VEC, Vector3<S>& X, Vector3<S>& Y)
+{
+  Vector3<S> T;
+  S A_dot_A, B_dot_B, A_dot_B, A_dot_T, B_dot_T;
+  Vector3<S> TMP;
+
+  T = Q - P;
+  A_dot_A = A.dot(A);
+  B_dot_B = B.dot(B);
+  A_dot_B = A.dot(B);
+  A_dot_T = A.dot(T);
+  B_dot_T = B.dot(T);
+
+  // t parameterizes ray P,A
+  // u parameterizes ray Q,B
+
+  S t, u;
+
+  // compute t for the closest point on ray P,A to
+  // ray Q,B
+
+  S denom = A_dot_A*B_dot_B - A_dot_B*A_dot_B;
+
+  t = (A_dot_T*B_dot_B - B_dot_T*A_dot_B) / denom;
+
+  // clamp result so t is on the segment P,A
+
+  if((t < 0) || std::isnan(t)) t = 0; else if(t > 1) t = 1;
+
+  // find u for point on ray Q,B closest to point at t
+
+  u = (t*A_dot_B - B_dot_T) / B_dot_B;
+
+  // if u is on segment Q,B, t and u correspond to
+  // closest points, otherwise, clamp u, recompute and
+  // clamp t
+
+  if((u <= 0) || std::isnan(u))
+  {
+    Y = Q;
+
+    t = A_dot_T / A_dot_A;
+
+    if((t <= 0) || std::isnan(t))
+    {
+      X = P;
+      VEC = Q - P;
+    }
+    else if(t >= 1)
+    {
+      X = P + A;
+      VEC = Q - X;
+    }
+    else
+    {
+      X = P + A * t;
+      TMP = T.cross(A);
+      VEC = A.cross(TMP);
+    }
+  }
+  else if (u >= 1)
+  {
+    Y = Q + B;
+
+    t = (A_dot_B + A_dot_T) / A_dot_A;
+
+    if((t <= 0) || std::isnan(t))
+    {
+      X = P;
+      VEC = Y - P;
+    }
+    else if(t >= 1)
+    {
+      X = P + A;
+      VEC = Y - X;
+    }
+    else
+    {
+      X = P + A * t;
+      T = Y - P;
+      TMP = T.cross(A);
+      VEC= A.cross(TMP);
+    }
+  }
+  else
+  {
+    Y = Q + B * u;
+
+    if((t <= 0) || std::isnan(t))
+    {
+      X = P;
+      TMP = T.cross(B);
+      VEC = B.cross(TMP);
+    }
+    else if(t >= 1)
+    {
+      X = P + A;
+      T = Q - X;
+      TMP = T.cross(B);
+      VEC = B.cross(TMP);
+    }
+    else
+    {
+      X = P + A * t;
+      VEC = A.cross(B);
+      if(VEC.dot(T) < 0)
+      {
+        VEC = VEC * (-1);
+      }
+    }
+  }
+}
+
+//==============================================================================
+template <typename S>
+S TriangleDistance<S>::triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3], Vector3<S>& P, Vector3<S>& Q)
+{
+  // Compute vectors along the 6 sides
+
+  Vector3<S> Sv[3];
+  Vector3<S> Tv[3];
+  Vector3<S> VEC;
+
+  Sv[0] = T1[1] - T1[0];
+  Sv[1] = T1[2] - T1[1];
+  Sv[2] = T1[0] - T1[2];
+
+  Tv[0] = T2[1] - T2[0];
+  Tv[1] = T2[2] - T2[1];
+  Tv[2] = T2[0] - T2[2];
+
+  // For each edge pair, the vector connecting the closest points
+  // of the edges defines a slab (parallel planes at head and tail
+  // enclose the slab). If we can show that the off-edge vertex of
+  // each triangle is outside of the slab, then the closest points
+  // of the edges are the closest points for the triangles.
+  // Even if these tests fail, it may be helpful to know the closest
+  // points found, and whether the triangles were shown disjoint
+
+  Vector3<S> V;
+  Vector3<S> Z;
+  Vector3<S> minP = Vector3<S>::Zero();
+  Vector3<S> minQ = Vector3<S>::Zero();
+  S mindd;
+  int shown_disjoint = 0;
+
+  mindd = (T1[0] - T2[0]).squaredNorm() + 1; // Set first minimum safely high
+
+  for(int i = 0; i < 3; ++i)
+  {
+    for(int j = 0; j < 3; ++j)
+    {
+      // Find closest points on edges i & j, plus the
+      // vector (and distance squared) between these points
+      segPoints(T1[i], Sv[i], T2[j], Tv[j], VEC, P, Q);
+
+      V = Q - P;
+      S dd = V.dot(V);
+
+      // Verify this closest point pair only if the distance
+      // squared is less than the minimum found thus far.
+
+      if(dd <= mindd)
+      {
+        minP = P;
+        minQ = Q;
+        mindd = dd;
+
+        Z = T1[(i+2)%3] - P;
+        S a = Z.dot(VEC);
+        Z = T2[(j+2)%3] - Q;
+        S b = Z.dot(VEC);
+
+        if((a <= 0) && (b >= 0)) return sqrt(dd);
+
+        S p = V.dot(VEC);
+
+        if(a < 0) a = 0;
+        if(b > 0) b = 0;
+        if((p - a + b) > 0) shown_disjoint = 1;
+      }
+    }
+  }
+
+  // No edge pairs contained the closest points.
+  // either:
+  // 1. one of the closest points is a vertex, and the
+  //    other point is interior to a face.
+  // 2. the triangles are overlapping.
+  // 3. an edge of one triangle is parallel to the other's face. If
+  //    cases 1 and 2 are not true, then the closest points from the 9
+  //    edge pairs checks above can be taken as closest points for the
+  //    triangles.
+  // 4. possibly, the triangles were degenerate.  When the
+  //    triangle points are nearly colinear or coincident, one
+  //    of above tests might fail even though the edges tested
+  //    contain the closest points.
+
+  // First check for case 1
+
+  Vector3<S> Sn;
+  S Snl;
+
+  Sn = Sv[0].cross(Sv[1]); // Compute normal to T1 triangle
+  Snl = Sn.dot(Sn);        // Compute square of length of normal
+
+  // If cross product is long enough,
+
+  if(Snl > 1e-15)
+  {
+    // Get projection lengths of T2 points
+
+    Vector3<S> Tp;
+
+    V = T1[0] - T2[0];
+    Tp[0] = V.dot(Sn);
+
+    V = T1[0] - T2[1];
+    Tp[1] = V.dot(Sn);
+
+    V = T1[0] - T2[2];
+    Tp[2] = V.dot(Sn);
+
+    // If Sn is a separating direction,
+    // find point with smallest projection
+
+    int point = -1;
+    if((Tp[0] > 0) && (Tp[1] > 0) && (Tp[2] > 0))
+    {
+      if(Tp[0] < Tp[1]) point = 0; else point = 1;
+      if(Tp[2] < Tp[point]) point = 2;
+    }
+    else if((Tp[0] < 0) && (Tp[1] < 0) && (Tp[2] < 0))
+    {
+      if(Tp[0] > Tp[1]) point = 0; else point = 1;
+      if(Tp[2] > Tp[point]) point = 2;
+    }
+
+    // If Sn is a separating direction,
+
+    if(point >= 0)
+    {
+      shown_disjoint = 1;
+
+      // Test whether the point found, when projected onto the
+      // other triangle, lies within the face.
+
+      V = T2[point] - T1[0];
+      Z = Sn.cross(Sv[0]);
+      if(V.dot(Z) > 0)
+      {
+        V = T2[point] - T1[1];
+        Z = Sn.cross(Sv[1]);
+        if(V.dot(Z) > 0)
+        {
+          V = T2[point] - T1[2];
+          Z = Sn.cross(Sv[2]);
+          if(V.dot(Z) > 0)
+          {
+            // T[point] passed the test - it's a closest point for
+            // the T2 triangle; the other point is on the face of T1
+            P = T2[point] + Sn * (Tp[point] / Snl);
+            Q = T2[point];
+            return (P - Q).norm();
+          }
+        }
+      }
+    }
+  }
+
+  Vector3<S> Tn;
+  S Tnl;
+
+  Tn = Tv[0].cross(Tv[1]);
+  Tnl = Tn.dot(Tn);
+
+  if(Tnl > 1e-15)
+  {
+    Vector3<S> Sp;
+
+    V = T2[0] - T1[0];
+    Sp[0] = V.dot(Tn);
+
+    V = T2[0] - T1[1];
+    Sp[1] = V.dot(Tn);
+
+    V = T2[0] - T1[2];
+    Sp[2] = V.dot(Tn);
+
+    int point = -1;
+    if((Sp[0] > 0) && (Sp[1] > 0) && (Sp[2] > 0))
+    {
+      if(Sp[0] < Sp[1]) point = 0; else point = 1;
+      if(Sp[2] < Sp[point]) point = 2;
+    }
+    else if((Sp[0] < 0) && (Sp[1] < 0) && (Sp[2] < 0))
+    {
+      if(Sp[0] > Sp[1]) point = 0; else point = 1;
+      if(Sp[2] > Sp[point]) point = 2;
+    }
+
+    if(point >= 0)
+    {
+      shown_disjoint = 1;
+
+      V = T1[point] - T2[0];
+      Z = Tn.cross(Tv[0]);
+      if(V.dot(Z) > 0)
+      {
+        V = T1[point] - T2[1];
+        Z = Tn.cross(Tv[1]);
+        if(V.dot(Z) > 0)
+        {
+          V = T1[point] - T2[2];
+          Z = Tn.cross(Tv[2]);
+          if(V.dot(Z) > 0)
+          {
+            P = T1[point];
+            Q = T1[point] + Tn * (Sp[point] / Tnl);
+            return (P - Q).norm();
+          }
+        }
+      }
+    }
+  }
+
+  // Case 1 can't be shown.
+  // If one of these tests showed the triangles disjoint,
+  // we assume case 3 or 4, otherwise we conclude case 2,
+  // that the triangles overlap.
+
+  if(shown_disjoint)
+  {
+    P = minP;
+    Q = minQ;
+    return sqrt(mindd);
+  }
+  else return 0;
+}
+
+//==============================================================================
+template <typename S>
+S TriangleDistance<S>::triDistance(const Vector3<S>& S1, const Vector3<S>& S2, const Vector3<S>& S3,
+                                       const Vector3<S>& T1, const Vector3<S>& T2, const Vector3<S>& T3,
+                                       Vector3<S>& P, Vector3<S>& Q)
+{
+  Vector3<S> U[3];
+  Vector3<S> T[3];
+  U[0] = S1; U[1] = S2; U[2] = S3;
+  T[0] = T1; T[1] = T2; T[2] = T3;
+
+  return triDistance(U, T, P, Q);
+}
+
+//==============================================================================
+template <typename S>
+S TriangleDistance<S>::triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3],
+                                       const Matrix3<S>& R, const Vector3<S>& Tl,
+                                       Vector3<S>& P, Vector3<S>& Q)
+{
+  Vector3<S> T_transformed[3];
+  T_transformed[0] = R * T2[0] + Tl;
+  T_transformed[1] = R * T2[1] + Tl;
+  T_transformed[2] = R * T2[2] + Tl;
+
+  return triDistance(T1, T_transformed, P, Q);
+}
+
+//==============================================================================
+template <typename S>
+S TriangleDistance<S>::triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3],
+                                       const Transform3<S>& tf,
+                                       Vector3<S>& P, Vector3<S>& Q)
+{
+  Vector3<S> T_transformed[3];
+  T_transformed[0] = tf * T2[0];
+  T_transformed[1] = tf * T2[1];
+  T_transformed[2] = tf * T2[2];
+
+  return triDistance(T1, T_transformed, P, Q);
+}
+
+//==============================================================================
+template <typename S>
+S TriangleDistance<S>::triDistance(const Vector3<S>& S1, const Vector3<S>& S2, const Vector3<S>& S3,
+                                       const Vector3<S>& T1, const Vector3<S>& T2, const Vector3<S>& T3,
+                                       const Matrix3<S>& R, const Vector3<S>& Tl,
+                                       Vector3<S>& P, Vector3<S>& Q)
+{
+  Vector3<S> T1_transformed = R * T1 + Tl;
+  Vector3<S> T2_transformed = R * T2 + Tl;
+  Vector3<S> T3_transformed = R * T3 + Tl;
+  return triDistance(S1, S2, S3, T1_transformed, T2_transformed, T3_transformed, P, Q);
+}
+
+//==============================================================================
+template <typename S>
+S TriangleDistance<S>::triDistance(const Vector3<S>& S1, const Vector3<S>& S2, const Vector3<S>& S3,
+                                       const Vector3<S>& T1, const Vector3<S>& T2, const Vector3<S>& T3,
+                                       const Transform3<S>& tf,
+                                       Vector3<S>& P, Vector3<S>& Q)
+{
+  Vector3<S> T1_transformed = tf * T1;
+  Vector3<S> T2_transformed = tf * T2;
+  Vector3<S> T3_transformed = tf * T3;
+  return triDistance(S1, S2, S3, T1_transformed, T2_transformed, T3_transformed, P, Q);
+}
+
+} // namespace detail
+} // namespace fcl
+
+#endif
diff --git a/include/fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance.h b/include/fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance.h
index cb4b2e6..b32408d 100644
--- a/include/fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance.h
+++ b/include/fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance.h
@@ -1,114 +1,114 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#ifndef FCL_NARROWPHASE_DETAIL_TRIANGLEDISTANCE_H
-#define FCL_NARROWPHASE_DETAIL_TRIANGLEDISTANCE_H
-
-#include "fcl/common/types.h"
-
-namespace fcl
-{
-
-namespace detail
-{
-
-/// @brief Triangle distance functions
-template <typename S>
-class FCL_EXPORT TriangleDistance
-{
-public:
-
-  /// @brief Returns closest points between an segment pair.
-  /// The first segment is P + t * A
-  /// The second segment is Q + t * B
-  /// X, Y are the closest points on the two segments
-  /// VEC is the vector between X and Y
-  static void segPoints(const Vector3<S>& P, const Vector3<S>& A, const Vector3<S>& Q, const Vector3<S>& B,
-                        Vector3<S>& VEC, Vector3<S>& X, Vector3<S>& Y);
-
-  /// @brief Compute the closest points on two triangles given their absolute coordinate, and returns the distance between them
-  /// T1 and T2 are two triangles
-  /// If the triangles are disjoint, P and Q give the closet points of T1 and T2 respectively. However,
-  /// if the triangles overlap, P and Q are basically a random pair of points from the triangles, not
-  /// coincident points on the intersection of the triangles, as might be expected.
-  static S triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3], Vector3<S>& P, Vector3<S>& Q);
-
-  static S triDistance(const Vector3<S>& S1, const Vector3<S>& S2, const Vector3<S>& S3,
-                              const Vector3<S>& T1, const Vector3<S>& T2, const Vector3<S>& T3,
-                              Vector3<S>& P, Vector3<S>& Q);
-
-  /// @brief Compute the closest points on two triangles given the relative transform between them, and returns the distance between them
-  /// T1 and T2 are two triangles
-  /// If the triangles are disjoint, P and Q give the closet points of T1 and T2 respectively. However,
-  /// if the triangles overlap, P and Q are basically a random pair of points from the triangles, not
-  /// coincident points on the intersection of the triangles, as might be expected.
-  /// The returned P and Q are both in the coordinate of the first triangle's coordinate
-  static S triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3],
-                              const Matrix3<S>& R, const Vector3<S>& Tl,
-                              Vector3<S>& P, Vector3<S>& Q);
-
-  static S triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3],
-                              const Transform3<S>& tf,
-                              Vector3<S>& P, Vector3<S>& Q);
-
-  static S triDistance(const Vector3<S>& S1, const Vector3<S>& S2, const Vector3<S>& S3,
-                              const Vector3<S>& T1, const Vector3<S>& T2, const Vector3<S>& T3,
-                              const Matrix3<S>& R, const Vector3<S>& Tl,
-                              Vector3<S>& P, Vector3<S>& Q);
-
-  static S triDistance(
-      const Vector3<S>& S1,
-      const Vector3<S>& S2,
-      const Vector3<S>& S3,
-      const Vector3<S>& T1,
-      const Vector3<S>& T2,
-      const Vector3<S>& T3,
-      const Transform3<S>& tf,
-      Vector3<S>& P,
-      Vector3<S>& Q);
-
-};
-
-using TriangleDistancef = TriangleDistance<float>;
-using TriangleDistanced = TriangleDistance<double>;
-
-} // namespace detail
-} // namespace fcl
-
-#include "fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance-inl.h"
-
-#endif
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#ifndef FCL_NARROWPHASE_DETAIL_TRIANGLEDISTANCE_H
+#define FCL_NARROWPHASE_DETAIL_TRIANGLEDISTANCE_H
+
+#include "fcl/common/types.h"
+
+namespace fcl
+{
+
+namespace detail
+{
+
+/// @brief Triangle distance functions
+template <typename S>
+class TriangleDistance
+{
+public:
+
+  /// @brief Returns closest points between an segment pair.
+  /// The first segment is P + t * A
+  /// The second segment is Q + t * B
+  /// X, Y are the closest points on the two segments
+  /// VEC is the vector between X and Y
+  static void segPoints(const Vector3<S>& P, const Vector3<S>& A, const Vector3<S>& Q, const Vector3<S>& B,
+                        Vector3<S>& VEC, Vector3<S>& X, Vector3<S>& Y);
+
+  /// @brief Compute the closest points on two triangles given their absolute coordinate, and returns the distance between them
+  /// T1 and T2 are two triangles
+  /// If the triangles are disjoint, P and Q give the closet points of T1 and T2 respectively. However,
+  /// if the triangles overlap, P and Q are basically a random pair of points from the triangles, not
+  /// coincident points on the intersection of the triangles, as might be expected.
+  static S triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3], Vector3<S>& P, Vector3<S>& Q);
+
+  static S triDistance(const Vector3<S>& S1, const Vector3<S>& S2, const Vector3<S>& S3,
+                              const Vector3<S>& T1, const Vector3<S>& T2, const Vector3<S>& T3,
+                              Vector3<S>& P, Vector3<S>& Q);
+
+  /// @brief Compute the closest points on two triangles given the relative transform between them, and returns the distance between them
+  /// T1 and T2 are two triangles
+  /// If the triangles are disjoint, P and Q give the closet points of T1 and T2 respectively. However,
+  /// if the triangles overlap, P and Q are basically a random pair of points from the triangles, not
+  /// coincident points on the intersection of the triangles, as might be expected.
+  /// The returned P and Q are both in the coordinate of the first triangle's coordinate
+  static S triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3],
+                              const Matrix3<S>& R, const Vector3<S>& Tl,
+                              Vector3<S>& P, Vector3<S>& Q);
+
+  static S triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3],
+                              const Transform3<S>& tf,
+                              Vector3<S>& P, Vector3<S>& Q);
+
+  static S triDistance(const Vector3<S>& S1, const Vector3<S>& S2, const Vector3<S>& S3,
+                              const Vector3<S>& T1, const Vector3<S>& T2, const Vector3<S>& T3,
+                              const Matrix3<S>& R, const Vector3<S>& Tl,
+                              Vector3<S>& P, Vector3<S>& Q);
+
+  static S triDistance(
+      const Vector3<S>& S1,
+      const Vector3<S>& S2,
+      const Vector3<S>& S3,
+      const Vector3<S>& T1,
+      const Vector3<S>& T2,
+      const Vector3<S>& T3,
+      const Transform3<S>& tf,
+      Vector3<S>& P,
+      Vector3<S>& Q);
+
+};
+
+using TriangleDistancef = TriangleDistance<float>;
+using TriangleDistanced = TriangleDistance<double>;
+
+} // namespace detail
+} // namespace fcl
+
+#include "fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance-inl.h"
+
+#endif
diff --git a/include/fcl/narrowphase/detail/traversal/collision/bvh_collision_traversal_node.h b/include/fcl/narrowphase/detail/traversal/collision/bvh_collision_traversal_node.h
index 021a478..d147386 100644
--- a/include/fcl/narrowphase/detail/traversal/collision/bvh_collision_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/collision/bvh_collision_traversal_node.h
@@ -49,7 +49,7 @@ namespace detail
 
 /// @brief Traversal node for collision between BVH models
 template <typename BV>
-class FCL_EXPORT BVHCollisionTraversalNode
+class BVHCollisionTraversalNode
     : public CollisionTraversalNodeBase<typename BV::S>
 {
 public:
@@ -81,7 +81,7 @@ public:
 
   /// @brief BV culling test in one BVTT node
   bool BVTesting(int b1, int b2) const;
-  
+
   /// @brief The first BVH model
   const BVHModel<BV>* model1;
 
diff --git a/include/fcl/narrowphase/detail/traversal/collision/bvh_shape_collision_traversal_node.h b/include/fcl/narrowphase/detail/traversal/collision/bvh_shape_collision_traversal_node.h
index 9247d56..551223d 100644
--- a/include/fcl/narrowphase/detail/traversal/collision/bvh_shape_collision_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/collision/bvh_shape_collision_traversal_node.h
@@ -49,7 +49,7 @@ namespace detail
 
 /// @brief Traversal node for collision between BVH and shape
 template <typename BV, typename Shape>
-class FCL_EXPORT BVHShapeCollisionTraversalNode
+class BVHShapeCollisionTraversalNode
     : public CollisionTraversalNodeBase<typename BV::S>
 {
 public:
diff --git a/include/fcl/narrowphase/detail/traversal/collision/collision_traversal_node_base.h b/include/fcl/narrowphase/detail/traversal/collision/collision_traversal_node_base.h
index 6f6b10c..959d532 100644
--- a/include/fcl/narrowphase/detail/traversal/collision/collision_traversal_node_base.h
+++ b/include/fcl/narrowphase/detail/traversal/collision/collision_traversal_node_base.h
@@ -49,7 +49,7 @@ namespace detail
 
 /// @brief Node structure encoding the information required for collision traversal.
 template <typename S>
-class FCL_EXPORT CollisionTraversalNodeBase : public TraversalNodeBase<S>
+class CollisionTraversalNodeBase : public TraversalNodeBase<S>
 {
 public:
   CollisionTraversalNodeBase();
@@ -74,7 +74,7 @@ public:
   /// @brief collision result kept during the traversal iteration
   CollisionResult<S>* result;
 
-  /// @brief Whether stores statistics 
+  /// @brief Whether stores statistics
   bool enable_statistics;
 };
 
diff --git a/include/fcl/narrowphase/detail/traversal/collision/intersect-inl.h b/include/fcl/narrowphase/detail/traversal/collision/intersect-inl.h
index 4c9d606..ceea97f 100644
--- a/include/fcl/narrowphase/detail/traversal/collision/intersect-inl.h
+++ b/include/fcl/narrowphase/detail/traversal/collision/intersect-inl.h
@@ -1,1146 +1,1146 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#ifndef FCL_NARROWPHASE_DETAIL_INTERSECT_INL_H
-#define FCL_NARROWPHASE_DETAIL_INTERSECT_INL_H
-
-#include "fcl/narrowphase/detail/traversal/collision/intersect.h"
-
-namespace fcl
-{
-
-namespace detail
-{
-
-//==============================================================================
-extern template
-class FCL_EXPORT Intersect<double>;
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::isZero(S v)
-{
-  return (v < getNearZeroThreshold()) && (v > -getNearZeroThreshold());
-}
-
-//==============================================================================
-/// @brief data: only used for EE, return the intersect point
-template <typename S>
-bool Intersect<S>::solveCubicWithIntervalNewton(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                                             const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
-                                             S& l, S& r, bool bVF, S coeffs[], Vector3<S>* data)
-{
-  S v2[2]= {l*l,r*r};
-  S v[2]= {l,r};
-  S r_backup;
-
-  unsigned char min3, min2, min1, max3, max2, max1;
-
-  min3= *((unsigned char*)&coeffs[3]+7)>>7; max3=min3^1;
-  min2= *((unsigned char*)&coeffs[2]+7)>>7; max2=min2^1;
-  min1= *((unsigned char*)&coeffs[1]+7)>>7; max1=min1^1;
-
-  // bound the cubic
-
-  S minor = coeffs[3]*v2[min3]*v[min3]+coeffs[2]*v2[min2]+coeffs[1]*v[min1]+coeffs[0];
-  S major = coeffs[3]*v2[max3]*v[max3]+coeffs[2]*v2[max2]+coeffs[1]*v[max1]+coeffs[0];
-
-  if(major<0) return false;
-  if(minor>0) return false;
-
-  // starting here, the bounds have opposite values
-  S m = 0.5 * (r + l);
-
-  // bound the derivative
-  S dminor = 3.0*coeffs[3]*v2[min3]+2.0*coeffs[2]*v[min2]+coeffs[1];
-  S dmajor = 3.0*coeffs[3]*v2[max3]+2.0*coeffs[2]*v[max2]+coeffs[1];
-
-  if((dminor > 0)||(dmajor < 0)) // we can use Newton
-  {
-    S m2 = m*m;
-    S fm = coeffs[3]*m2*m+coeffs[2]*m2+coeffs[1]*m+coeffs[0];
-    S nl = m;
-    S nu = m;
-    if(fm>0)
-    {
-      nl-=(fm/dminor);
-      nu-=(fm/dmajor);
-    }
-    else
-    {
-      nu-=(fm/dminor);
-      nl-=(fm/dmajor);
-    }
-
-    //intersect with [l,r]
-
-    if(nl>r) return false;
-    if(nu<l) return false;
-    if(nl>l)
-    {
-      if(nu<r) { l=nl; r=nu; m=0.5*(l+r); }
-      else { l=nl; m=0.5*(l+r); }
-    }
-    else
-    {
-      if(nu<r) { r=nu; m=0.5*(l+r); }
-    }
-  }
-
-  // sufficient temporal resolution, check root validity
-  if((r-l)< getCcdResolution())
-  {
-    if(bVF)
-      return checkRootValidity_VF(a0, b0, c0, d0, va, vb, vc, vd, r);
-    else
-      return checkRootValidity_EE(a0, b0, c0, d0, va, vb, vc, vd, r, data);
-  }
-
-  r_backup = r, r = m;
-  if(solveCubicWithIntervalNewton(a0, b0, c0, d0, va, vb, vc, vd, l, r, bVF, coeffs, data))
-    return true;
-
-  l = m, r = r_backup;
-  return solveCubicWithIntervalNewton(a0, b0, c0, d0, va, vb, vc, vd, l, r, bVF, coeffs, data);
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::insideTriangle(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>&p)
-{
-  Vector3<S> ab = b - a;
-  Vector3<S> ac = c - a;
-  Vector3<S> n = ab.cross(ac);
-
-  Vector3<S> pa = a - p;
-  Vector3<S> pb = b - p;
-  Vector3<S> pc = c - p;
-
-  if((pb.cross(pc)).dot(n) < -getEpsilon()) return false;
-  if((pc.cross(pa)).dot(n) < -getEpsilon()) return false;
-  if((pa.cross(pb)).dot(n) < -getEpsilon()) return false;
-
-  return true;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::insideLineSegment(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& p)
-{
-  return (p - a).dot(p - b) <= 0;
-}
-
-//==============================================================================
-/// @brief Calculate the line segment papb that is the shortest route between
-/// two lines p1p2 and p3p4. Calculate also the values of mua and mub where
-///    pa = p1 + mua (p2 - p1)
-///    pb = p3 + mub (p4 - p3)
-/// Return FALSE if no solution exists.
-template <typename S>
-bool Intersect<S>::linelineIntersect(const Vector3<S>& p1, const Vector3<S>& p2, const Vector3<S>& p3, const Vector3<S>& p4,
-                                  Vector3<S>* pa, Vector3<S>* pb, S* mua, S* mub)
-{
-  Vector3<S> p31 = p1 - p3;
-  Vector3<S> p34 = p4 - p3;
-  if(fabs(p34[0]) < getEpsilon() && fabs(p34[1]) < getEpsilon() && fabs(p34[2]) < getEpsilon())
-    return false;
-
-  Vector3<S> p12 = p2 - p1;
-  if(fabs(p12[0]) < getEpsilon() && fabs(p12[1]) < getEpsilon() && fabs(p12[2]) < getEpsilon())
-    return false;
-
-  S d3134 = p31.dot(p34);
-  S d3412 = p34.dot(p12);
-  S d3112 = p31.dot(p12);
-  S d3434 = p34.dot(p34);
-  S d1212 = p12.dot(p12);
-
-  S denom = d1212 * d3434 - d3412 * d3412;
-  if(fabs(denom) < getEpsilon())
-    return false;
-  S numer = d3134 * d3412 - d3112 * d3434;
-
-  *mua = numer / denom;
-  if(*mua < 0 || *mua > 1)
-    return false;
-
-  *mub = (d3134 + d3412 * (*mua)) / d3434;
-  if(*mub < 0 || *mub > 1)
-    return false;
-
-  *pa = p1 + p12 * (*mua);
-  *pb = p3 + p34 * (*mub);
-  return true;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::checkRootValidity_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
-                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vp,
-                                     S t)
-{
-  return insideTriangle(a0 + va * t, b0 + vb * t, c0 + vc * t, p0 + vp * t);
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::checkRootValidity_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
-                                     S t, Vector3<S>* q_i)
-{
-  Vector3<S> a = a0 + va * t;
-  Vector3<S> b = b0 + vb * t;
-  Vector3<S> c = c0 + vc * t;
-  Vector3<S> d = d0 + vd * t;
-  Vector3<S> p1, p2;
-  S t_ab, t_cd;
-  if(linelineIntersect(a, b, c, d, &p1, &p2, &t_ab, &t_cd))
-  {
-    if(q_i) *q_i = p1;
-    return true;
-  }
-
-  return false;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::checkRootValidity_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
-                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp,
-                                     S t)
-{
-  return insideLineSegment(a0 + va * t, b0 + vb * t, p0 + vp * t);
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::solveSquare(S a, S b, S c,
-                            const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                            const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
-                            bool bVF,
-                            S* ret)
-{
-  S discriminant = b * b - 4 * a * c;
-  if(discriminant < 0)
-    return false;
-
-  S sqrt_dis = sqrt(discriminant);
-  S r1 = (-b + sqrt_dis) / (2 * a);
-  bool v1 = (r1 >= 0.0 && r1 <= 1.0) ? ((bVF) ? checkRootValidity_VF(a0, b0, c0, d0, va, vb, vc, vd, r1) : checkRootValidity_EE(a0, b0, c0, d0, va, vb, vc, vd, r1)) : false;
-
-  S r2 = (-b - sqrt_dis) / (2 * a);
-  bool v2 = (r2 >= 0.0 && r2 <= 1.0) ? ((bVF) ? checkRootValidity_VF(a0, b0, c0, d0, va, vb, vc, vd, r2) : checkRootValidity_EE(a0, b0, c0, d0, va, vb, vc, vd, r2)) : false;
-
-  if(v1 && v2)
-  {
-    *ret = (r1 > r2) ? r2 : r1;
-    return true;
-  }
-  if(v1)
-  {
-    *ret = r1;
-    return true;
-  }
-  if(v2)
-  {
-    *ret = r2;
-    return true;
-  }
-
-  return false;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::solveSquare(S a, S b, S c,
-                            const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
-                            const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp)
-{
-  if(isZero(a))
-  {
-    S t = -c/b;
-    return (t >= 0 && t <= 1) ? checkRootValidity_VE(a0, b0, p0, va, vb, vp, t) : false;
-  }
-
-  S discriminant = b*b-4*a*c;
-  if(discriminant < 0)
-    return false;
-
-  S sqrt_dis = sqrt(discriminant);
-
-  S r1 = (-b+sqrt_dis) / (2 * a);
-  bool v1 = (r1 >= 0.0 && r1 <= 1.0) ? checkRootValidity_VE(a0, b0, p0, va, vb, vp, r1) : false;
-  if(v1) return true;
-
-  S r2 = (-b-sqrt_dis) / (2 * a);
-  bool v2 = (r2 >= 0.0 && r2 <= 1.0) ? checkRootValidity_VE(a0, b0, p0, va, vb, vp, r2) : false;
-  return v2;
-}
-
-//==============================================================================
-/// @brief Compute the cubic coefficients for VF case
-/// See Paper "Interactive Continuous Collision Detection between Deformable Models using Connectivity-Based Culling", Equation 1.
-template <typename S>
-void Intersect<S>::computeCubicCoeff_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
-                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vp,
-                                     S* a, S* b, S* c, S* d)
-{
-  Vector3<S> vavb = vb - va;
-  Vector3<S> vavc = vc - va;
-  Vector3<S> vavp = vp - va;
-  Vector3<S> a0b0 = b0 - a0;
-  Vector3<S> a0c0 = c0 - a0;
-  Vector3<S> a0p0 = p0 - a0;
-
-  Vector3<S> vavb_cross_vavc = vavb.cross(vavc);
-  Vector3<S> vavb_cross_a0c0 = vavb.cross(a0c0);
-  Vector3<S> a0b0_cross_vavc = a0b0.cross(vavc);
-  Vector3<S> a0b0_cross_a0c0 = a0b0.cross(a0c0);
-
-  *a = vavp.dot(vavb_cross_vavc);
-  *b = a0p0.dot(vavb_cross_vavc) + vavp.dot(vavb_cross_a0c0 + a0b0_cross_vavc);
-  *c = vavp.dot(a0b0_cross_a0c0) + a0p0.dot(vavb_cross_a0c0 + a0b0_cross_vavc);
-  *d = a0p0.dot(a0b0_cross_a0c0);
-}
-
-//==============================================================================
-template <typename S>
-void Intersect<S>::computeCubicCoeff_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
-                                     S* a, S* b, S* c, S* d)
-{
-  Vector3<S> vavb = vb - va;
-  Vector3<S> vcvd = vd - vc;
-  Vector3<S> vavc = vc - va;
-  Vector3<S> c0d0 = d0 - c0;
-  Vector3<S> a0b0 = b0 - a0;
-  Vector3<S> a0c0 = c0 - a0;
-  Vector3<S> vavb_cross_vcvd = vavb.cross(vcvd);
-  Vector3<S> vavb_cross_c0d0 = vavb.cross(c0d0);
-  Vector3<S> a0b0_cross_vcvd = a0b0.cross(vcvd);
-  Vector3<S> a0b0_cross_c0d0 = a0b0.cross(c0d0);
-
-  *a = vavc.dot(vavb_cross_vcvd);
-  *b = a0c0.dot(vavb_cross_vcvd) + vavc.dot(vavb_cross_c0d0 + a0b0_cross_vcvd);
-  *c = vavc.dot(a0b0_cross_c0d0) + a0c0.dot(vavb_cross_c0d0 + a0b0_cross_vcvd);
-  *d = a0c0.dot(a0b0_cross_c0d0);
-}
-
-//==============================================================================
-template <typename S>
-void Intersect<S>::computeCubicCoeff_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
-                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp,
-                                     const Vector3<S>& L,
-                                     S* a, S* b, S* c)
-{
-  Vector3<S> vbva = va - vb;
-  Vector3<S> vbvp = vp - vb;
-  Vector3<S> b0a0 = a0 - b0;
-  Vector3<S> b0p0 = p0 - b0;
-
-  Vector3<S> L_cross_vbvp = L.cross(vbvp);
-  Vector3<S> L_cross_b0p0 = L.cross(b0p0);
-
-  *a = L_cross_vbvp.dot(vbva);
-  *b = L_cross_vbvp.dot(b0a0) + L_cross_b0p0.dot(vbva);
-  *c = L_cross_b0p0.dot(b0a0);
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::intersect_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
-                             const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& p1,
-                             S* collision_time, Vector3<S>* p_i, bool useNewton)
-{
-  *collision_time = 2.0;
-
-  Vector3<S> vp, va, vb, vc;
-  vp = p1 - p0;
-  va = a1 - a0;
-  vb = b1 - b0;
-  vc = c1 - c0;
-
-  S a, b, c, d;
-  computeCubicCoeff_VF(a0, b0, c0, p0, va, vb, vc, vp, &a, &b, &c, &d);
-
-  if(isZero(a) && isZero(b) && isZero(c) && isZero(d))
-  {
-    return false;
-  }
-
-
-  /// if(isZero(a))
-  /// {
-  ///   return solveSquare(b, c, d, a0, b0, c0, p0, va, vb, vc, vp, true, collision_time);
-  /// }
-
-  S coeffs[4];
-  coeffs[3] = a, coeffs[2] = b, coeffs[1] = c, coeffs[0] = d;
-
-  if(useNewton)
-  {
-    S l = 0;
-    S r = 1;
-
-    if(solveCubicWithIntervalNewton(a0, b0, c0, p0, va, vb, vc, vp, l, r, true, coeffs))
-    {
-      *collision_time = 0.5 * (l + r);
-    }
-  }
-  else
-  {
-    S roots[3];
-    int num = PolySolver<S>::solveCubic(coeffs, roots);
-    for(int i = 0; i < num; ++i)
-    {
-      S r = roots[i];
-      if(r < 0 || r > 1) continue;
-      if(checkRootValidity_VF(a0, b0, c0, p0, va, vb, vc, vp, r))
-      {
-        *collision_time = r;
-        break;
-      }
-    }
-  }
-
-  if(*collision_time > 1)
-  {
-    return false;
-  }
-
-  *p_i = vp * (*collision_time) + p0;
-  return true;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::intersect_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                             const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1,
-                             S* collision_time, Vector3<S>* p_i, bool useNewton)
-{
-  *collision_time = 2.0;
-
-  Vector3<S> va, vb, vc, vd;
-  va = a1 - a0;
-  vb = b1 - b0;
-  vc = c1 - c0;
-  vd = d1 - d0;
-
-  S a, b, c, d;
-  computeCubicCoeff_EE(a0, b0, c0, d0, va, vb, vc, vd, &a, &b, &c, &d);
-
-  if(isZero(a) && isZero(b) && isZero(c) && isZero(d))
-  {
-    return false;
-  }
-
-  /// if(isZero(a))
-  /// {
-  ///   return solveSquare(b, c, d, a0, b0, c0, d0, va, vb, vc, vd, collision_time, false);
-  /// }
-
-
-  S coeffs[4];
-  coeffs[3] = a, coeffs[2] = b, coeffs[1] = c, coeffs[0] = d;
-
-  if(useNewton)
-  {
-    S l = 0;
-    S r = 1;
-
-    if(solveCubicWithIntervalNewton(a0, b0, c0, d0, va, vb, vc, vd, l, r, false, coeffs, p_i))
-    {
-      *collision_time  = (l + r) * 0.5;
-    }
-  }
-  else
-  {
-    S roots[3];
-    int num = PolySolver<S>::solveCubic(coeffs, roots);
-    for(int i = 0; i < num; ++i)
-    {
-      S r = roots[i];
-      if(r < 0 || r > 1) continue;
-
-      if(checkRootValidity_EE(a0, b0, c0, d0, va, vb, vc, vd, r, p_i))
-      {
-        *collision_time = r;
-        break;
-      }
-    }
-  }
-
-  if(*collision_time > 1)
-  {
-    return false;
-  }
-
-  return true;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::intersect_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
-                             const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& p1,
-                             const Vector3<S>& L)
-{
-  Vector3<S> va, vb, vp;
-  va = a1 - a0;
-  vb = b1 - b0;
-  vp = p1 - p0;
-
-  S a, b, c;
-  computeCubicCoeff_VE(a0, b0, p0, va, vb, vp, L, &a, &b, &c);
-
-  if(isZero(a) && isZero(b) && isZero(c))
-    return true;
-
-  return solveSquare(a, b, c, a0, b0, p0, va, vb, vp);
-
-}
-
-//==============================================================================
-/// @brief Prefilter for intersection, works for both VF and EE
-template <typename S>
-bool Intersect<S>::intersectPreFiltering(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                                      const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1)
-{
-  Vector3<S> n0 = (b0 - a0).cross(c0 - a0);
-  Vector3<S> n1 = (b1 - a1).cross(c1 - a1);
-  Vector3<S> a0a1 = a1 - a0;
-  Vector3<S> b0b1 = b1 - b0;
-  Vector3<S> c0c1 = c1 - c0;
-  Vector3<S> delta = (b0b1 - a0a1).cross(c0c1 - a0a1);
-  Vector3<S> nx = (n0 + n1 - delta) * 0.5;
-
-  Vector3<S> a0d0 = d0 - a0;
-  Vector3<S> a1d1 = d1 - a1;
-
-  S A = n0.dot(a0d0);
-  S B = n1.dot(a1d1);
-  S C = nx.dot(a0d0);
-  S D = nx.dot(a1d1);
-  S E = n1.dot(a0d0);
-  S F = n0.dot(a1d1);
-
-  if(A > 0 && B > 0 && (2*C +F) > 0 && (2*D+E) > 0)
-    return false;
-  if(A < 0 && B < 0 && (2*C +F) < 0 && (2*D+E) < 0)
-    return false;
-
-  return true;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::intersect_VF_filtered(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
-                                      const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& p1,
-                                      S* collision_time, Vector3<S>* p_i, bool useNewton)
-{
-  if(intersectPreFiltering(a0, b0, c0, p0, a1, b1, c1, p1))
-  {
-    return intersect_VF(a0, b0, c0, p0, a1, b1, c1, p1, collision_time, p_i, useNewton);
-  }
-  else
-    return false;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::intersect_EE_filtered(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                                      const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1,
-                                      S* collision_time, Vector3<S>* p_i, bool useNewton)
-{
-  if(intersectPreFiltering(a0, b0, c0, d0, a1, b1, c1, d1))
-  {
-    return intersect_EE(a0, b0, c0, d0, a1, b1, c1, d1, collision_time, p_i, useNewton);
-  }
-  else
-    return false;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::intersect_Triangle(
-    const Vector3<S>& P1,
-    const Vector3<S>& P2,
-    const Vector3<S>& P3,
-    const Vector3<S>& Q1,
-    const Vector3<S>& Q2,
-    const Vector3<S>& Q3,
-    const Matrix3<S>& R,
-    const Vector3<S>& T,
-    Vector3<S>* contact_points,
-    unsigned int* num_contact_points,
-    S* penetration_depth,
-    Vector3<S>* normal)
-{
-  Vector3<S> Q1_ = R * Q1 + T;
-  Vector3<S> Q2_ = R * Q2 + T;
-  Vector3<S> Q3_ = R * Q3 + T;
-
-  return intersect_Triangle(P1, P2, P3, Q1_, Q2_, Q3_, contact_points, num_contact_points, penetration_depth, normal);
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::intersect_Triangle(
-    const Vector3<S>& P1,
-    const Vector3<S>& P2,
-    const Vector3<S>& P3,
-    const Vector3<S>& Q1,
-    const Vector3<S>& Q2,
-    const Vector3<S>& Q3,
-    const Transform3<S>& tf,
-    Vector3<S>* contact_points,
-    unsigned int* num_contact_points,
-    S* penetration_depth,
-    Vector3<S>* normal)
-{
-  Vector3<S> Q1_ = tf * Q1;
-  Vector3<S> Q2_ = tf * Q2;
-  Vector3<S> Q3_ = tf * Q3;
-
-  return intersect_Triangle(P1, P2, P3, Q1_, Q2_, Q3_, contact_points, num_contact_points, penetration_depth, normal);
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::intersect_Triangle_ODE_style(
-    const Vector3<S>& P1, const Vector3<S>& P2, const Vector3<S>& P3,
-    const Vector3<S>& Q1, const Vector3<S>& Q2, const Vector3<S>& Q3,
-    Vector3<S>* contact_points,
-    unsigned int* num_contact_points,
-    S* penetration_depth,
-    Vector3<S>* normal)
-{
-  Vector3<S> n1;
-  S t1;
-  bool b1 = buildTrianglePlane(P1, P2, P3, &n1, &t1);
-  if(!b1) return false;
-
-  Vector3<S> n2;
-  S t2;
-  bool b2 = buildTrianglePlane(Q1, Q2, Q3, &n2, &t2);
-  if(!b2) return false;
-
-  if(sameSideOfPlane(P1, P2, P3, n2, t2))
-    return false;
-
-  if(sameSideOfPlane(Q1, Q2, Q3, n1, t1))
-    return false;
-
-  Vector3<S> clipped_points1[getMaxTriangleClips()];
-  unsigned int num_clipped_points1 = 0;
-  Vector3<S> clipped_points2[getMaxTriangleClips()];
-  unsigned int num_clipped_points2 = 0;
-
-  Vector3<S> deepest_points1[getMaxTriangleClips()];
-  unsigned int num_deepest_points1 = 0;
-  Vector3<S> deepest_points2[getMaxTriangleClips()];
-  unsigned int num_deepest_points2 = 0;
-  S penetration_depth1 = -1, penetration_depth2 = -1;
-
-  clipTriangleByTriangleAndEdgePlanes(Q1, Q2, Q3, P1, P2, P3, n1, t1, clipped_points2, &num_clipped_points2);
-
-  if(num_clipped_points2 == 0)
-    return false;
-
-  computeDeepestPoints(clipped_points2, num_clipped_points2, n1, t1, &penetration_depth2, deepest_points2, &num_deepest_points2);
-  if(num_deepest_points2 == 0)
-    return false;
-
-  clipTriangleByTriangleAndEdgePlanes(P1, P2, P3, Q1, Q2, Q3, n2, t2, clipped_points1, &num_clipped_points1);
-  if(num_clipped_points1 == 0)
-    return false;
-
-  computeDeepestPoints(clipped_points1, num_clipped_points1, n2, t2, &penetration_depth1, deepest_points1, &num_deepest_points1);
-  if(num_deepest_points1 == 0)
-    return false;
-
-
-  /// Return contact information
-  if(contact_points && num_contact_points && penetration_depth && normal)
-  {
-    if(penetration_depth1 > penetration_depth2)
-    {
-      *num_contact_points = num_deepest_points2;
-      for(unsigned int i = 0; i < num_deepest_points2; ++i)
-      {
-        contact_points[i] = deepest_points2[i];
-      }
-
-      *normal = n1;
-      *penetration_depth = penetration_depth2;
-    }
-    else
-    {
-      *num_contact_points = num_deepest_points1;
-      for(unsigned int i = 0; i < num_deepest_points1; ++i)
-      {
-        contact_points[i] = deepest_points1[i];
-      }
-
-      *normal = -n2;
-      *penetration_depth = penetration_depth1;
-    }
-  }
-
-  return true;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::intersect_Triangle(
-    const Vector3<S>& P1, const Vector3<S>& P2, const Vector3<S>& P3,
-    const Vector3<S>& Q1, const Vector3<S>& Q2, const Vector3<S>& Q3,
-    Vector3<S>* contact_points,
-    unsigned int* num_contact_points,
-    S* penetration_depth,
-    Vector3<S>* normal)
-{
-  Vector3<S> p1 = P1 - P1;
-  Vector3<S> p2 = P2 - P1;
-  Vector3<S> p3 = P3 - P1;
-  Vector3<S> q1 = Q1 - P1;
-  Vector3<S> q2 = Q2 - P1;
-  Vector3<S> q3 = Q3 - P1;
-
-  Vector3<S> e1 = p2 - p1;
-  Vector3<S> e2 = p3 - p2;
-  Vector3<S> n1 = e1.cross(e2);
-  if (!project6(n1, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> f1 = q2 - q1;
-  Vector3<S> f2 = q3 - q2;
-  Vector3<S> m1 = f1.cross(f2);
-  if (!project6(m1, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> ef11 = e1.cross(f1);
-  if (!project6(ef11, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> ef12 = e1.cross(f2);
-  if (!project6(ef12, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> f3 = q1 - q3;
-  Vector3<S> ef13 = e1.cross(f3);
-  if (!project6(ef13, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> ef21 = e2.cross(f1);
-  if (!project6(ef21, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> ef22 = e2.cross(f2);
-  if (!project6(ef22, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> ef23 = e2.cross(f3);
-  if (!project6(ef23, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> e3 = p1 - p3;
-  Vector3<S> ef31 = e3.cross(f1);
-  if (!project6(ef31, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> ef32 = e3.cross(f2);
-  if (!project6(ef32, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> ef33 = e3.cross(f3);
-  if (!project6(ef33, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> g1 = e1.cross(n1);
-  if (!project6(g1, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> g2 = e2.cross(n1);
-  if (!project6(g2, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> g3 = e3.cross(n1);
-  if (!project6(g3, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> h1 = f1.cross(m1);
-  if (!project6(h1, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> h2 = f2.cross(m1);
-  if (!project6(h2, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> h3 = f3.cross(m1);
-  if (!project6(h3, p1, p2, p3, q1, q2, q3)) return false;
-
-  if(contact_points && num_contact_points && penetration_depth && normal)
-  {
-    Vector3<S> n1, n2;
-    S t1, t2;
-    buildTrianglePlane(P1, P2, P3, &n1, &t1);
-    buildTrianglePlane(Q1, Q2, Q3, &n2, &t2);
-
-    Vector3<S> deepest_points1[3];
-    unsigned int num_deepest_points1 = 0;
-    Vector3<S> deepest_points2[3];
-    unsigned int num_deepest_points2 = 0;
-    S penetration_depth1, penetration_depth2;
-
-    Vector3<S> P[3] = {P1, P2, P3};
-    Vector3<S> Q[3] = {Q1, Q2, Q3};
-
-    computeDeepestPoints(Q, 3, n1, t1, &penetration_depth2, deepest_points2, &num_deepest_points2);
-    computeDeepestPoints(P, 3, n2, t2, &penetration_depth1, deepest_points1, &num_deepest_points1);
-
-
-    if(penetration_depth1 > penetration_depth2)
-    {
-      *num_contact_points = std::min(num_deepest_points2, (unsigned int)2);
-      for(unsigned int i = 0; i < *num_contact_points; ++i)
-      {
-        contact_points[i] = deepest_points2[i];
-      }
-
-      *normal = n1;
-      *penetration_depth = penetration_depth2;
-    }
-    else
-    {
-      *num_contact_points = std::min(num_deepest_points1, (unsigned int)2);
-      for(unsigned int i = 0; i < *num_contact_points; ++i)
-      {
-        contact_points[i] = deepest_points1[i];
-      }
-
-      *normal = -n2;
-      *penetration_depth = penetration_depth1;
-    }
-  }
-
-  return true;
-}
-
-//==============================================================================
-template <typename S>
-void Intersect<S>::computeDeepestPoints(Vector3<S>* clipped_points, unsigned int num_clipped_points, const Vector3<S>& n, S t, S* penetration_depth, Vector3<S>* deepest_points, unsigned int* num_deepest_points)
-{
-  *num_deepest_points = 0;
-  S max_depth = -std::numeric_limits<S>::max();
-  unsigned int num_deepest_points_ = 0;
-  unsigned int num_neg = 0;
-  unsigned int num_pos = 0;
-  unsigned int num_zero = 0;
-
-  for(unsigned int i = 0; i < num_clipped_points; ++i)
-  {
-    S dist = -distanceToPlane(n, t, clipped_points[i]);
-    if(dist > getEpsilon()) num_pos++;
-    else if(dist < -getEpsilon()) num_neg++;
-    else num_zero++;
-    if(dist > max_depth)
-    {
-      max_depth = dist;
-      num_deepest_points_ = 1;
-      deepest_points[num_deepest_points_ - 1] = clipped_points[i];
-    }
-    else if(dist + 1e-6 >= max_depth)
-    {
-      num_deepest_points_++;
-      deepest_points[num_deepest_points_ - 1] = clipped_points[i];
-    }
-  }
-
-  if(max_depth < -getEpsilon())
-    num_deepest_points_ = 0;
-
-  if(num_zero == 0 && ((num_neg == 0) || (num_pos == 0)))
-    num_deepest_points_ = 0;
-
-  *penetration_depth = max_depth;
-  *num_deepest_points = num_deepest_points_;
-}
-
-//==============================================================================
-template <typename S>
-void Intersect<S>::clipTriangleByTriangleAndEdgePlanes(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3,
-                                                    const Vector3<S>& t1, const Vector3<S>& t2, const Vector3<S>& t3,
-                                                    const Vector3<S>& tn, S to,
-                                                    Vector3<S> clipped_points[], unsigned int* num_clipped_points,
-                                                    bool clip_triangle)
-{
-  *num_clipped_points = 0;
-  Vector3<S> temp_clip[getMaxTriangleClips()];
-  Vector3<S> temp_clip2[getMaxTriangleClips()];
-  unsigned int num_temp_clip = 0;
-  unsigned int num_temp_clip2 = 0;
-  Vector3<S> v[3] = {v1, v2, v3};
-
-  Vector3<S> plane_n;
-  S plane_dist;
-
-  if(buildEdgePlane(t1, t2, tn, &plane_n, &plane_dist))
-  {
-    clipPolygonByPlane(v, 3, plane_n, plane_dist, temp_clip, &num_temp_clip);
-    if(num_temp_clip > 0)
-    {
-      if(buildEdgePlane(t2, t3, tn, &plane_n, &plane_dist))
-      {
-        clipPolygonByPlane(temp_clip, num_temp_clip, plane_n, plane_dist, temp_clip2, &num_temp_clip2);
-        if(num_temp_clip2 > 0)
-        {
-          if(buildEdgePlane(t3, t1, tn, &plane_n, &plane_dist))
-          {
-            if(clip_triangle)
-            {
-              num_temp_clip = 0;
-              clipPolygonByPlane(temp_clip2, num_temp_clip2, plane_n, plane_dist, temp_clip, &num_temp_clip);
-              if(num_temp_clip > 0)
-              {
-                clipPolygonByPlane(temp_clip, num_temp_clip, tn, to, clipped_points, num_clipped_points);
-              }
-            }
-            else
-            {
-              clipPolygonByPlane(temp_clip2, num_temp_clip2, plane_n, plane_dist, clipped_points, num_clipped_points);
-            }
-          }
-        }
-      }
-    }
-  }
-}
-
-//==============================================================================
-template <typename S>
-void Intersect<S>::clipPolygonByPlane(Vector3<S>* polygon_points, unsigned int num_polygon_points, const Vector3<S>& n, S t, Vector3<S> clipped_points[], unsigned int* num_clipped_points)
-{
-  *num_clipped_points = 0;
-
-  unsigned int num_clipped_points_ = 0;
-  unsigned int vi;
-  unsigned int prev_classify = 2;
-  unsigned int classify;
-  for(unsigned int i = 0; i <= num_polygon_points; ++i)
-  {
-    vi = (i % num_polygon_points);
-    S d = distanceToPlane(n, t, polygon_points[i]);
-    classify = ((d > getEpsilon()) ? 1 : 0);
-    if(classify == 0)
-    {
-      if(prev_classify == 1)
-      {
-        if(num_clipped_points_ < getMaxTriangleClips())
-        {
-          Vector3<S> tmp;
-          clipSegmentByPlane(polygon_points[i - 1], polygon_points[vi], n, t, &tmp);
-          if(num_clipped_points_ > 0)
-          {
-            if((tmp - clipped_points[num_clipped_points_ - 1]).squaredNorm() > getEpsilon())
-            {
-              clipped_points[num_clipped_points_] = tmp;
-              num_clipped_points_++;
-            }
-          }
-          else
-          {
-            clipped_points[num_clipped_points_] = tmp;
-            num_clipped_points_++;
-          }
-        }
-      }
-
-      if(num_clipped_points_ < getMaxTriangleClips() && i < num_polygon_points)
-      {
-        clipped_points[num_clipped_points_] = polygon_points[vi];
-        num_clipped_points_++;
-      }
-    }
-    else
-    {
-      if(prev_classify == 0)
-      {
-        if(num_clipped_points_ < getMaxTriangleClips())
-        {
-          Vector3<S> tmp;
-          clipSegmentByPlane(polygon_points[i - 1], polygon_points[vi], n, t, &tmp);
-          if(num_clipped_points_ > 0)
-          {
-            if((tmp - clipped_points[num_clipped_points_ - 1]).squaredNorm() > getEpsilon())
-            {
-              clipped_points[num_clipped_points_] = tmp;
-              num_clipped_points_++;
-            }
-          }
-          else
-          {
-            clipped_points[num_clipped_points_] = tmp;
-            num_clipped_points_++;
-          }
-        }
-      }
-    }
-
-    prev_classify = classify;
-  }
-
-  if(num_clipped_points_ > 2)
-  {
-    if((clipped_points[0] - clipped_points[num_clipped_points_ - 1]).squaredNorm() < getEpsilon())
-    {
-      num_clipped_points_--;
-    }
-  }
-
-  *num_clipped_points = num_clipped_points_;
-}
-
-//==============================================================================
-template <typename S>
-void Intersect<S>::clipSegmentByPlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& n, S t, Vector3<S>* clipped_point)
-{
-  S dist1 = distanceToPlane(n, t, v1);
-  Vector3<S> tmp = v2 - v1;
-  S dist2 = tmp.dot(n);
-  *clipped_point = tmp * (-dist1 / dist2) + v1;
-}
-
-//==============================================================================
-template <typename S>
-S Intersect<S>::distanceToPlane(const Vector3<S>& n, S t, const Vector3<S>& v)
-{
-  return n.dot(v) - t;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::buildTrianglePlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3, Vector3<S>* n, S* t)
-{
-  Vector3<S> n_ = (v2 - v1).cross(v3 - v1);
-  bool can_normalize = false;
-  normalize(n_, &can_normalize);
-  if(can_normalize)
-  {
-    *n = n_;
-    *t = n_.dot(v1);
-    return true;
-  }
-
-  return false;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::buildEdgePlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& tn, Vector3<S>* n, S* t)
-{
-  Vector3<S> n_ = (v2 - v1).cross(tn);
-  bool can_normalize = false;
-  normalize(n_, &can_normalize);
-  if(can_normalize)
-  {
-    *n = n_;
-    *t = n_.dot(v1);
-    return true;
-  }
-
-  return false;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::sameSideOfPlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3, const Vector3<S>& n, S t)
-{
-  S dist1 = distanceToPlane(n, t, v1);
-  S dist2 = dist1 * distanceToPlane(n, t, v2);
-  S dist3 = dist1 * distanceToPlane(n, t, v3);
-  if((dist2 > 0) && (dist3 > 0))
-    return true;
-  return false;
-}
-
-//==============================================================================
-template <typename S>
-int Intersect<S>::project6(const Vector3<S>& ax,
-                        const Vector3<S>& p1, const Vector3<S>& p2, const Vector3<S>& p3,
-                        const Vector3<S>& q1, const Vector3<S>& q2, const Vector3<S>& q3)
-{
-  S P1 = ax.dot(p1);
-  S P2 = ax.dot(p2);
-  S P3 = ax.dot(p3);
-  S Q1 = ax.dot(q1);
-  S Q2 = ax.dot(q2);
-  S Q3 = ax.dot(q3);
-
-  S mn1 = std::min(P1, std::min(P2, P3));
-  S mx2 = std::max(Q1, std::max(Q2, Q3));
-  if(mn1 > mx2) return 0;
-
-  S mx1 = std::max(P1, std::max(P2, P3));
-  S mn2 = std::min(Q1, std::min(Q2, Q3));
-
-  if(mn2 > mx1) return 0;
-  return 1;
-}
-
-//==============================================================================
-template <typename S>
-S Intersect<S>::gaussianCDF(S x)
-{
-  return 0.5 * std::erfc(-x / sqrt(2.0));
-}
-
-//==============================================================================
-template <typename S>
-constexpr S Intersect<S>::getEpsilon()
-{
-  return 1e-5;
-}
-
-//==============================================================================
-template <typename S>
-constexpr S Intersect<S>::getNearZeroThreshold()
-{
-  return 1e-7;
-}
-
-//==============================================================================
-template <typename S>
-constexpr S Intersect<S>::getCcdResolution()
-{
-  return 1e-7;
-}
-
-//==============================================================================
-template <typename S>
-constexpr unsigned int Intersect<S>::getMaxTriangleClips()
-{
-  return 8;
-}
-
-} // namespace detail
-} // namespace fcl
-
-#endif
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#ifndef FCL_NARROWPHASE_DETAIL_INTERSECT_INL_H
+#define FCL_NARROWPHASE_DETAIL_INTERSECT_INL_H
+
+#include "fcl/narrowphase/detail/traversal/collision/intersect.h"
+
+namespace fcl
+{
+
+namespace detail
+{
+
+//==============================================================================
+extern template
+class FCL_EXPORT Intersect<double>;
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::isZero(S v)
+{
+  return (v < getNearZeroThreshold()) && (v > -getNearZeroThreshold());
+}
+
+//==============================================================================
+/// @brief data: only used for EE, return the intersect point
+template <typename S>
+bool Intersect<S>::solveCubicWithIntervalNewton(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                                             const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
+                                             S& l, S& r, bool bVF, S coeffs[], Vector3<S>* data)
+{
+  S v2[2]= {l*l,r*r};
+  S v[2]= {l,r};
+  S r_backup;
+
+  unsigned char min3, min2, min1, max3, max2, max1;
+
+  min3= *((unsigned char*)&coeffs[3]+7)>>7; max3=min3^1;
+  min2= *((unsigned char*)&coeffs[2]+7)>>7; max2=min2^1;
+  min1= *((unsigned char*)&coeffs[1]+7)>>7; max1=min1^1;
+
+  // bound the cubic
+
+  S minor = coeffs[3]*v2[min3]*v[min3]+coeffs[2]*v2[min2]+coeffs[1]*v[min1]+coeffs[0];
+  S major = coeffs[3]*v2[max3]*v[max3]+coeffs[2]*v2[max2]+coeffs[1]*v[max1]+coeffs[0];
+
+  if(major<0) return false;
+  if(minor>0) return false;
+
+  // starting here, the bounds have opposite values
+  S m = 0.5 * (r + l);
+
+  // bound the derivative
+  S dminor = 3.0*coeffs[3]*v2[min3]+2.0*coeffs[2]*v[min2]+coeffs[1];
+  S dmajor = 3.0*coeffs[3]*v2[max3]+2.0*coeffs[2]*v[max2]+coeffs[1];
+
+  if((dminor > 0)||(dmajor < 0)) // we can use Newton
+  {
+    S m2 = m*m;
+    S fm = coeffs[3]*m2*m+coeffs[2]*m2+coeffs[1]*m+coeffs[0];
+    S nl = m;
+    S nu = m;
+    if(fm>0)
+    {
+      nl-=(fm/dminor);
+      nu-=(fm/dmajor);
+    }
+    else
+    {
+      nu-=(fm/dminor);
+      nl-=(fm/dmajor);
+    }
+
+    //intersect with [l,r]
+
+    if(nl>r) return false;
+    if(nu<l) return false;
+    if(nl>l)
+    {
+      if(nu<r) { l=nl; r=nu; m=0.5*(l+r); }
+      else { l=nl; m=0.5*(l+r); }
+    }
+    else
+    {
+      if(nu<r) { r=nu; m=0.5*(l+r); }
+    }
+  }
+
+  // sufficient temporal resolution, check root validity
+  if((r-l)< getCcdResolution())
+  {
+    if(bVF)
+      return checkRootValidity_VF(a0, b0, c0, d0, va, vb, vc, vd, r);
+    else
+      return checkRootValidity_EE(a0, b0, c0, d0, va, vb, vc, vd, r, data);
+  }
+
+  r_backup = r, r = m;
+  if(solveCubicWithIntervalNewton(a0, b0, c0, d0, va, vb, vc, vd, l, r, bVF, coeffs, data))
+    return true;
+
+  l = m, r = r_backup;
+  return solveCubicWithIntervalNewton(a0, b0, c0, d0, va, vb, vc, vd, l, r, bVF, coeffs, data);
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::insideTriangle(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>&p)
+{
+  Vector3<S> ab = b - a;
+  Vector3<S> ac = c - a;
+  Vector3<S> n = ab.cross(ac);
+
+  Vector3<S> pa = a - p;
+  Vector3<S> pb = b - p;
+  Vector3<S> pc = c - p;
+
+  if((pb.cross(pc)).dot(n) < -getEpsilon()) return false;
+  if((pc.cross(pa)).dot(n) < -getEpsilon()) return false;
+  if((pa.cross(pb)).dot(n) < -getEpsilon()) return false;
+
+  return true;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::insideLineSegment(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& p)
+{
+  return (p - a).dot(p - b) <= 0;
+}
+
+//==============================================================================
+/// @brief Calculate the line segment papb that is the shortest route between
+/// two lines p1p2 and p3p4. Calculate also the values of mua and mub where
+///    pa = p1 + mua (p2 - p1)
+///    pb = p3 + mub (p4 - p3)
+/// Return FALSE if no solution exists.
+template <typename S>
+bool Intersect<S>::linelineIntersect(const Vector3<S>& p1, const Vector3<S>& p2, const Vector3<S>& p3, const Vector3<S>& p4,
+                                  Vector3<S>* pa, Vector3<S>* pb, S* mua, S* mub)
+{
+  Vector3<S> p31 = p1 - p3;
+  Vector3<S> p34 = p4 - p3;
+  if(fabs(p34[0]) < getEpsilon() && fabs(p34[1]) < getEpsilon() && fabs(p34[2]) < getEpsilon())
+    return false;
+
+  Vector3<S> p12 = p2 - p1;
+  if(fabs(p12[0]) < getEpsilon() && fabs(p12[1]) < getEpsilon() && fabs(p12[2]) < getEpsilon())
+    return false;
+
+  S d3134 = p31.dot(p34);
+  S d3412 = p34.dot(p12);
+  S d3112 = p31.dot(p12);
+  S d3434 = p34.dot(p34);
+  S d1212 = p12.dot(p12);
+
+  S denom = d1212 * d3434 - d3412 * d3412;
+  if(fabs(denom) < getEpsilon())
+    return false;
+  S numer = d3134 * d3412 - d3112 * d3434;
+
+  *mua = numer / denom;
+  if(*mua < 0 || *mua > 1)
+    return false;
+
+  *mub = (d3134 + d3412 * (*mua)) / d3434;
+  if(*mub < 0 || *mub > 1)
+    return false;
+
+  *pa = p1 + p12 * (*mua);
+  *pb = p3 + p34 * (*mub);
+  return true;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::checkRootValidity_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
+                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vp,
+                                     S t)
+{
+  return insideTriangle(a0 + va * t, b0 + vb * t, c0 + vc * t, p0 + vp * t);
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::checkRootValidity_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
+                                     S t, Vector3<S>* q_i)
+{
+  Vector3<S> a = a0 + va * t;
+  Vector3<S> b = b0 + vb * t;
+  Vector3<S> c = c0 + vc * t;
+  Vector3<S> d = d0 + vd * t;
+  Vector3<S> p1, p2;
+  S t_ab, t_cd;
+  if(linelineIntersect(a, b, c, d, &p1, &p2, &t_ab, &t_cd))
+  {
+    if(q_i) *q_i = p1;
+    return true;
+  }
+
+  return false;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::checkRootValidity_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
+                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp,
+                                     S t)
+{
+  return insideLineSegment(a0 + va * t, b0 + vb * t, p0 + vp * t);
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::solveSquare(S a, S b, S c,
+                            const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                            const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
+                            bool bVF,
+                            S* ret)
+{
+  S discriminant = b * b - 4 * a * c;
+  if(discriminant < 0)
+    return false;
+
+  S sqrt_dis = sqrt(discriminant);
+  S r1 = (-b + sqrt_dis) / (2 * a);
+  bool v1 = (r1 >= 0.0 && r1 <= 1.0) ? ((bVF) ? checkRootValidity_VF(a0, b0, c0, d0, va, vb, vc, vd, r1) : checkRootValidity_EE(a0, b0, c0, d0, va, vb, vc, vd, r1)) : false;
+
+  S r2 = (-b - sqrt_dis) / (2 * a);
+  bool v2 = (r2 >= 0.0 && r2 <= 1.0) ? ((bVF) ? checkRootValidity_VF(a0, b0, c0, d0, va, vb, vc, vd, r2) : checkRootValidity_EE(a0, b0, c0, d0, va, vb, vc, vd, r2)) : false;
+
+  if(v1 && v2)
+  {
+    *ret = (r1 > r2) ? r2 : r1;
+    return true;
+  }
+  if(v1)
+  {
+    *ret = r1;
+    return true;
+  }
+  if(v2)
+  {
+    *ret = r2;
+    return true;
+  }
+
+  return false;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::solveSquare(S a, S b, S c,
+                            const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
+                            const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp)
+{
+  if(isZero(a))
+  {
+    S t = -c/b;
+    return (t >= 0 && t <= 1) ? checkRootValidity_VE(a0, b0, p0, va, vb, vp, t) : false;
+  }
+
+  S discriminant = b*b-4*a*c;
+  if(discriminant < 0)
+    return false;
+
+  S sqrt_dis = sqrt(discriminant);
+
+  S r1 = (-b+sqrt_dis) / (2 * a);
+  bool v1 = (r1 >= 0.0 && r1 <= 1.0) ? checkRootValidity_VE(a0, b0, p0, va, vb, vp, r1) : false;
+  if(v1) return true;
+
+  S r2 = (-b-sqrt_dis) / (2 * a);
+  bool v2 = (r2 >= 0.0 && r2 <= 1.0) ? checkRootValidity_VE(a0, b0, p0, va, vb, vp, r2) : false;
+  return v2;
+}
+
+//==============================================================================
+/// @brief Compute the cubic coefficients for VF case
+/// See Paper "Interactive Continuous Collision Detection between Deformable Models using Connectivity-Based Culling", Equation 1.
+template <typename S>
+void Intersect<S>::computeCubicCoeff_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
+                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vp,
+                                     S* a, S* b, S* c, S* d)
+{
+  Vector3<S> vavb = vb - va;
+  Vector3<S> vavc = vc - va;
+  Vector3<S> vavp = vp - va;
+  Vector3<S> a0b0 = b0 - a0;
+  Vector3<S> a0c0 = c0 - a0;
+  Vector3<S> a0p0 = p0 - a0;
+
+  Vector3<S> vavb_cross_vavc = vavb.cross(vavc);
+  Vector3<S> vavb_cross_a0c0 = vavb.cross(a0c0);
+  Vector3<S> a0b0_cross_vavc = a0b0.cross(vavc);
+  Vector3<S> a0b0_cross_a0c0 = a0b0.cross(a0c0);
+
+  *a = vavp.dot(vavb_cross_vavc);
+  *b = a0p0.dot(vavb_cross_vavc) + vavp.dot(vavb_cross_a0c0 + a0b0_cross_vavc);
+  *c = vavp.dot(a0b0_cross_a0c0) + a0p0.dot(vavb_cross_a0c0 + a0b0_cross_vavc);
+  *d = a0p0.dot(a0b0_cross_a0c0);
+}
+
+//==============================================================================
+template <typename S>
+void Intersect<S>::computeCubicCoeff_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
+                                     S* a, S* b, S* c, S* d)
+{
+  Vector3<S> vavb = vb - va;
+  Vector3<S> vcvd = vd - vc;
+  Vector3<S> vavc = vc - va;
+  Vector3<S> c0d0 = d0 - c0;
+  Vector3<S> a0b0 = b0 - a0;
+  Vector3<S> a0c0 = c0 - a0;
+  Vector3<S> vavb_cross_vcvd = vavb.cross(vcvd);
+  Vector3<S> vavb_cross_c0d0 = vavb.cross(c0d0);
+  Vector3<S> a0b0_cross_vcvd = a0b0.cross(vcvd);
+  Vector3<S> a0b0_cross_c0d0 = a0b0.cross(c0d0);
+
+  *a = vavc.dot(vavb_cross_vcvd);
+  *b = a0c0.dot(vavb_cross_vcvd) + vavc.dot(vavb_cross_c0d0 + a0b0_cross_vcvd);
+  *c = vavc.dot(a0b0_cross_c0d0) + a0c0.dot(vavb_cross_c0d0 + a0b0_cross_vcvd);
+  *d = a0c0.dot(a0b0_cross_c0d0);
+}
+
+//==============================================================================
+template <typename S>
+void Intersect<S>::computeCubicCoeff_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
+                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp,
+                                     const Vector3<S>& L,
+                                     S* a, S* b, S* c)
+{
+  Vector3<S> vbva = va - vb;
+  Vector3<S> vbvp = vp - vb;
+  Vector3<S> b0a0 = a0 - b0;
+  Vector3<S> b0p0 = p0 - b0;
+
+  Vector3<S> L_cross_vbvp = L.cross(vbvp);
+  Vector3<S> L_cross_b0p0 = L.cross(b0p0);
+
+  *a = L_cross_vbvp.dot(vbva);
+  *b = L_cross_vbvp.dot(b0a0) + L_cross_b0p0.dot(vbva);
+  *c = L_cross_b0p0.dot(b0a0);
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::intersect_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
+                             const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& p1,
+                             S* collision_time, Vector3<S>* p_i, bool useNewton)
+{
+  *collision_time = 2.0;
+
+  Vector3<S> vp, va, vb, vc;
+  vp = p1 - p0;
+  va = a1 - a0;
+  vb = b1 - b0;
+  vc = c1 - c0;
+
+  S a, b, c, d;
+  computeCubicCoeff_VF(a0, b0, c0, p0, va, vb, vc, vp, &a, &b, &c, &d);
+
+  if(isZero(a) && isZero(b) && isZero(c) && isZero(d))
+  {
+    return false;
+  }
+
+
+  /// if(isZero(a))
+  /// {
+  ///   return solveSquare(b, c, d, a0, b0, c0, p0, va, vb, vc, vp, true, collision_time);
+  /// }
+
+  S coeffs[4];
+  coeffs[3] = a, coeffs[2] = b, coeffs[1] = c, coeffs[0] = d;
+
+  if(useNewton)
+  {
+    S l = 0;
+    S r = 1;
+
+    if(solveCubicWithIntervalNewton(a0, b0, c0, p0, va, vb, vc, vp, l, r, true, coeffs))
+    {
+      *collision_time = 0.5 * (l + r);
+    }
+  }
+  else
+  {
+    S roots[3];
+    int num = PolySolver<S>::solveCubic(coeffs, roots);
+    for(int i = 0; i < num; ++i)
+    {
+      S r = roots[i];
+      if(r < 0 || r > 1) continue;
+      if(checkRootValidity_VF(a0, b0, c0, p0, va, vb, vc, vp, r))
+      {
+        *collision_time = r;
+        break;
+      }
+    }
+  }
+
+  if(*collision_time > 1)
+  {
+    return false;
+  }
+
+  *p_i = vp * (*collision_time) + p0;
+  return true;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::intersect_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                             const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1,
+                             S* collision_time, Vector3<S>* p_i, bool useNewton)
+{
+  *collision_time = 2.0;
+
+  Vector3<S> va, vb, vc, vd;
+  va = a1 - a0;
+  vb = b1 - b0;
+  vc = c1 - c0;
+  vd = d1 - d0;
+
+  S a, b, c, d;
+  computeCubicCoeff_EE(a0, b0, c0, d0, va, vb, vc, vd, &a, &b, &c, &d);
+
+  if(isZero(a) && isZero(b) && isZero(c) && isZero(d))
+  {
+    return false;
+  }
+
+  /// if(isZero(a))
+  /// {
+  ///   return solveSquare(b, c, d, a0, b0, c0, d0, va, vb, vc, vd, collision_time, false);
+  /// }
+
+
+  S coeffs[4];
+  coeffs[3] = a, coeffs[2] = b, coeffs[1] = c, coeffs[0] = d;
+
+  if(useNewton)
+  {
+    S l = 0;
+    S r = 1;
+
+    if(solveCubicWithIntervalNewton(a0, b0, c0, d0, va, vb, vc, vd, l, r, false, coeffs, p_i))
+    {
+      *collision_time  = (l + r) * 0.5;
+    }
+  }
+  else
+  {
+    S roots[3];
+    int num = PolySolver<S>::solveCubic(coeffs, roots);
+    for(int i = 0; i < num; ++i)
+    {
+      S r = roots[i];
+      if(r < 0 || r > 1) continue;
+
+      if(checkRootValidity_EE(a0, b0, c0, d0, va, vb, vc, vd, r, p_i))
+      {
+        *collision_time = r;
+        break;
+      }
+    }
+  }
+
+  if(*collision_time > 1)
+  {
+    return false;
+  }
+
+  return true;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::intersect_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
+                             const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& p1,
+                             const Vector3<S>& L)
+{
+  Vector3<S> va, vb, vp;
+  va = a1 - a0;
+  vb = b1 - b0;
+  vp = p1 - p0;
+
+  S a, b, c;
+  computeCubicCoeff_VE(a0, b0, p0, va, vb, vp, L, &a, &b, &c);
+
+  if(isZero(a) && isZero(b) && isZero(c))
+    return true;
+
+  return solveSquare(a, b, c, a0, b0, p0, va, vb, vp);
+
+}
+
+//==============================================================================
+/// @brief Prefilter for intersection, works for both VF and EE
+template <typename S>
+bool Intersect<S>::intersectPreFiltering(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                                      const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1)
+{
+  Vector3<S> n0 = (b0 - a0).cross(c0 - a0);
+  Vector3<S> n1 = (b1 - a1).cross(c1 - a1);
+  Vector3<S> a0a1 = a1 - a0;
+  Vector3<S> b0b1 = b1 - b0;
+  Vector3<S> c0c1 = c1 - c0;
+  Vector3<S> delta = (b0b1 - a0a1).cross(c0c1 - a0a1);
+  Vector3<S> nx = (n0 + n1 - delta) * 0.5;
+
+  Vector3<S> a0d0 = d0 - a0;
+  Vector3<S> a1d1 = d1 - a1;
+
+  S A = n0.dot(a0d0);
+  S B = n1.dot(a1d1);
+  S C = nx.dot(a0d0);
+  S D = nx.dot(a1d1);
+  S E = n1.dot(a0d0);
+  S F = n0.dot(a1d1);
+
+  if(A > 0 && B > 0 && (2*C +F) > 0 && (2*D+E) > 0)
+    return false;
+  if(A < 0 && B < 0 && (2*C +F) < 0 && (2*D+E) < 0)
+    return false;
+
+  return true;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::intersect_VF_filtered(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
+                                      const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& p1,
+                                      S* collision_time, Vector3<S>* p_i, bool useNewton)
+{
+  if(intersectPreFiltering(a0, b0, c0, p0, a1, b1, c1, p1))
+  {
+    return intersect_VF(a0, b0, c0, p0, a1, b1, c1, p1, collision_time, p_i, useNewton);
+  }
+  else
+    return false;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::intersect_EE_filtered(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                                      const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1,
+                                      S* collision_time, Vector3<S>* p_i, bool useNewton)
+{
+  if(intersectPreFiltering(a0, b0, c0, d0, a1, b1, c1, d1))
+  {
+    return intersect_EE(a0, b0, c0, d0, a1, b1, c1, d1, collision_time, p_i, useNewton);
+  }
+  else
+    return false;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::intersect_Triangle(
+    const Vector3<S>& P1,
+    const Vector3<S>& P2,
+    const Vector3<S>& P3,
+    const Vector3<S>& Q1,
+    const Vector3<S>& Q2,
+    const Vector3<S>& Q3,
+    const Matrix3<S>& R,
+    const Vector3<S>& T,
+    Vector3<S>* contact_points,
+    unsigned int* num_contact_points,
+    S* penetration_depth,
+    Vector3<S>* normal)
+{
+  Vector3<S> Q1_ = R * Q1 + T;
+  Vector3<S> Q2_ = R * Q2 + T;
+  Vector3<S> Q3_ = R * Q3 + T;
+
+  return intersect_Triangle(P1, P2, P3, Q1_, Q2_, Q3_, contact_points, num_contact_points, penetration_depth, normal);
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::intersect_Triangle(
+    const Vector3<S>& P1,
+    const Vector3<S>& P2,
+    const Vector3<S>& P3,
+    const Vector3<S>& Q1,
+    const Vector3<S>& Q2,
+    const Vector3<S>& Q3,
+    const Transform3<S>& tf,
+    Vector3<S>* contact_points,
+    unsigned int* num_contact_points,
+    S* penetration_depth,
+    Vector3<S>* normal)
+{
+  Vector3<S> Q1_ = tf * Q1;
+  Vector3<S> Q2_ = tf * Q2;
+  Vector3<S> Q3_ = tf * Q3;
+
+  return intersect_Triangle(P1, P2, P3, Q1_, Q2_, Q3_, contact_points, num_contact_points, penetration_depth, normal);
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::intersect_Triangle_ODE_style(
+    const Vector3<S>& P1, const Vector3<S>& P2, const Vector3<S>& P3,
+    const Vector3<S>& Q1, const Vector3<S>& Q2, const Vector3<S>& Q3,
+    Vector3<S>* contact_points,
+    unsigned int* num_contact_points,
+    S* penetration_depth,
+    Vector3<S>* normal)
+{
+  Vector3<S> n1;
+  S t1;
+  bool b1 = buildTrianglePlane(P1, P2, P3, &n1, &t1);
+  if(!b1) return false;
+
+  Vector3<S> n2;
+  S t2;
+  bool b2 = buildTrianglePlane(Q1, Q2, Q3, &n2, &t2);
+  if(!b2) return false;
+
+  if(sameSideOfPlane(P1, P2, P3, n2, t2))
+    return false;
+
+  if(sameSideOfPlane(Q1, Q2, Q3, n1, t1))
+    return false;
+
+  Vector3<S> clipped_points1[getMaxTriangleClips()];
+  unsigned int num_clipped_points1 = 0;
+  Vector3<S> clipped_points2[getMaxTriangleClips()];
+  unsigned int num_clipped_points2 = 0;
+
+  Vector3<S> deepest_points1[getMaxTriangleClips()];
+  unsigned int num_deepest_points1 = 0;
+  Vector3<S> deepest_points2[getMaxTriangleClips()];
+  unsigned int num_deepest_points2 = 0;
+  S penetration_depth1 = -1, penetration_depth2 = -1;
+
+  clipTriangleByTriangleAndEdgePlanes(Q1, Q2, Q3, P1, P2, P3, n1, t1, clipped_points2, &num_clipped_points2);
+
+  if(num_clipped_points2 == 0)
+    return false;
+
+  computeDeepestPoints(clipped_points2, num_clipped_points2, n1, t1, &penetration_depth2, deepest_points2, &num_deepest_points2);
+  if(num_deepest_points2 == 0)
+    return false;
+
+  clipTriangleByTriangleAndEdgePlanes(P1, P2, P3, Q1, Q2, Q3, n2, t2, clipped_points1, &num_clipped_points1);
+  if(num_clipped_points1 == 0)
+    return false;
+
+  computeDeepestPoints(clipped_points1, num_clipped_points1, n2, t2, &penetration_depth1, deepest_points1, &num_deepest_points1);
+  if(num_deepest_points1 == 0)
+    return false;
+
+
+  /// Return contact information
+  if(contact_points && num_contact_points && penetration_depth && normal)
+  {
+    if(penetration_depth1 > penetration_depth2)
+    {
+      *num_contact_points = num_deepest_points2;
+      for(unsigned int i = 0; i < num_deepest_points2; ++i)
+      {
+        contact_points[i] = deepest_points2[i];
+      }
+
+      *normal = n1;
+      *penetration_depth = penetration_depth2;
+    }
+    else
+    {
+      *num_contact_points = num_deepest_points1;
+      for(unsigned int i = 0; i < num_deepest_points1; ++i)
+      {
+        contact_points[i] = deepest_points1[i];
+      }
+
+      *normal = -n2;
+      *penetration_depth = penetration_depth1;
+    }
+  }
+
+  return true;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::intersect_Triangle(
+    const Vector3<S>& P1, const Vector3<S>& P2, const Vector3<S>& P3,
+    const Vector3<S>& Q1, const Vector3<S>& Q2, const Vector3<S>& Q3,
+    Vector3<S>* contact_points,
+    unsigned int* num_contact_points,
+    S* penetration_depth,
+    Vector3<S>* normal)
+{
+  Vector3<S> p1 = P1 - P1;
+  Vector3<S> p2 = P2 - P1;
+  Vector3<S> p3 = P3 - P1;
+  Vector3<S> q1 = Q1 - P1;
+  Vector3<S> q2 = Q2 - P1;
+  Vector3<S> q3 = Q3 - P1;
+
+  Vector3<S> e1 = p2 - p1;
+  Vector3<S> e2 = p3 - p2;
+  Vector3<S> n1 = e1.cross(e2);
+  if (!project6(n1, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> f1 = q2 - q1;
+  Vector3<S> f2 = q3 - q2;
+  Vector3<S> m1 = f1.cross(f2);
+  if (!project6(m1, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> ef11 = e1.cross(f1);
+  if (!project6(ef11, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> ef12 = e1.cross(f2);
+  if (!project6(ef12, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> f3 = q1 - q3;
+  Vector3<S> ef13 = e1.cross(f3);
+  if (!project6(ef13, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> ef21 = e2.cross(f1);
+  if (!project6(ef21, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> ef22 = e2.cross(f2);
+  if (!project6(ef22, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> ef23 = e2.cross(f3);
+  if (!project6(ef23, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> e3 = p1 - p3;
+  Vector3<S> ef31 = e3.cross(f1);
+  if (!project6(ef31, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> ef32 = e3.cross(f2);
+  if (!project6(ef32, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> ef33 = e3.cross(f3);
+  if (!project6(ef33, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> g1 = e1.cross(n1);
+  if (!project6(g1, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> g2 = e2.cross(n1);
+  if (!project6(g2, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> g3 = e3.cross(n1);
+  if (!project6(g3, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> h1 = f1.cross(m1);
+  if (!project6(h1, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> h2 = f2.cross(m1);
+  if (!project6(h2, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> h3 = f3.cross(m1);
+  if (!project6(h3, p1, p2, p3, q1, q2, q3)) return false;
+
+  if(contact_points && num_contact_points && penetration_depth && normal)
+  {
+    Vector3<S> n1, n2;
+    S t1, t2;
+    buildTrianglePlane(P1, P2, P3, &n1, &t1);
+    buildTrianglePlane(Q1, Q2, Q3, &n2, &t2);
+
+    Vector3<S> deepest_points1[3];
+    unsigned int num_deepest_points1 = 0;
+    Vector3<S> deepest_points2[3];
+    unsigned int num_deepest_points2 = 0;
+    S penetration_depth1, penetration_depth2;
+
+    Vector3<S> P[3] = {P1, P2, P3};
+    Vector3<S> Q[3] = {Q1, Q2, Q3};
+
+    computeDeepestPoints(Q, 3, n1, t1, &penetration_depth2, deepest_points2, &num_deepest_points2);
+    computeDeepestPoints(P, 3, n2, t2, &penetration_depth1, deepest_points1, &num_deepest_points1);
+
+
+    if(penetration_depth1 > penetration_depth2)
+    {
+      *num_contact_points = std::min(num_deepest_points2, (unsigned int)2);
+      for(unsigned int i = 0; i < *num_contact_points; ++i)
+      {
+        contact_points[i] = deepest_points2[i];
+      }
+
+      *normal = n1;
+      *penetration_depth = penetration_depth2;
+    }
+    else
+    {
+      *num_contact_points = std::min(num_deepest_points1, (unsigned int)2);
+      for(unsigned int i = 0; i < *num_contact_points; ++i)
+      {
+        contact_points[i] = deepest_points1[i];
+      }
+
+      *normal = -n2;
+      *penetration_depth = penetration_depth1;
+    }
+  }
+
+  return true;
+}
+
+//==============================================================================
+template <typename S>
+void Intersect<S>::computeDeepestPoints(Vector3<S>* clipped_points, unsigned int num_clipped_points, const Vector3<S>& n, S t, S* penetration_depth, Vector3<S>* deepest_points, unsigned int* num_deepest_points)
+{
+  *num_deepest_points = 0;
+  S max_depth = -std::numeric_limits<S>::max();
+  unsigned int num_deepest_points_ = 0;
+  unsigned int num_neg = 0;
+  unsigned int num_pos = 0;
+  unsigned int num_zero = 0;
+
+  for(unsigned int i = 0; i < num_clipped_points; ++i)
+  {
+    S dist = -distanceToPlane(n, t, clipped_points[i]);
+    if(dist > getEpsilon()) num_pos++;
+    else if(dist < -getEpsilon()) num_neg++;
+    else num_zero++;
+    if(dist > max_depth)
+    {
+      max_depth = dist;
+      num_deepest_points_ = 1;
+      deepest_points[num_deepest_points_ - 1] = clipped_points[i];
+    }
+    else if(dist + 1e-6 >= max_depth)
+    {
+      num_deepest_points_++;
+      deepest_points[num_deepest_points_ - 1] = clipped_points[i];
+    }
+  }
+
+  if(max_depth < -getEpsilon())
+    num_deepest_points_ = 0;
+
+  if(num_zero == 0 && ((num_neg == 0) || (num_pos == 0)))
+    num_deepest_points_ = 0;
+
+  *penetration_depth = max_depth;
+  *num_deepest_points = num_deepest_points_;
+}
+
+//==============================================================================
+template <typename S>
+void Intersect<S>::clipTriangleByTriangleAndEdgePlanes(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3,
+                                                    const Vector3<S>& t1, const Vector3<S>& t2, const Vector3<S>& t3,
+                                                    const Vector3<S>& tn, S to,
+                                                    Vector3<S> clipped_points[], unsigned int* num_clipped_points,
+                                                    bool clip_triangle)
+{
+  *num_clipped_points = 0;
+  Vector3<S> temp_clip[getMaxTriangleClips()];
+  Vector3<S> temp_clip2[getMaxTriangleClips()];
+  unsigned int num_temp_clip = 0;
+  unsigned int num_temp_clip2 = 0;
+  Vector3<S> v[3] = {v1, v2, v3};
+
+  Vector3<S> plane_n;
+  S plane_dist;
+
+  if(buildEdgePlane(t1, t2, tn, &plane_n, &plane_dist))
+  {
+    clipPolygonByPlane(v, 3, plane_n, plane_dist, temp_clip, &num_temp_clip);
+    if(num_temp_clip > 0)
+    {
+      if(buildEdgePlane(t2, t3, tn, &plane_n, &plane_dist))
+      {
+        clipPolygonByPlane(temp_clip, num_temp_clip, plane_n, plane_dist, temp_clip2, &num_temp_clip2);
+        if(num_temp_clip2 > 0)
+        {
+          if(buildEdgePlane(t3, t1, tn, &plane_n, &plane_dist))
+          {
+            if(clip_triangle)
+            {
+              num_temp_clip = 0;
+              clipPolygonByPlane(temp_clip2, num_temp_clip2, plane_n, plane_dist, temp_clip, &num_temp_clip);
+              if(num_temp_clip > 0)
+              {
+                clipPolygonByPlane(temp_clip, num_temp_clip, tn, to, clipped_points, num_clipped_points);
+              }
+            }
+            else
+            {
+              clipPolygonByPlane(temp_clip2, num_temp_clip2, plane_n, plane_dist, clipped_points, num_clipped_points);
+            }
+          }
+        }
+      }
+    }
+  }
+}
+
+//==============================================================================
+template <typename S>
+void Intersect<S>::clipPolygonByPlane(Vector3<S>* polygon_points, unsigned int num_polygon_points, const Vector3<S>& n, S t, Vector3<S> clipped_points[], unsigned int* num_clipped_points)
+{
+  *num_clipped_points = 0;
+
+  unsigned int num_clipped_points_ = 0;
+  unsigned int vi;
+  unsigned int prev_classify = 2;
+  unsigned int classify;
+  for(unsigned int i = 0; i <= num_polygon_points; ++i)
+  {
+    vi = (i % num_polygon_points);
+    S d = distanceToPlane(n, t, polygon_points[i]);
+    classify = ((d > getEpsilon()) ? 1 : 0);
+    if(classify == 0)
+    {
+      if(prev_classify == 1)
+      {
+        if(num_clipped_points_ < getMaxTriangleClips())
+        {
+          Vector3<S> tmp;
+          clipSegmentByPlane(polygon_points[i - 1], polygon_points[vi], n, t, &tmp);
+          if(num_clipped_points_ > 0)
+          {
+            if((tmp - clipped_points[num_clipped_points_ - 1]).squaredNorm() > getEpsilon())
+            {
+              clipped_points[num_clipped_points_] = tmp;
+              num_clipped_points_++;
+            }
+          }
+          else
+          {
+            clipped_points[num_clipped_points_] = tmp;
+            num_clipped_points_++;
+          }
+        }
+      }
+
+      if(num_clipped_points_ < getMaxTriangleClips() && i < num_polygon_points)
+      {
+        clipped_points[num_clipped_points_] = polygon_points[vi];
+        num_clipped_points_++;
+      }
+    }
+    else
+    {
+      if(prev_classify == 0)
+      {
+        if(num_clipped_points_ < getMaxTriangleClips())
+        {
+          Vector3<S> tmp;
+          clipSegmentByPlane(polygon_points[i - 1], polygon_points[vi], n, t, &tmp);
+          if(num_clipped_points_ > 0)
+          {
+            if((tmp - clipped_points[num_clipped_points_ - 1]).squaredNorm() > getEpsilon())
+            {
+              clipped_points[num_clipped_points_] = tmp;
+              num_clipped_points_++;
+            }
+          }
+          else
+          {
+            clipped_points[num_clipped_points_] = tmp;
+            num_clipped_points_++;
+          }
+        }
+      }
+    }
+
+    prev_classify = classify;
+  }
+
+  if(num_clipped_points_ > 2)
+  {
+    if((clipped_points[0] - clipped_points[num_clipped_points_ - 1]).squaredNorm() < getEpsilon())
+    {
+      num_clipped_points_--;
+    }
+  }
+
+  *num_clipped_points = num_clipped_points_;
+}
+
+//==============================================================================
+template <typename S>
+void Intersect<S>::clipSegmentByPlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& n, S t, Vector3<S>* clipped_point)
+{
+  S dist1 = distanceToPlane(n, t, v1);
+  Vector3<S> tmp = v2 - v1;
+  S dist2 = tmp.dot(n);
+  *clipped_point = tmp * (-dist1 / dist2) + v1;
+}
+
+//==============================================================================
+template <typename S>
+S Intersect<S>::distanceToPlane(const Vector3<S>& n, S t, const Vector3<S>& v)
+{
+  return n.dot(v) - t;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::buildTrianglePlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3, Vector3<S>* n, S* t)
+{
+  Vector3<S> n_ = (v2 - v1).cross(v3 - v1);
+  bool can_normalize = false;
+  normalize(n_, &can_normalize);
+  if(can_normalize)
+  {
+    *n = n_;
+    *t = n_.dot(v1);
+    return true;
+  }
+
+  return false;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::buildEdgePlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& tn, Vector3<S>* n, S* t)
+{
+  Vector3<S> n_ = (v2 - v1).cross(tn);
+  bool can_normalize = false;
+  normalize(n_, &can_normalize);
+  if(can_normalize)
+  {
+    *n = n_;
+    *t = n_.dot(v1);
+    return true;
+  }
+
+  return false;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::sameSideOfPlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3, const Vector3<S>& n, S t)
+{
+  S dist1 = distanceToPlane(n, t, v1);
+  S dist2 = dist1 * distanceToPlane(n, t, v2);
+  S dist3 = dist1 * distanceToPlane(n, t, v3);
+  if((dist2 > 0) && (dist3 > 0))
+    return true;
+  return false;
+}
+
+//==============================================================================
+template <typename S>
+int Intersect<S>::project6(const Vector3<S>& ax,
+                        const Vector3<S>& p1, const Vector3<S>& p2, const Vector3<S>& p3,
+                        const Vector3<S>& q1, const Vector3<S>& q2, const Vector3<S>& q3)
+{
+  S P1 = ax.dot(p1);
+  S P2 = ax.dot(p2);
+  S P3 = ax.dot(p3);
+  S Q1 = ax.dot(q1);
+  S Q2 = ax.dot(q2);
+  S Q3 = ax.dot(q3);
+
+  S mn1 = std::min(P1, std::min(P2, P3));
+  S mx2 = std::max(Q1, std::max(Q2, Q3));
+  if(mn1 > mx2) return 0;
+
+  S mx1 = std::max(P1, std::max(P2, P3));
+  S mn2 = std::min(Q1, std::min(Q2, Q3));
+
+  if(mn2 > mx1) return 0;
+  return 1;
+}
+
+//==============================================================================
+template <typename S>
+S Intersect<S>::gaussianCDF(S x)
+{
+  return 0.5 * std::erfc(-x / sqrt(2.0));
+}
+
+//==============================================================================
+template <typename S>
+constexpr S Intersect<S>::getEpsilon()
+{
+  return 1e-5;
+}
+
+//==============================================================================
+template <typename S>
+constexpr S Intersect<S>::getNearZeroThreshold()
+{
+  return 1e-7;
+}
+
+//==============================================================================
+template <typename S>
+constexpr S Intersect<S>::getCcdResolution()
+{
+  return 1e-7;
+}
+
+//==============================================================================
+template <typename S>
+constexpr unsigned int Intersect<S>::getMaxTriangleClips()
+{
+  return 8;
+}
+
+} // namespace detail
+} // namespace fcl
+
+#endif
diff --git a/include/fcl/narrowphase/detail/traversal/collision/intersect.h b/include/fcl/narrowphase/detail/traversal/collision/intersect.h
index d653b87..df33a8c 100644
--- a/include/fcl/narrowphase/detail/traversal/collision/intersect.h
+++ b/include/fcl/narrowphase/detail/traversal/collision/intersect.h
@@ -1,265 +1,265 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#ifndef FCL_NARROWPHASE_DETAIL_INTERSECT_H
-#define FCL_NARROWPHASE_DETAIL_INTERSECT_H
-
-#include <limits>
-#include "fcl/common/types.h"
-#include "fcl/math/geometry.h"
-#include "fcl/math/detail/polysolver.h"
-
-namespace fcl
-{
-
-namespace detail
-{
-
-/// @brief CCD intersect kernel among primitives 
-template <typename S>
-class FCL_EXPORT Intersect
-{
-
-public:
-
-  /// @brief CCD intersect between one vertex and one face
-  /// [a0, b0, c0] and [a1, b1, c1] are points for the triangle face in time t0 and t1
-  /// p0 and p1 are points for vertex in time t0 and t1
-  /// p_i returns the coordinate of the collision point
-  static bool intersect_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
-                           const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& p1,
-                           S* collision_time, Vector3<S>* p_i, bool useNewton = true);
-
-  /// @brief CCD intersect between two edges
-  /// [a0, b0] and [a1, b1] are points for one edge in time t0 and t1
-  /// [c0, d0] and [c1, d1] are points for the other edge in time t0 and t1
-  /// p_i returns the coordinate of the collision point
-  static bool intersect_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                           const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1,
-                           S* collision_time, Vector3<S>* p_i, bool useNewton = true);
-
-  /// @brief CCD intersect between one vertex and one face, using additional filter 
-  static bool intersect_VF_filtered(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
-                                    const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& p1,
-                                    S* collision_time, Vector3<S>* p_i, bool useNewton = true);
-
-  /// @brief CCD intersect between two edges, using additional filter 
-  static bool intersect_EE_filtered(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                                    const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1,
-                                    S* collision_time, Vector3<S>* p_i, bool useNewton = true);
-
-  /// @brief CCD intersect between one vertex and and one edge 
-  static bool intersect_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
-                           const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& p1,
-                           const Vector3<S>& L);
-
-  /// @brief CD intersect between two triangles [P1, P2, P3] and [Q1, Q2, Q3]
-  static bool intersect_Triangle(
-      const Vector3<S>& P1,
-      const Vector3<S>& P2,
-      const Vector3<S>& P3,
-      const Vector3<S>& Q1,
-      const Vector3<S>& Q2,
-      const Vector3<S>& Q3,
-      Vector3<S>* contact_points = nullptr,
-      unsigned int* num_contact_points = nullptr,
-      S* penetration_depth = nullptr,
-      Vector3<S>* normal = nullptr);
-
-  /// @brief CD intersect between two triangles [P1, P2, P3] and [Q1, Q2, Q3]
-  static bool intersect_Triangle_ODE_style(
-      const Vector3<S>& P1,
-      const Vector3<S>& P2,
-      const Vector3<S>& P3,
-      const Vector3<S>& Q1,
-      const Vector3<S>& Q2,
-      const Vector3<S>& Q3,
-      Vector3<S>* contact_points = nullptr,
-      unsigned int* num_contact_points = nullptr,
-      S* penetration_depth = nullptr,
-      Vector3<S>* normal = nullptr);
-
-  static bool intersect_Triangle(
-      const Vector3<S>& P1,
-      const Vector3<S>& P2,
-      const Vector3<S>& P3,
-      const Vector3<S>& Q1,
-      const Vector3<S>& Q2,
-      const Vector3<S>& Q3,
-      const Matrix3<S>& R,
-      const Vector3<S>& T,
-      Vector3<S>* contact_points = nullptr,
-      unsigned int* num_contact_points = nullptr,
-      S* penetration_depth = nullptr,
-      Vector3<S>* normal = nullptr);
-
-  static bool intersect_Triangle(
-      const Vector3<S>& P1,
-      const Vector3<S>& P2,
-      const Vector3<S>& P3,
-      const Vector3<S>& Q1,
-      const Vector3<S>& Q2,
-      const Vector3<S>& Q3,
-      const Transform3<S>& tf,
-      Vector3<S>* contact_points = nullptr,
-      unsigned int* num_contact_points = nullptr,
-      S* penetration_depth = nullptr,
-      Vector3<S>* normal = nullptr);
-  
-private:
-
-  /// @brief Project function used in intersect_Triangle() 
-  static int project6(const Vector3<S>& ax,
-                      const Vector3<S>& p1, const Vector3<S>& p2, const Vector3<S>& p3,
-                      const Vector3<S>& q1, const Vector3<S>& q2, const Vector3<S>& q3);
-
-  /// @brief Check whether one value is zero 
-  static bool isZero(S v);
-
-  /// @brief Solve the cubic function using Newton method, also satisfies the interval restriction 
-  static bool solveCubicWithIntervalNewton(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                                           const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
-                                           S& l, S& r, bool bVF, S coeffs[], Vector3<S>* data = nullptr);
-
-  /// @brief Check whether one point p is within triangle [a, b, c] 
-  static bool insideTriangle(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>&p);
-
-  /// @brief Check whether one point p is within a line segment [a, b] 
-  static bool insideLineSegment(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& p);
-
-  /// @brief Calculate the line segment papb that is the shortest route between
-  /// two lines p1p2 and p3p4. Calculate also the values of mua and mub where
-  ///                    pa = p1 + mua (p2 - p1)
-  ///                    pb = p3 + mub (p4 - p3)
-  /// return FALSE if no solution exists.
-  static bool linelineIntersect(const Vector3<S>& p1, const Vector3<S>& p2, const Vector3<S>& p3, const Vector3<S>& p4,
-                                Vector3<S>* pa, Vector3<S>* pb, S* mua, S* mub);
-
-  /// @brief Check whether a root for VF intersection is valid (i.e. within the triangle at intersection t 
-  static bool checkRootValidity_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
-                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vp,
-                                   S t);
-
-  /// @brief Check whether a root for EE intersection is valid (i.e. within the two edges intersected at the given time 
-  static bool checkRootValidity_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
-                                   S t, Vector3<S>* q_i = nullptr);
-
-  /// @brief Check whether a root for VE intersection is valid 
-  static bool checkRootValidity_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
-                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp,
-                                   S t);
-
-  /// @brief Solve a square function for EE intersection (with interval restriction) 
-  static bool solveSquare(S a, S b, S c,
-                          const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                          const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
-                          bool bVF,
-                          S* ret);
-
-  /// @brief Solve a square function for VE intersection (with interval restriction) 
-  static bool solveSquare(S a, S b, S c,
-                          const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
-                          const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp);
-
-  /// @brief Compute the cubic coefficients for VF intersection
-  /// See Paper "Interactive Continuous Collision Detection between Deformable Models using Connectivity-Based Culling", Equation 1.
-   
-  static void computeCubicCoeff_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
-                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vp,
-                                   S* a, S* b, S* c, S* d);
-
-  /// @brief Compute the cubic coefficients for EE intersection 
-  static void computeCubicCoeff_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
-                                   S* a, S* b, S* c, S* d);
-
-  /// @brief Compute the cubic coefficients for VE intersection 
-  static void computeCubicCoeff_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
-                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp,
-                                   const Vector3<S>& L,
-                                   S* a, S* b, S* c);
-
-  /// @brief filter for intersection, works for both VF and EE 
-  static bool intersectPreFiltering(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                                    const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1);
-
-  /// @brief distance of point v to a plane n * x - t = 0 
-  static S distanceToPlane(const Vector3<S>& n, S t, const Vector3<S>& v);
-
-  /// @brief check wether points v1, v2, v2 are on the same side of plane n * x - t = 0 
-  static bool sameSideOfPlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3, const Vector3<S>& n, S t);
-
-  /// @brief clip triangle v1, v2, v3 by the prism made by t1, t2 and t3. The normal of the prism is tn and is cutted up by to 
-  static void clipTriangleByTriangleAndEdgePlanes(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3,
-                                                  const Vector3<S>& t1, const Vector3<S>& t2, const Vector3<S>& t3,
-                                                  const Vector3<S>& tn, S to,
-                                                  Vector3<S> clipped_points[], unsigned int* num_clipped_points, bool clip_triangle = false);
-
-  /// @brief build a plane passed through triangle v1 v2 v3 
-  static bool buildTrianglePlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3, Vector3<S>* n, S* t);
-
-  /// @brief build a plane pass through edge v1 and v2, normal is tn 
-  static bool buildEdgePlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& tn, Vector3<S>* n, S* t);
-
-  /// @brief compute the points which has deepest penetration depth 
-  static void computeDeepestPoints(Vector3<S>* clipped_points, unsigned int num_clipped_points, const Vector3<S>& n, S t, S* penetration_depth, Vector3<S>* deepest_points, unsigned int* num_deepest_points);
-
-  /// @brief clip polygon by plane 
-  static void clipPolygonByPlane(Vector3<S>* polygon_points, unsigned int num_polygon_points, const Vector3<S>& n, S t, Vector3<S> clipped_points[], unsigned int* num_clipped_points);
-
-  /// @brief clip a line segment by plane 
-  static void clipSegmentByPlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& n, S t, Vector3<S>* clipped_point);
-
-  /// @brief compute the cdf(x) 
-  static S gaussianCDF(S x);
-
-  static constexpr S getEpsilon();
-  static constexpr S getNearZeroThreshold();
-  static constexpr S getCcdResolution();
-  static constexpr unsigned int getMaxTriangleClips();
-};
-
-using Intersectf = Intersect<float>;
-using Intersectd = Intersect<double>;
-
-} // namespace detail
-} // namespace fcl
-
-#include "fcl/narrowphase/detail/traversal/collision/intersect-inl.h"
-
-#endif
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#ifndef FCL_NARROWPHASE_DETAIL_INTERSECT_H
+#define FCL_NARROWPHASE_DETAIL_INTERSECT_H
+
+#include <limits>
+#include "fcl/common/types.h"
+#include "fcl/math/geometry.h"
+#include "fcl/math/detail/polysolver.h"
+
+namespace fcl
+{
+
+namespace detail
+{
+
+/// @brief CCD intersect kernel among primitives
+template <typename S>
+class Intersect
+{
+
+public:
+
+  /// @brief CCD intersect between one vertex and one face
+  /// [a0, b0, c0] and [a1, b1, c1] are points for the triangle face in time t0 and t1
+  /// p0 and p1 are points for vertex in time t0 and t1
+  /// p_i returns the coordinate of the collision point
+  static bool intersect_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
+                           const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& p1,
+                           S* collision_time, Vector3<S>* p_i, bool useNewton = true);
+
+  /// @brief CCD intersect between two edges
+  /// [a0, b0] and [a1, b1] are points for one edge in time t0 and t1
+  /// [c0, d0] and [c1, d1] are points for the other edge in time t0 and t1
+  /// p_i returns the coordinate of the collision point
+  static bool intersect_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                           const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1,
+                           S* collision_time, Vector3<S>* p_i, bool useNewton = true);
+
+  /// @brief CCD intersect between one vertex and one face, using additional filter
+  static bool intersect_VF_filtered(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
+                                    const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& p1,
+                                    S* collision_time, Vector3<S>* p_i, bool useNewton = true);
+
+  /// @brief CCD intersect between two edges, using additional filter
+  static bool intersect_EE_filtered(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                                    const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1,
+                                    S* collision_time, Vector3<S>* p_i, bool useNewton = true);
+
+  /// @brief CCD intersect between one vertex and and one edge
+  static bool intersect_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
+                           const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& p1,
+                           const Vector3<S>& L);
+
+  /// @brief CD intersect between two triangles [P1, P2, P3] and [Q1, Q2, Q3]
+  static bool intersect_Triangle(
+      const Vector3<S>& P1,
+      const Vector3<S>& P2,
+      const Vector3<S>& P3,
+      const Vector3<S>& Q1,
+      const Vector3<S>& Q2,
+      const Vector3<S>& Q3,
+      Vector3<S>* contact_points = nullptr,
+      unsigned int* num_contact_points = nullptr,
+      S* penetration_depth = nullptr,
+      Vector3<S>* normal = nullptr);
+
+  /// @brief CD intersect between two triangles [P1, P2, P3] and [Q1, Q2, Q3]
+  static bool intersect_Triangle_ODE_style(
+      const Vector3<S>& P1,
+      const Vector3<S>& P2,
+      const Vector3<S>& P3,
+      const Vector3<S>& Q1,
+      const Vector3<S>& Q2,
+      const Vector3<S>& Q3,
+      Vector3<S>* contact_points = nullptr,
+      unsigned int* num_contact_points = nullptr,
+      S* penetration_depth = nullptr,
+      Vector3<S>* normal = nullptr);
+
+  static bool intersect_Triangle(
+      const Vector3<S>& P1,
+      const Vector3<S>& P2,
+      const Vector3<S>& P3,
+      const Vector3<S>& Q1,
+      const Vector3<S>& Q2,
+      const Vector3<S>& Q3,
+      const Matrix3<S>& R,
+      const Vector3<S>& T,
+      Vector3<S>* contact_points = nullptr,
+      unsigned int* num_contact_points = nullptr,
+      S* penetration_depth = nullptr,
+      Vector3<S>* normal = nullptr);
+
+  static bool intersect_Triangle(
+      const Vector3<S>& P1,
+      const Vector3<S>& P2,
+      const Vector3<S>& P3,
+      const Vector3<S>& Q1,
+      const Vector3<S>& Q2,
+      const Vector3<S>& Q3,
+      const Transform3<S>& tf,
+      Vector3<S>* contact_points = nullptr,
+      unsigned int* num_contact_points = nullptr,
+      S* penetration_depth = nullptr,
+      Vector3<S>* normal = nullptr);
+
+private:
+
+  /// @brief Project function used in intersect_Triangle()
+  static int project6(const Vector3<S>& ax,
+                      const Vector3<S>& p1, const Vector3<S>& p2, const Vector3<S>& p3,
+                      const Vector3<S>& q1, const Vector3<S>& q2, const Vector3<S>& q3);
+
+  /// @brief Check whether one value is zero
+  static bool isZero(S v);
+
+  /// @brief Solve the cubic function using Newton method, also satisfies the interval restriction
+  static bool solveCubicWithIntervalNewton(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                                           const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
+                                           S& l, S& r, bool bVF, S coeffs[], Vector3<S>* data = nullptr);
+
+  /// @brief Check whether one point p is within triangle [a, b, c]
+  static bool insideTriangle(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>&p);
+
+  /// @brief Check whether one point p is within a line segment [a, b]
+  static bool insideLineSegment(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& p);
+
+  /// @brief Calculate the line segment papb that is the shortest route between
+  /// two lines p1p2 and p3p4. Calculate also the values of mua and mub where
+  ///                    pa = p1 + mua (p2 - p1)
+  ///                    pb = p3 + mub (p4 - p3)
+  /// return FALSE if no solution exists.
+  static bool linelineIntersect(const Vector3<S>& p1, const Vector3<S>& p2, const Vector3<S>& p3, const Vector3<S>& p4,
+                                Vector3<S>* pa, Vector3<S>* pb, S* mua, S* mub);
+
+  /// @brief Check whether a root for VF intersection is valid (i.e. within the triangle at intersection t
+  static bool checkRootValidity_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
+                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vp,
+                                   S t);
+
+  /// @brief Check whether a root for EE intersection is valid (i.e. within the two edges intersected at the given time
+  static bool checkRootValidity_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
+                                   S t, Vector3<S>* q_i = nullptr);
+
+  /// @brief Check whether a root for VE intersection is valid
+  static bool checkRootValidity_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
+                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp,
+                                   S t);
+
+  /// @brief Solve a square function for EE intersection (with interval restriction)
+  static bool solveSquare(S a, S b, S c,
+                          const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                          const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
+                          bool bVF,
+                          S* ret);
+
+  /// @brief Solve a square function for VE intersection (with interval restriction)
+  static bool solveSquare(S a, S b, S c,
+                          const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
+                          const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp);
+
+  /// @brief Compute the cubic coefficients for VF intersection
+  /// See Paper "Interactive Continuous Collision Detection between Deformable Models using Connectivity-Based Culling", Equation 1.
+
+  static void computeCubicCoeff_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
+                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vp,
+                                   S* a, S* b, S* c, S* d);
+
+  /// @brief Compute the cubic coefficients for EE intersection
+  static void computeCubicCoeff_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
+                                   S* a, S* b, S* c, S* d);
+
+  /// @brief Compute the cubic coefficients for VE intersection
+  static void computeCubicCoeff_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
+                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp,
+                                   const Vector3<S>& L,
+                                   S* a, S* b, S* c);
+
+  /// @brief filter for intersection, works for both VF and EE
+  static bool intersectPreFiltering(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                                    const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1);
+
+  /// @brief distance of point v to a plane n * x - t = 0
+  static S distanceToPlane(const Vector3<S>& n, S t, const Vector3<S>& v);
+
+  /// @brief check wether points v1, v2, v2 are on the same side of plane n * x - t = 0
+  static bool sameSideOfPlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3, const Vector3<S>& n, S t);
+
+  /// @brief clip triangle v1, v2, v3 by the prism made by t1, t2 and t3. The normal of the prism is tn and is cutted up by to
+  static void clipTriangleByTriangleAndEdgePlanes(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3,
+                                                  const Vector3<S>& t1, const Vector3<S>& t2, const Vector3<S>& t3,
+                                                  const Vector3<S>& tn, S to,
+                                                  Vector3<S> clipped_points[], unsigned int* num_clipped_points, bool clip_triangle = false);
+
+  /// @brief build a plane passed through triangle v1 v2 v3
+  static bool buildTrianglePlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3, Vector3<S>* n, S* t);
+
+  /// @brief build a plane pass through edge v1 and v2, normal is tn
+  static bool buildEdgePlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& tn, Vector3<S>* n, S* t);
+
+  /// @brief compute the points which has deepest penetration depth
+  static void computeDeepestPoints(Vector3<S>* clipped_points, unsigned int num_clipped_points, const Vector3<S>& n, S t, S* penetration_depth, Vector3<S>* deepest_points, unsigned int* num_deepest_points);
+
+  /// @brief clip polygon by plane
+  static void clipPolygonByPlane(Vector3<S>* polygon_points, unsigned int num_polygon_points, const Vector3<S>& n, S t, Vector3<S> clipped_points[], unsigned int* num_clipped_points);
+
+  /// @brief clip a line segment by plane
+  static void clipSegmentByPlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& n, S t, Vector3<S>* clipped_point);
+
+  /// @brief compute the cdf(x)
+  static S gaussianCDF(S x);
+
+  static constexpr S getEpsilon();
+  static constexpr S getNearZeroThreshold();
+  static constexpr S getCcdResolution();
+  static constexpr unsigned int getMaxTriangleClips();
+};
+
+using Intersectf = Intersect<float>;
+using Intersectd = Intersect<double>;
+
+} // namespace detail
+} // namespace fcl
+
+#include "fcl/narrowphase/detail/traversal/collision/intersect-inl.h"
+
+#endif
diff --git a/include/fcl/narrowphase/detail/traversal/collision/mesh_collision_traversal_node-inl.h b/include/fcl/narrowphase/detail/traversal/collision/mesh_collision_traversal_node-inl.h
index 0a2731f..2665d96 100644
--- a/include/fcl/narrowphase/detail/traversal/collision/mesh_collision_traversal_node-inl.h
+++ b/include/fcl/narrowphase/detail/traversal/collision/mesh_collision_traversal_node-inl.h
@@ -56,6 +56,7 @@ class FCL_EXPORT MeshCollisionTraversalNodeOBB<double>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool initialize(
     MeshCollisionTraversalNodeOBB<double>& node,
     const BVHModel<OBB<double>>& model1,
@@ -71,6 +72,7 @@ class FCL_EXPORT MeshCollisionTraversalNodeRSS<double>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool initialize(
     MeshCollisionTraversalNodeRSS<double>& node,
     const BVHModel<RSS<double>>& model1,
@@ -86,6 +88,7 @@ class FCL_EXPORT MeshCollisionTraversalNodekIOS<double>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool initialize(
     MeshCollisionTraversalNodekIOS<double>& node,
     const BVHModel<kIOS<double>>& model1,
@@ -101,6 +104,7 @@ class FCL_EXPORT MeshCollisionTraversalNodeOBBRSS<double>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool initialize(
     MeshCollisionTraversalNodeOBBRSS<double>& node,
     const BVHModel<OBBRSS<double>>& model1,
diff --git a/include/fcl/narrowphase/detail/traversal/collision/mesh_collision_traversal_node.h b/include/fcl/narrowphase/detail/traversal/collision/mesh_collision_traversal_node.h
index 7e3d993..6d0ec97 100644
--- a/include/fcl/narrowphase/detail/traversal/collision/mesh_collision_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/collision/mesh_collision_traversal_node.h
@@ -55,7 +55,7 @@ namespace detail
 
 /// @brief Traversal node for collision between two meshes
 template <typename BV>
-class FCL_EXPORT MeshCollisionTraversalNode : public BVHCollisionTraversalNode<BV>
+class MeshCollisionTraversalNode : public BVHCollisionTraversalNode<BV>
 {
 public:
 
@@ -81,7 +81,6 @@ public:
 /// @brief Initialize traversal node for collision between two meshes, given the
 /// current transforms
 template <typename BV>
-FCL_EXPORT
 bool initialize(
     MeshCollisionTraversalNode<BV>& node,
     BVHModel<BV>& model1,
@@ -96,7 +95,7 @@ bool initialize(
 /// @brief Traversal node for collision between two meshes if their underlying
 /// BVH node is oriented node (OBB, RSS, OBBRSS, kIOS)
 template <typename S>
-class FCL_EXPORT MeshCollisionTraversalNodeOBB : public MeshCollisionTraversalNode<OBB<S>>
+class MeshCollisionTraversalNodeOBB : public MeshCollisionTraversalNode<OBB<S>>
 {
 public:
   MeshCollisionTraversalNodeOBB();
@@ -125,7 +124,6 @@ using MeshCollisionTraversalNodeOBBd = MeshCollisionTraversalNodeOBB<double>;
 /// @brief Initialize traversal node for collision between two meshes,
 /// specialized for OBB type
 template <typename S>
-FCL_EXPORT
 bool initialize(
     MeshCollisionTraversalNodeOBB<S>& node,
     const BVHModel<OBB<S>>& model1,
@@ -136,7 +134,7 @@ bool initialize(
     CollisionResult<S>& result);
 
 template <typename S>
-class FCL_EXPORT MeshCollisionTraversalNodeRSS : public MeshCollisionTraversalNode<RSS<S>>
+class MeshCollisionTraversalNodeRSS : public MeshCollisionTraversalNode<RSS<S>>
 {
 public:
   MeshCollisionTraversalNodeRSS();
@@ -167,7 +165,6 @@ using MeshCollisionTraversalNodeRSSd = MeshCollisionTraversalNodeRSS<double>;
 /// @brief Initialize traversal node for collision between two meshes,
 /// specialized for RSS type
 template <typename S>
-FCL_EXPORT
 bool initialize(
     MeshCollisionTraversalNodeRSS<S>& node,
     const BVHModel<RSS<S>>& model1,
@@ -178,11 +175,11 @@ bool initialize(
     CollisionResult<S>& result);
 
 template <typename S>
-class FCL_EXPORT MeshCollisionTraversalNodekIOS : public MeshCollisionTraversalNode<kIOS<S>>
+class MeshCollisionTraversalNodekIOS : public MeshCollisionTraversalNode<kIOS<S>>
 {
 public:
   MeshCollisionTraversalNodekIOS();
- 
+
   bool BVTesting(int b1, int b2) const;
 
   void leafTesting(int b1, int b2) const;
@@ -199,7 +196,6 @@ using MeshCollisionTraversalNodekIOSd = MeshCollisionTraversalNodekIOS<double>;
 /// @brief Initialize traversal node for collision between two meshes,
 /// specialized for kIOS type
 template <typename S>
-FCL_EXPORT
 bool initialize(
     MeshCollisionTraversalNodekIOS<S>& node,
     const BVHModel<kIOS<S>>& model1,
@@ -210,11 +206,11 @@ bool initialize(
     CollisionResult<S>& result);
 
 template <typename S>
-class FCL_EXPORT MeshCollisionTraversalNodeOBBRSS : public MeshCollisionTraversalNode<OBBRSS<S>>
+class MeshCollisionTraversalNodeOBBRSS : public MeshCollisionTraversalNode<OBBRSS<S>>
 {
 public:
   MeshCollisionTraversalNodeOBBRSS();
- 
+
 
   bool BVTesting(int b1, int b2) const;
 
@@ -232,7 +228,6 @@ using MeshCollisionTraversalNodeOBBRSSd = MeshCollisionTraversalNodeOBBRSS<doubl
 /// @brief Initialize traversal node for collision between two meshes,
 /// specialized for OBBRSS type
 template <typename S>
-FCL_EXPORT
 bool initialize(
     MeshCollisionTraversalNodeOBBRSS<S>& node,
     const BVHModel<OBBRSS<S>>& model1,
@@ -243,7 +238,6 @@ bool initialize(
     CollisionResult<S>& result);
 
 template <typename BV>
-FCL_EXPORT
 void meshCollisionOrientedNodeLeafTesting(
     int b1,
     int b2,
@@ -264,7 +258,6 @@ void meshCollisionOrientedNodeLeafTesting(
     CollisionResult<typename BV::S>& result);
 
 template <typename BV>
-FCL_EXPORT
 void meshCollisionOrientedNodeLeafTesting(
     int b1,
     int b2,
diff --git a/include/fcl/narrowphase/detail/traversal/collision/mesh_continuous_collision_traversal_node-inl.h b/include/fcl/narrowphase/detail/traversal/collision/mesh_continuous_collision_traversal_node-inl.h
index 39213d7..07e9c7b 100644
--- a/include/fcl/narrowphase/detail/traversal/collision/mesh_continuous_collision_traversal_node-inl.h
+++ b/include/fcl/narrowphase/detail/traversal/collision/mesh_continuous_collision_traversal_node-inl.h
@@ -50,7 +50,7 @@ namespace detail
 
 //==============================================================================
 extern template
-struct BVHContinuousCollisionPair<double>;
+struct FCL_EXPORT BVHContinuousCollisionPair<double>;
 
 //==============================================================================
 template <typename S>
diff --git a/include/fcl/narrowphase/detail/traversal/collision/mesh_continuous_collision_traversal_node.h b/include/fcl/narrowphase/detail/traversal/collision/mesh_continuous_collision_traversal_node.h
index 82425a5..a9e7b01 100644
--- a/include/fcl/narrowphase/detail/traversal/collision/mesh_continuous_collision_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/collision/mesh_continuous_collision_traversal_node.h
@@ -48,7 +48,7 @@ namespace detail
 
 /// @brief Traversal node for continuous collision between BVH models
 template <typename S>
-struct FCL_EXPORT BVHContinuousCollisionPair
+struct BVHContinuousCollisionPair
 {
   BVHContinuousCollisionPair();
 
@@ -66,7 +66,7 @@ struct FCL_EXPORT BVHContinuousCollisionPair
 
 /// @brief Traversal node for continuous collision between meshes
 template <typename BV>
-class FCL_EXPORT MeshContinuousCollisionTraversalNode
+class MeshContinuousCollisionTraversalNode
     : public BVHCollisionTraversalNode<BV>
 {
 public:
@@ -101,7 +101,6 @@ public:
 /// @brief Initialize traversal node for continuous collision detection between
 /// two meshes
 template <typename BV>
-FCL_EXPORT
 bool initialize(
     MeshContinuousCollisionTraversalNode<BV>& node,
     const BVHModel<BV>& model1,
diff --git a/include/fcl/narrowphase/detail/traversal/collision/mesh_shape_collision_traversal_node.h b/include/fcl/narrowphase/detail/traversal/collision/mesh_shape_collision_traversal_node.h
index a06250a..5354b40 100644
--- a/include/fcl/narrowphase/detail/traversal/collision/mesh_shape_collision_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/collision/mesh_shape_collision_traversal_node.h
@@ -49,7 +49,7 @@ namespace detail
 
 /// @brief Traversal node for collision between mesh and shape
 template <typename BV, typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT MeshShapeCollisionTraversalNode
+class MeshShapeCollisionTraversalNode
     : public BVHShapeCollisionTraversalNode<BV, Shape>
 {
 public:
@@ -66,7 +66,7 @@ public:
 
   Vector3<S>* vertices;
   Triangle* tri_indices;
-  
+
   S cost_density;
 
   const NarrowPhaseSolver* nsolver;
@@ -75,7 +75,6 @@ public:
 /// @brief Initialize traversal node for collision between one mesh and one
 /// shape, given current object transform
 template <typename BV, typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool initialize(
     MeshShapeCollisionTraversalNode<BV, Shape, NarrowPhaseSolver>& node,
     BVHModel<BV>& model1,
@@ -88,7 +87,6 @@ bool initialize(
     bool use_refit = false, bool refit_bottomup = false);
 
 template <typename BV, typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 void meshShapeCollisionOrientedNodeLeafTesting(
     int b1,
     int b2,
@@ -107,7 +105,7 @@ void meshShapeCollisionOrientedNodeLeafTesting(
 
 /// @brief Traversal node for mesh and shape, when mesh BVH is one of the oriented node (OBB, RSS, OBBRSS, kIOS)
 template <typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT MeshShapeCollisionTraversalNodeOBB
+class MeshShapeCollisionTraversalNodeOBB
     : public MeshShapeCollisionTraversalNode<
           OBB<typename Shape::S>, Shape, NarrowPhaseSolver>
 {
@@ -123,7 +121,6 @@ public:
 /// @brief Initialize the traversal node for collision between one mesh and one
 /// shape, specialized for OBB type
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool initialize(
     MeshShapeCollisionTraversalNodeOBB<Shape, NarrowPhaseSolver>& node,
     const BVHModel<OBB<typename Shape::S>>& model1,
@@ -135,7 +132,7 @@ bool initialize(
     CollisionResult<typename Shape::S>& result);
 
 template <typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT MeshShapeCollisionTraversalNodeRSS
+class MeshShapeCollisionTraversalNodeRSS
     : public MeshShapeCollisionTraversalNode<
           RSS<typename Shape::S>, Shape, NarrowPhaseSolver>
 {
@@ -151,7 +148,6 @@ public:
 /// @brief Initialize the traversal node for collision between one mesh and one
 /// shape, specialized for RSS type
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool initialize(
     MeshShapeCollisionTraversalNodeRSS<Shape, NarrowPhaseSolver>& node,
     const BVHModel<RSS<typename Shape::S>>& model1,
@@ -163,7 +159,7 @@ bool initialize(
     CollisionResult<typename Shape::S>& result);
 
 template <typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT MeshShapeCollisionTraversalNodekIOS
+class MeshShapeCollisionTraversalNodekIOS
     : public MeshShapeCollisionTraversalNode<
           kIOS<typename Shape::S>, Shape, NarrowPhaseSolver>
 {
@@ -179,7 +175,6 @@ public:
 /// @brief Initialize the traversal node for collision between one mesh and one
 ///  shape, specialized for kIOS type
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool initialize(
     MeshShapeCollisionTraversalNodekIOS<Shape, NarrowPhaseSolver>& node,
     const BVHModel<kIOS<typename Shape::S>>& model1,
@@ -191,7 +186,7 @@ bool initialize(
     CollisionResult<typename Shape::S>& result);
 
 template <typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT MeshShapeCollisionTraversalNodeOBBRSS
+class MeshShapeCollisionTraversalNodeOBBRSS
     : public MeshShapeCollisionTraversalNode<
           OBBRSS<typename Shape::S>, Shape, NarrowPhaseSolver>
 {
@@ -207,7 +202,6 @@ public:
 /// @brief Initialize the traversal node for collision between one mesh and one
 /// shape, specialized for OBBRSS type
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool initialize(
     MeshShapeCollisionTraversalNodeOBBRSS<Shape, NarrowPhaseSolver>& node,
     const BVHModel<OBBRSS<typename Shape::S>>& model1,
diff --git a/include/fcl/narrowphase/detail/traversal/collision/shape_bvh_collision_traversal_node.h b/include/fcl/narrowphase/detail/traversal/collision/shape_bvh_collision_traversal_node.h
index d665279..fc2ca97 100644
--- a/include/fcl/narrowphase/detail/traversal/collision/shape_bvh_collision_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/collision/shape_bvh_collision_traversal_node.h
@@ -49,7 +49,7 @@ namespace detail
 
 /// @brief Traversal node for collision between shape and BVH
 template <typename Shape, typename BV>
-class FCL_EXPORT ShapeBVHCollisionTraversalNode
+class ShapeBVHCollisionTraversalNode
     : public CollisionTraversalNodeBase<typename BV::S>
 {
 public:
diff --git a/include/fcl/narrowphase/detail/traversal/collision/shape_collision_traversal_node.h b/include/fcl/narrowphase/detail/traversal/collision/shape_collision_traversal_node.h
index 68394d1..575807f 100644
--- a/include/fcl/narrowphase/detail/traversal/collision/shape_collision_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/collision/shape_collision_traversal_node.h
@@ -50,7 +50,7 @@ namespace detail
 
 /// @brief Traversal node for collision between two shapes
 template <typename Shape1, typename Shape2, typename NarrowPhaseSolver>
-class FCL_EXPORT ShapeCollisionTraversalNode
+class ShapeCollisionTraversalNode
     : public CollisionTraversalNodeBase<typename Shape1::S>
 {
 public:
diff --git a/include/fcl/narrowphase/detail/traversal/collision/shape_mesh_collision_traversal_node-inl.h b/include/fcl/narrowphase/detail/traversal/collision/shape_mesh_collision_traversal_node-inl.h
index d4fbdfb..ed405f5 100644
--- a/include/fcl/narrowphase/detail/traversal/collision/shape_mesh_collision_traversal_node-inl.h
+++ b/include/fcl/narrowphase/detail/traversal/collision/shape_mesh_collision_traversal_node-inl.h
@@ -50,7 +50,6 @@ namespace detail
 
 //==============================================================================
 template <typename Shape, typename BV, typename NarrowPhaseSolver>
-FCL_EXPORT
 ShapeMeshCollisionTraversalNode<Shape, BV, NarrowPhaseSolver>::ShapeMeshCollisionTraversalNode()
   : ShapeBVHCollisionTraversalNode<Shape, BV>()
 {
@@ -62,7 +61,6 @@ ShapeMeshCollisionTraversalNode<Shape, BV, NarrowPhaseSolver>::ShapeMeshCollisio
 
 //==============================================================================
 template <typename Shape, typename BV, typename NarrowPhaseSolver>
-FCL_EXPORT
 void ShapeMeshCollisionTraversalNode<Shape, BV, NarrowPhaseSolver>::leafTesting(int b1, int b2) const
 {
   FCL_UNUSED(b1);
@@ -131,7 +129,6 @@ void ShapeMeshCollisionTraversalNode<Shape, BV, NarrowPhaseSolver>::leafTesting(
 
 //==============================================================================
 template <typename Shape, typename BV, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool ShapeMeshCollisionTraversalNode<Shape, BV, NarrowPhaseSolver>::canStop() const
 {
   return this->request.isSatisfied(*(this->result));
@@ -139,7 +136,6 @@ bool ShapeMeshCollisionTraversalNode<Shape, BV, NarrowPhaseSolver>::canStop() co
 
 //==============================================================================
 template <typename Shape, typename BV, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool initialize(
     ShapeMeshCollisionTraversalNode<Shape, BV, NarrowPhaseSolver>& node,
     const Shape& model1,
@@ -195,14 +191,12 @@ bool initialize(
 
 //==============================================================================
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 ShapeMeshCollisionTraversalNodeOBB<Shape, NarrowPhaseSolver>::ShapeMeshCollisionTraversalNodeOBB() : ShapeMeshCollisionTraversalNode<Shape, OBB<typename Shape::S>, NarrowPhaseSolver>()
 {
 }
 
 //==============================================================================
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool ShapeMeshCollisionTraversalNodeOBB<Shape, NarrowPhaseSolver>::BVTesting(int b1, int b2) const
 {
   FCL_UNUSED(b1);
@@ -213,7 +207,6 @@ bool ShapeMeshCollisionTraversalNodeOBB<Shape, NarrowPhaseSolver>::BVTesting(int
 
 //==============================================================================
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 void ShapeMeshCollisionTraversalNodeOBB<Shape, NarrowPhaseSolver>::leafTesting(int b1, int b2) const
 {
   detail::meshShapeCollisionOrientedNodeLeafTesting(b2, b1, *(this->model2), this->model1, this->vertices, this->tri_indices,
@@ -224,14 +217,12 @@ void ShapeMeshCollisionTraversalNodeOBB<Shape, NarrowPhaseSolver>::leafTesting(i
 
 //==============================================================================
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 ShapeMeshCollisionTraversalNodeRSS<Shape, NarrowPhaseSolver>::ShapeMeshCollisionTraversalNodeRSS() : ShapeMeshCollisionTraversalNode<Shape, RSS<typename Shape::S>, NarrowPhaseSolver>()
 {
 }
 
 //==============================================================================
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool ShapeMeshCollisionTraversalNodeRSS<Shape, NarrowPhaseSolver>::BVTesting(int b1, int b2) const
 {
   FCL_UNUSED(b1);
@@ -242,7 +233,6 @@ bool ShapeMeshCollisionTraversalNodeRSS<Shape, NarrowPhaseSolver>::BVTesting(int
 
 //==============================================================================
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 void ShapeMeshCollisionTraversalNodeRSS<Shape, NarrowPhaseSolver>::leafTesting(int b1, int b2) const
 {
   detail::meshShapeCollisionOrientedNodeLeafTesting(b2, b1, *(this->model2), this->model1, this->vertices, this->tri_indices,
@@ -253,14 +243,12 @@ void ShapeMeshCollisionTraversalNodeRSS<Shape, NarrowPhaseSolver>::leafTesting(i
 
 //==============================================================================
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 ShapeMeshCollisionTraversalNodekIOS<Shape, NarrowPhaseSolver>::ShapeMeshCollisionTraversalNodekIOS() : ShapeMeshCollisionTraversalNode<Shape, kIOS<typename Shape::S>, NarrowPhaseSolver>()
 {
 }
 
 //==============================================================================
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool ShapeMeshCollisionTraversalNodekIOS<Shape, NarrowPhaseSolver>::BVTesting(int b1, int b2) const
 {
   FCL_UNUSED(b1);
@@ -271,7 +259,6 @@ bool ShapeMeshCollisionTraversalNodekIOS<Shape, NarrowPhaseSolver>::BVTesting(in
 
 //==============================================================================
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 void ShapeMeshCollisionTraversalNodekIOS<Shape, NarrowPhaseSolver>::leafTesting(int b1, int b2) const
 {
   detail::meshShapeCollisionOrientedNodeLeafTesting(b2, b1, *(this->model2), this->model1, this->vertices, this->tri_indices,
@@ -282,14 +269,12 @@ void ShapeMeshCollisionTraversalNodekIOS<Shape, NarrowPhaseSolver>::leafTesting(
 
 //==============================================================================
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 ShapeMeshCollisionTraversalNodeOBBRSS<Shape, NarrowPhaseSolver>::ShapeMeshCollisionTraversalNodeOBBRSS() : ShapeMeshCollisionTraversalNode<Shape, OBBRSS<typename Shape::S>, NarrowPhaseSolver>()
 {
 }
 
 //==============================================================================
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool ShapeMeshCollisionTraversalNodeOBBRSS<Shape, NarrowPhaseSolver>::BVTesting(int b1, int b2) const
 {
   FCL_UNUSED(b1);
@@ -300,7 +285,6 @@ bool ShapeMeshCollisionTraversalNodeOBBRSS<Shape, NarrowPhaseSolver>::BVTesting(
 
 //==============================================================================
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 void ShapeMeshCollisionTraversalNodeOBBRSS<Shape, NarrowPhaseSolver>::leafTesting(int b1, int b2) const
 {
   detail::meshShapeCollisionOrientedNodeLeafTesting(b2, b1, *(this->model2), this->model1, this->vertices, this->tri_indices,
@@ -341,7 +325,6 @@ static bool setupShapeMeshCollisionOrientedNode(OrientedNode<Shape, NarrowPhaseS
 
 //==============================================================================
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool initialize(
     ShapeMeshCollisionTraversalNodeOBB<Shape, NarrowPhaseSolver>& node,
     const Shape& model1,
@@ -358,7 +341,6 @@ bool initialize(
 
 //==============================================================================
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool initialize(
     ShapeMeshCollisionTraversalNodeRSS<Shape, NarrowPhaseSolver>& node,
     const Shape& model1,
@@ -375,7 +357,6 @@ bool initialize(
 
 //==============================================================================
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool initialize(
     ShapeMeshCollisionTraversalNodekIOS<Shape, NarrowPhaseSolver>& node,
     const Shape& model1,
@@ -392,7 +373,6 @@ bool initialize(
 
 //==============================================================================
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool initialize(
     ShapeMeshCollisionTraversalNodeOBBRSS<Shape, NarrowPhaseSolver>& node,
     const Shape& model1,
diff --git a/include/fcl/narrowphase/detail/traversal/collision/shape_mesh_collision_traversal_node.h b/include/fcl/narrowphase/detail/traversal/collision/shape_mesh_collision_traversal_node.h
index 5ebcc03..1514a5e 100644
--- a/include/fcl/narrowphase/detail/traversal/collision/shape_mesh_collision_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/collision/shape_mesh_collision_traversal_node.h
@@ -49,7 +49,7 @@ namespace detail
 
 /// @brief Traversal node for collision between shape and mesh
 template <typename Shape, typename BV, typename NarrowPhaseSolver>
-class FCL_EXPORT ShapeMeshCollisionTraversalNode
+class ShapeMeshCollisionTraversalNode
     : public ShapeBVHCollisionTraversalNode<Shape, BV>
 {
 public:
@@ -74,7 +74,6 @@ public:
 /// @brief Initialize traversal node for collision between one mesh and one
 /// shape, given current object transform
 template <typename Shape, typename BV, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool initialize(
     ShapeMeshCollisionTraversalNode<Shape, BV, NarrowPhaseSolver>& node,
     const Shape& model1,
@@ -88,7 +87,7 @@ bool initialize(
 
 /// @brief Traversal node for shape and mesh, when mesh BVH is one of the oriented node (OBB, RSS, OBBRSS, kIOS)
 template <typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT ShapeMeshCollisionTraversalNodeOBB
+class ShapeMeshCollisionTraversalNodeOBB
     : public ShapeMeshCollisionTraversalNode<
     Shape, OBB<typename Shape::S>, NarrowPhaseSolver>
 {
@@ -103,7 +102,6 @@ public:
 /// @brief Initialize the traversal node for collision between one mesh and one
 /// shape, specialized for OBB type
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool initialize(
     ShapeMeshCollisionTraversalNodeOBB<Shape, NarrowPhaseSolver>& node,
     const Shape& model1,
@@ -115,7 +113,7 @@ bool initialize(
     CollisionResult<typename Shape::S>& result);
 
 template <typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT ShapeMeshCollisionTraversalNodeRSS
+class ShapeMeshCollisionTraversalNodeRSS
     : public ShapeMeshCollisionTraversalNode<Shape, RSS<typename Shape::S>, NarrowPhaseSolver>
 {
 public:
@@ -130,7 +128,6 @@ public:
 /// @brief Initialize the traversal node for collision between one mesh and one
 /// shape, specialized for RSS type
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool initialize(
     ShapeMeshCollisionTraversalNodeRSS<Shape, NarrowPhaseSolver>& node,
     const Shape& model1,
@@ -142,7 +139,7 @@ bool initialize(
     CollisionResult<typename Shape::S>& result);
 
 template <typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT ShapeMeshCollisionTraversalNodekIOS
+class ShapeMeshCollisionTraversalNodekIOS
     : public ShapeMeshCollisionTraversalNode<Shape, kIOS<typename Shape::S>, NarrowPhaseSolver>
 {
 public:
@@ -157,7 +154,6 @@ public:
 /// @brief Initialize the traversal node for collision between one mesh and one
 /// shape, specialized for kIOS type
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool initialize(
     ShapeMeshCollisionTraversalNodekIOS<Shape, NarrowPhaseSolver>& node,
     const Shape& model1,
@@ -169,7 +165,7 @@ bool initialize(
     CollisionResult<typename Shape::S>& result);
 
 template <typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT ShapeMeshCollisionTraversalNodeOBBRSS
+class ShapeMeshCollisionTraversalNodeOBBRSS
     : public ShapeMeshCollisionTraversalNode<Shape, OBBRSS<typename Shape::S>, NarrowPhaseSolver>
 {
 public:
@@ -184,7 +180,6 @@ public:
 /// @brief Initialize the traversal node for collision between one mesh and one
 /// shape, specialized for OBBRSS type
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool initialize(
     ShapeMeshCollisionTraversalNodeOBBRSS<Shape, NarrowPhaseSolver>& node,
     const Shape& model1,
diff --git a/include/fcl/narrowphase/detail/traversal/collision_node-inl.h b/include/fcl/narrowphase/detail/traversal/collision_node-inl.h
index 73d7a72..82c605b 100644
--- a/include/fcl/narrowphase/detail/traversal/collision_node-inl.h
+++ b/include/fcl/narrowphase/detail/traversal/collision_node-inl.h
@@ -49,22 +49,27 @@ namespace detail
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void collide(CollisionTraversalNodeBase<double>* node, BVHFrontList* front_list);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void selfCollide(CollisionTraversalNodeBase<double>* node, BVHFrontList* front_list);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void distance(DistanceTraversalNodeBase<double>* node, BVHFrontList* front_list, int qsize);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void collide2(MeshCollisionTraversalNodeOBB<double>* node, BVHFrontList* front_list);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void collide2(MeshCollisionTraversalNodeRSS<double>* node, BVHFrontList* front_list);
 
 //==============================================================================
diff --git a/include/fcl/narrowphase/detail/traversal/collision_node.h b/include/fcl/narrowphase/detail/traversal/collision_node.h
index c00a1a1..d15f4ee 100644
--- a/include/fcl/narrowphase/detail/traversal/collision_node.h
+++ b/include/fcl/narrowphase/detail/traversal/collision_node.h
@@ -53,27 +53,22 @@ namespace detail
 
 /// @brief collision on collision traversal node; can use front list to accelerate
 template <typename S>
-FCL_EXPORT
 void collide(CollisionTraversalNodeBase<S>* node, BVHFrontList* front_list = nullptr);
 
 /// @brief self collision on collision traversal node; can use front list to accelerate
 template <typename S>
-FCL_EXPORT
 void selfCollide(CollisionTraversalNodeBase<S>* node, BVHFrontList* front_list = nullptr);
 
 /// @brief distance computation on distance traversal node; can use front list to accelerate
 template <typename S>
-FCL_EXPORT
 void distance(DistanceTraversalNodeBase<S>* node, BVHFrontList* front_list = nullptr, int qsize = 2);
 
 /// @brief special collision on OBB traversal node
 template <typename S>
-FCL_EXPORT
 void collide2(MeshCollisionTraversalNodeOBB<S>* node, BVHFrontList* front_list = nullptr);
 
 /// @brief special collision on RSS traversal node
 template <typename S>
-FCL_EXPORT
 void collide2(MeshCollisionTraversalNodeRSS<S>* node, BVHFrontList* front_list = nullptr);
 
 } // namespace detail
diff --git a/include/fcl/narrowphase/detail/traversal/distance/bvh_distance_traversal_node.h b/include/fcl/narrowphase/detail/traversal/distance/bvh_distance_traversal_node.h
index d56cbe2..5310bdd 100644
--- a/include/fcl/narrowphase/detail/traversal/distance/bvh_distance_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/distance/bvh_distance_traversal_node.h
@@ -50,7 +50,7 @@ namespace detail
 
 /// @brief Traversal node for distance computation between BVH models
 template <typename BV>
-class FCL_EXPORT BVHDistanceTraversalNode
+class BVHDistanceTraversalNode
     : public DistanceTraversalNodeBase<typename BV::S>
 {
 public:
diff --git a/include/fcl/narrowphase/detail/traversal/distance/bvh_shape_distance_traversal_node.h b/include/fcl/narrowphase/detail/traversal/distance/bvh_shape_distance_traversal_node.h
index 50f4fc2..8231fc9 100644
--- a/include/fcl/narrowphase/detail/traversal/distance/bvh_shape_distance_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/distance/bvh_shape_distance_traversal_node.h
@@ -49,7 +49,7 @@ namespace detail
 
 /// @brief Traversal node for distance computation between BVH and shape
 template<typename BV, typename Shape>
-class FCL_EXPORT BVHShapeDistanceTraversalNode
+class BVHShapeDistanceTraversalNode
     : public DistanceTraversalNodeBase<typename BV::S>
 {
 public:
diff --git a/include/fcl/narrowphase/detail/traversal/distance/conservative_advancement_stack_data-inl.h b/include/fcl/narrowphase/detail/traversal/distance/conservative_advancement_stack_data-inl.h
index 9c567ac..51a2493 100644
--- a/include/fcl/narrowphase/detail/traversal/distance/conservative_advancement_stack_data-inl.h
+++ b/include/fcl/narrowphase/detail/traversal/distance/conservative_advancement_stack_data-inl.h
@@ -48,7 +48,7 @@ namespace detail
 
 //==============================================================================
 extern template
-struct ConservativeAdvancementStackData<double>;
+struct FCL_EXPORT ConservativeAdvancementStackData<double>;
 
 //==============================================================================
 template <typename S>
diff --git a/include/fcl/narrowphase/detail/traversal/distance/conservative_advancement_stack_data.h b/include/fcl/narrowphase/detail/traversal/distance/conservative_advancement_stack_data.h
index fb95a94..b372f84 100644
--- a/include/fcl/narrowphase/detail/traversal/distance/conservative_advancement_stack_data.h
+++ b/include/fcl/narrowphase/detail/traversal/distance/conservative_advancement_stack_data.h
@@ -47,7 +47,7 @@ namespace detail
 {
 
 template <typename S>
-struct FCL_EXPORT ConservativeAdvancementStackData
+struct ConservativeAdvancementStackData
 {
   ConservativeAdvancementStackData(
       const Vector3<S>& P1_,
diff --git a/include/fcl/narrowphase/detail/traversal/distance/distance_traversal_node_base.h b/include/fcl/narrowphase/detail/traversal/distance/distance_traversal_node_base.h
index e4a69a2..72437ed 100644
--- a/include/fcl/narrowphase/detail/traversal/distance/distance_traversal_node_base.h
+++ b/include/fcl/narrowphase/detail/traversal/distance/distance_traversal_node_base.h
@@ -50,7 +50,7 @@ namespace detail
 
 /// @brief Node structure encoding the information required for distance traversal.
 template <typename S>
-class FCL_EXPORT DistanceTraversalNodeBase : public TraversalNodeBase<S>
+class DistanceTraversalNodeBase : public TraversalNodeBase<S>
 {
 public:
   DistanceTraversalNodeBase();
diff --git a/include/fcl/narrowphase/detail/traversal/distance/mesh_conservative_advancement_traversal_node-inl.h b/include/fcl/narrowphase/detail/traversal/distance/mesh_conservative_advancement_traversal_node-inl.h
index 44ddde5..437bb52 100644
--- a/include/fcl/narrowphase/detail/traversal/distance/mesh_conservative_advancement_traversal_node-inl.h
+++ b/include/fcl/narrowphase/detail/traversal/distance/mesh_conservative_advancement_traversal_node-inl.h
@@ -55,6 +55,7 @@ class FCL_EXPORT MeshConservativeAdvancementTraversalNodeRSS<double>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool initialize(
     MeshConservativeAdvancementTraversalNodeRSS<double>& node,
     const BVHModel<RSS<double>>& model1,
@@ -69,6 +70,7 @@ class FCL_EXPORT MeshConservativeAdvancementTraversalNodeOBBRSS<double>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool initialize(
     MeshConservativeAdvancementTraversalNodeOBBRSS<double>& node,
     const BVHModel<OBBRSS<double>>& model1,
diff --git a/include/fcl/narrowphase/detail/traversal/distance/mesh_conservative_advancement_traversal_node.h b/include/fcl/narrowphase/detail/traversal/distance/mesh_conservative_advancement_traversal_node.h
index be72620..a1cbfcd 100644
--- a/include/fcl/narrowphase/detail/traversal/distance/mesh_conservative_advancement_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/distance/mesh_conservative_advancement_traversal_node.h
@@ -50,7 +50,7 @@ namespace detail
 
 /// @brief continuous collision node using conservative advancement. when using this default version, must refit the BVH in current configuration (R_t, T_t) into default configuration
 template <typename BV>
-class FCL_EXPORT MeshConservativeAdvancementTraversalNode
+class MeshConservativeAdvancementTraversalNode
     : public MeshDistanceTraversalNode<BV>
 {
 public:
@@ -69,9 +69,9 @@ public:
   bool canStop(S c) const;
 
   mutable S min_distance;
- 
+
   mutable Vector3<S> closest_p1, closest_p2;
-  
+
   mutable int last_tri_id1, last_tri_id2;
 
   /// @brief CA controlling variable: early stop for the early iterations of CA
@@ -97,7 +97,6 @@ public:
 /// @brief Initialize traversal node for conservative advancement computation
 /// between two meshes, given the current transforms
 template <typename BV>
-FCL_EXPORT
 bool initialize(
     MeshConservativeAdvancementTraversalNode<BV>& node,
     BVHModel<BV>& model1,
@@ -109,7 +108,7 @@ bool initialize(
     bool refit_bottomup = false);
 
 template <typename S>
-class FCL_EXPORT MeshConservativeAdvancementTraversalNodeRSS
+class MeshConservativeAdvancementTraversalNodeRSS
     : public MeshConservativeAdvancementTraversalNode<RSS<S>>
 {
 public:
@@ -150,7 +149,6 @@ using MeshConservativeAdvancementTraversalNodeRSSd = MeshConservativeAdvancement
 /// @brief Initialize traversal node for conservative advancement computation
 /// between two meshes, given the current transforms, specialized for RSS
 template <typename S>
-FCL_EXPORT
 bool initialize(
     MeshConservativeAdvancementTraversalNodeRSS<S>& node,
     const BVHModel<RSS<S>>& model1,
@@ -160,7 +158,7 @@ bool initialize(
     S w = 1);
 
 template <typename S>
-class FCL_EXPORT MeshConservativeAdvancementTraversalNodeOBBRSS
+class MeshConservativeAdvancementTraversalNodeOBBRSS
     : public MeshConservativeAdvancementTraversalNode<OBBRSS<S>>
 {
 public:
@@ -199,7 +197,6 @@ using MeshConservativeAdvancementTraversalNodeOBBRSSf = MeshConservativeAdvancem
 using MeshConservativeAdvancementTraversalNodeOBBRSSd = MeshConservativeAdvancementTraversalNodeOBBRSS<double>;
 
 template <typename S>
-FCL_EXPORT
 bool initialize(
     MeshConservativeAdvancementTraversalNodeOBBRSS<S>& node,
     const BVHModel<OBBRSS<S>>& model1,
@@ -209,11 +206,9 @@ bool initialize(
     S w = 1);
 
 template <typename S, typename BV>
-FCL_EXPORT
 const Vector3<S> getBVAxis(const BV& bv, int i);
 
 template <typename BV>
-FCL_EXPORT
 bool meshConservativeAdvancementTraversalNodeCanStop(
     typename BV::S c,
     typename BV::S min_distance,
@@ -228,7 +223,6 @@ bool meshConservativeAdvancementTraversalNodeCanStop(
     typename BV::S& delta_t);
 
 template <typename BV>
-FCL_EXPORT
 bool meshConservativeAdvancementOrientedNodeCanStop(
     typename BV::S c,
     typename BV::S min_distance,
@@ -243,7 +237,6 @@ bool meshConservativeAdvancementOrientedNodeCanStop(
     typename BV::S& delta_t);
 
 template <typename BV>
-FCL_EXPORT
 void meshConservativeAdvancementOrientedNodeLeafTesting(
     int b1,
     int b2,
diff --git a/include/fcl/narrowphase/detail/traversal/distance/mesh_distance_traversal_node-inl.h b/include/fcl/narrowphase/detail/traversal/distance/mesh_distance_traversal_node-inl.h
index 558149d..dbbc0c5 100644
--- a/include/fcl/narrowphase/detail/traversal/distance/mesh_distance_traversal_node-inl.h
+++ b/include/fcl/narrowphase/detail/traversal/distance/mesh_distance_traversal_node-inl.h
@@ -52,6 +52,7 @@ class FCL_EXPORT MeshDistanceTraversalNodeRSS<double>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool initialize(
     MeshDistanceTraversalNodeRSS<double>& node,
     const BVHModel<RSS<double>>& model1,
@@ -67,6 +68,7 @@ class FCL_EXPORT MeshDistanceTraversalNodekIOS<double>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool initialize(
     MeshDistanceTraversalNodekIOS<double>& node,
     const BVHModel<kIOS<double>>& model1,
@@ -82,6 +84,7 @@ class FCL_EXPORT MeshDistanceTraversalNodeOBBRSS<double>;
 
 //==============================================================================
 extern template
+FCL_EXPORT
 bool initialize(
     MeshDistanceTraversalNodeOBBRSS<double>& node,
     const BVHModel<OBBRSS<double>>& model1,
diff --git a/include/fcl/narrowphase/detail/traversal/distance/mesh_distance_traversal_node.h b/include/fcl/narrowphase/detail/traversal/distance/mesh_distance_traversal_node.h
index 92f4461..acd6a2a 100644
--- a/include/fcl/narrowphase/detail/traversal/distance/mesh_distance_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/distance/mesh_distance_traversal_node.h
@@ -52,7 +52,7 @@ namespace detail
 
 /// @brief Traversal node for distance computation between two meshes
 template <typename BV>
-class FCL_EXPORT MeshDistanceTraversalNode : public BVHDistanceTraversalNode<BV>
+class MeshDistanceTraversalNode : public BVHDistanceTraversalNode<BV>
 {
 public:
 
@@ -80,7 +80,6 @@ public:
 /// @brief Initialize traversal node for distance computation between two
 /// meshes, given the current transforms
 template <typename BV>
-FCL_EXPORT
 bool initialize(
     MeshDistanceTraversalNode<BV>& node,
     BVHModel<BV>& model1,
@@ -93,7 +92,7 @@ bool initialize(
 
 /// @brief Traversal node for distance computation between two meshes if their underlying BVH node is oriented node (RSS, OBBRSS, kIOS)
 template <typename S>
-class FCL_EXPORT MeshDistanceTraversalNodeRSS
+class MeshDistanceTraversalNodeRSS
     : public MeshDistanceTraversalNode<RSS<S>>
 {
 public:
@@ -123,7 +122,6 @@ using MeshDistanceTraversalNodeRSSd = MeshDistanceTraversalNodeRSS<double>;
 /// @brief Initialize traversal node for distance computation between two
 ///  meshes, specialized for RSS type
 template <typename S>
-FCL_EXPORT
 bool initialize(
     MeshDistanceTraversalNodeRSS<S>& node,
     const BVHModel<RSS<S>>& model1,
@@ -134,14 +132,14 @@ bool initialize(
     DistanceResult<S>& result);
 
 template <typename S>
-class FCL_EXPORT MeshDistanceTraversalNodekIOS
+class MeshDistanceTraversalNodekIOS
     : public MeshDistanceTraversalNode<kIOS<S>>
 {
 public:
   MeshDistanceTraversalNodekIOS();
 
   void preprocess();
-  
+
   void postprocess();
 
   S BVTesting(int b1, int b2) const
@@ -164,7 +162,6 @@ using MeshDistanceTraversalNodekIOSd = MeshDistanceTraversalNodekIOS<double>;
 /// @brief Initialize traversal node for distance computation between two
 ///  meshes, specialized for kIOS type
 template <typename S>
-FCL_EXPORT
 bool initialize(
     MeshDistanceTraversalNodekIOS<S>& node,
     const BVHModel<kIOS<S>>& model1,
@@ -175,7 +172,7 @@ bool initialize(
     DistanceResult<S>& result);
 
 template <typename S>
-class FCL_EXPORT MeshDistanceTraversalNodeOBBRSS
+class MeshDistanceTraversalNodeOBBRSS
     : public MeshDistanceTraversalNode<OBBRSS<S>>
 {
 public:
@@ -205,7 +202,6 @@ using MeshDistanceTraversalNodeOBBRSSd = MeshDistanceTraversalNodeOBBRSS<double>
 /// @brief Initialize traversal node for distance computation between two
 ///  meshes, specialized for OBBRSS type
 template <typename S>
-FCL_EXPORT
 bool initialize(
     MeshDistanceTraversalNodeOBBRSS<S>& node,
     const BVHModel<OBBRSS<S>>& model1,
@@ -216,7 +212,6 @@ bool initialize(
     DistanceResult<S>& result);
 
 template <typename BV>
-FCL_DEPRECATED_EXPORT
 void meshDistanceOrientedNodeLeafTesting(
     int b1,
     int b2,
@@ -234,7 +229,6 @@ void meshDistanceOrientedNodeLeafTesting(
     DistanceResult<typename BV::S>& result);
 
 template <typename BV>
-FCL_EXPORT
 void meshDistanceOrientedNodeLeafTesting(
     int b1,
     int b2,
@@ -251,7 +245,6 @@ void meshDistanceOrientedNodeLeafTesting(
     DistanceResult<typename BV::S>& result);
 
 template <typename BV>
-FCL_EXPORT
 void distancePreprocessOrientedNode(
     const BVHModel<BV>* model1,
     const BVHModel<BV>* model2,
@@ -267,7 +260,6 @@ void distancePreprocessOrientedNode(
     DistanceResult<typename BV::S>& result);
 
 template <typename BV>
-FCL_EXPORT
 void distancePreprocessOrientedNode(
     const BVHModel<BV>* model1,
     const BVHModel<BV>* model2,
@@ -282,7 +274,6 @@ void distancePreprocessOrientedNode(
     DistanceResult<typename BV::S>& result);
 
 template <typename BV>
-FCL_EXPORT
 void distancePostprocessOrientedNode(
     const BVHModel<BV>* model1,
     const BVHModel<BV>* model2,
diff --git a/include/fcl/narrowphase/detail/traversal/distance/mesh_shape_conservative_advancement_traversal_node.h b/include/fcl/narrowphase/detail/traversal/distance/mesh_shape_conservative_advancement_traversal_node.h
index a9f8d75..20b7e23 100644
--- a/include/fcl/narrowphase/detail/traversal/distance/mesh_shape_conservative_advancement_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/distance/mesh_shape_conservative_advancement_traversal_node.h
@@ -49,7 +49,7 @@ namespace detail
 
 /// @brief Traversal node for conservative advancement computation between BVH and shape
 template <typename BV, typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT MeshShapeConservativeAdvancementTraversalNode
+class MeshShapeConservativeAdvancementTraversalNode
     : public MeshShapeDistanceTraversalNode<BV, Shape, NarrowPhaseSolver>
 {
 public:
@@ -72,7 +72,7 @@ public:
   mutable Vector3<S> closest_p1, closest_p2;
 
   mutable int last_tri_id;
-  
+
   /// @brief CA controlling variable: early stop for the early iterations of CA
   S w;
 
@@ -140,7 +140,7 @@ bool meshShapeConservativeAdvancementOrientedNodeCanStop(
     typename BV::S& delta_t);
 
 template <typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT MeshShapeConservativeAdvancementTraversalNodeRSS
+class MeshShapeConservativeAdvancementTraversalNodeRSS
     : public MeshShapeConservativeAdvancementTraversalNode<
     RSS<typename Shape::S>, Shape, NarrowPhaseSolver>
 {
@@ -168,7 +168,7 @@ bool initialize(
     typename Shape::S w = 1);
 
 template <typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT MeshShapeConservativeAdvancementTraversalNodeOBBRSS :
+class MeshShapeConservativeAdvancementTraversalNodeOBBRSS :
     public MeshShapeConservativeAdvancementTraversalNode<
     OBBRSS<typename Shape::S>, Shape, NarrowPhaseSolver>
 {
diff --git a/include/fcl/narrowphase/detail/traversal/distance/mesh_shape_distance_traversal_node.h b/include/fcl/narrowphase/detail/traversal/distance/mesh_shape_distance_traversal_node.h
index 0d40e2e..79c5fde 100644
--- a/include/fcl/narrowphase/detail/traversal/distance/mesh_shape_distance_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/distance/mesh_shape_distance_traversal_node.h
@@ -49,9 +49,9 @@ namespace detail
 
 /// @brief Traversal node for distance between mesh and shape
 template <typename BV, typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT MeshShapeDistanceTraversalNode
+class MeshShapeDistanceTraversalNode
     : public BVHShapeDistanceTraversalNode<BV, Shape>
-{ 
+{
 public:
 
   using S = typename BV::S;
@@ -69,7 +69,7 @@ public:
 
   S rel_err;
   S abs_err;
-    
+
   const NarrowPhaseSolver* nsolver;
 };
 
@@ -118,7 +118,7 @@ bool initialize(
 
 /// @brief Traversal node for distance between mesh and shape, when mesh BVH is one of the oriented node (RSS, OBBRSS, kIOS)
 template <typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT MeshShapeDistanceTraversalNodeRSS
+class MeshShapeDistanceTraversalNodeRSS
     : public MeshShapeDistanceTraversalNode<
     RSS<typename Shape::S>, Shape, NarrowPhaseSolver>
 {
@@ -148,7 +148,7 @@ bool initialize(
     DistanceResult<typename Shape::S>& result);
 
 template <typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT MeshShapeDistanceTraversalNodekIOS
+class MeshShapeDistanceTraversalNodekIOS
     : public MeshShapeDistanceTraversalNode<kIOS<typename Shape::S>, Shape, NarrowPhaseSolver>
 {
 public:
@@ -177,7 +177,7 @@ bool initialize(
     DistanceResult<typename Shape::S>& result);
 
 template <typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT MeshShapeDistanceTraversalNodeOBBRSS
+class MeshShapeDistanceTraversalNodeOBBRSS
     : public MeshShapeDistanceTraversalNode<OBBRSS<typename Shape::S>, Shape, NarrowPhaseSolver>
 {
 public:
@@ -192,7 +192,7 @@ public:
   S BVTesting(int b1, int b2) const;
 
   void leafTesting(int b1, int b2) const;
-  
+
 };
 
 /// @brief Initialize traversal node for distance computation between one mesh and one shape, specialized for OBBRSS type
diff --git a/include/fcl/narrowphase/detail/traversal/distance/shape_bvh_distance_traversal_node.h b/include/fcl/narrowphase/detail/traversal/distance/shape_bvh_distance_traversal_node.h
index 53176cf..05ae2c1 100644
--- a/include/fcl/narrowphase/detail/traversal/distance/shape_bvh_distance_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/distance/shape_bvh_distance_traversal_node.h
@@ -50,7 +50,7 @@ namespace detail
 
 /// @brief Traversal node for distance computation between shape and BVH
 template<typename Shape, typename BV>
-class FCL_EXPORT ShapeBVHDistanceTraversalNode
+class ShapeBVHDistanceTraversalNode
     : public DistanceTraversalNodeBase<typename BV::S>
 {
 public:
@@ -74,7 +74,7 @@ public:
   const Shape* model1;
   const BVHModel<BV>* model2;
   BV model1_bv;
-  
+
   mutable int num_bv_tests;
   mutable int num_leaf_tests;
   mutable S query_time_seconds;
diff --git a/include/fcl/narrowphase/detail/traversal/distance/shape_conservative_advancement_traversal_node.h b/include/fcl/narrowphase/detail/traversal/distance/shape_conservative_advancement_traversal_node.h
index 525df72..3e92008 100644
--- a/include/fcl/narrowphase/detail/traversal/distance/shape_conservative_advancement_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/distance/shape_conservative_advancement_traversal_node.h
@@ -47,7 +47,7 @@ namespace detail
 {
 
 template<typename Shape1, typename Shape2, typename NarrowPhaseSolver>
-class FCL_EXPORT ShapeConservativeAdvancementTraversalNode
+class ShapeConservativeAdvancementTraversalNode
     : public ShapeDistanceTraversalNode<Shape1, Shape2, NarrowPhaseSolver>
 {
 public:
diff --git a/include/fcl/narrowphase/detail/traversal/distance/shape_distance_traversal_node.h b/include/fcl/narrowphase/detail/traversal/distance/shape_distance_traversal_node.h
index bfd1e1f..ad74992 100644
--- a/include/fcl/narrowphase/detail/traversal/distance/shape_distance_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/distance/shape_distance_traversal_node.h
@@ -49,7 +49,7 @@ namespace detail
 
 /// @brief Traversal node for distance between two shapes
 template<typename Shape1, typename Shape2, typename NarrowPhaseSolver>
-class FCL_EXPORT ShapeDistanceTraversalNode
+class ShapeDistanceTraversalNode
     : public DistanceTraversalNodeBase<typename Shape1::S>
 {
 public:
diff --git a/include/fcl/narrowphase/detail/traversal/distance/shape_mesh_conservative_advancement_traversal_node.h b/include/fcl/narrowphase/detail/traversal/distance/shape_mesh_conservative_advancement_traversal_node.h
index bf54940..01b5995 100644
--- a/include/fcl/narrowphase/detail/traversal/distance/shape_mesh_conservative_advancement_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/distance/shape_mesh_conservative_advancement_traversal_node.h
@@ -49,7 +49,7 @@ namespace detail
 {
 
 template <typename Shape, typename BV, typename NarrowPhaseSolver>
-class FCL_EXPORT ShapeMeshConservativeAdvancementTraversalNode
+class ShapeMeshConservativeAdvancementTraversalNode
     : public ShapeMeshDistanceTraversalNode<Shape, BV, NarrowPhaseSolver>
 {
 public:
@@ -72,7 +72,7 @@ public:
   mutable Vector3<S> closest_p1, closest_p2;
 
   mutable int last_tri_id;
-  
+
    /// @brief CA controlling variable: early stop for the early iterations of CA
   S w;
 
@@ -103,7 +103,7 @@ bool initialize(
     bool refit_bottomup = false);
 
 template <typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT ShapeMeshConservativeAdvancementTraversalNodeRSS
+class ShapeMeshConservativeAdvancementTraversalNodeRSS
     : public ShapeMeshConservativeAdvancementTraversalNode<
     Shape, RSS<typename Shape::S>, NarrowPhaseSolver>
 {
@@ -130,7 +130,7 @@ bool initialize(
     typename Shape::S w = 1);
 
 template <typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT ShapeMeshConservativeAdvancementTraversalNodeOBBRSS
+class ShapeMeshConservativeAdvancementTraversalNodeOBBRSS
     : public ShapeMeshConservativeAdvancementTraversalNode<
     Shape, OBBRSS<typename Shape::S>, NarrowPhaseSolver>
 {
diff --git a/include/fcl/narrowphase/detail/traversal/distance/shape_mesh_distance_traversal_node-inl.h b/include/fcl/narrowphase/detail/traversal/distance/shape_mesh_distance_traversal_node-inl.h
index cdf8c8d..c059ed1 100644
--- a/include/fcl/narrowphase/detail/traversal/distance/shape_mesh_distance_traversal_node-inl.h
+++ b/include/fcl/narrowphase/detail/traversal/distance/shape_mesh_distance_traversal_node-inl.h
@@ -108,7 +108,6 @@ bool ShapeMeshDistanceTraversalNode<Shape, BV, NarrowPhaseSolver>::canStop(S c)
 
 //==============================================================================
 template <typename Shape, typename BV, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool initialize(
     ShapeMeshDistanceTraversalNode<Shape, BV, NarrowPhaseSolver>& node,
     const Shape& model1,
@@ -349,7 +348,6 @@ static bool setupShapeMeshDistanceOrientedNode(OrientedNode<Shape, NarrowPhaseSo
 
 //==============================================================================
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool initialize(ShapeMeshDistanceTraversalNodeRSS<Shape, NarrowPhaseSolver>& node,
                 const Shape& model1, const Transform3<typename Shape::S>& tf1,
                 const BVHModel<RSS<typename Shape::S>>& model2, const Transform3<typename Shape::S>& tf2,
@@ -362,7 +360,6 @@ bool initialize(ShapeMeshDistanceTraversalNodeRSS<Shape, NarrowPhaseSolver>& nod
 
 //==============================================================================
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool initialize(ShapeMeshDistanceTraversalNodekIOS<Shape, NarrowPhaseSolver>& node,
                 const Shape& model1, const Transform3<typename Shape::S>& tf1,
                 const BVHModel<kIOS<typename Shape::S>>& model2, const Transform3<typename Shape::S>& tf2,
@@ -375,7 +372,6 @@ bool initialize(ShapeMeshDistanceTraversalNodekIOS<Shape, NarrowPhaseSolver>& no
 
 //==============================================================================
 template <typename Shape, typename NarrowPhaseSolver>
-FCL_EXPORT
 bool initialize(ShapeMeshDistanceTraversalNodeOBBRSS<Shape, NarrowPhaseSolver>& node,
                 const Shape& model1, const Transform3<typename Shape::S>& tf1,
                 const BVHModel<OBBRSS<typename Shape::S>>& model2, const Transform3<typename Shape::S>& tf2,
diff --git a/include/fcl/narrowphase/detail/traversal/distance/shape_mesh_distance_traversal_node.h b/include/fcl/narrowphase/detail/traversal/distance/shape_mesh_distance_traversal_node.h
index 438f205..a90c007 100644
--- a/include/fcl/narrowphase/detail/traversal/distance/shape_mesh_distance_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/distance/shape_mesh_distance_traversal_node.h
@@ -49,9 +49,9 @@ namespace detail
 
 /// @brief Traversal node for distance between shape and mesh
 template <typename Shape, typename BV, typename NarrowPhaseSolver>
-class FCL_EXPORT ShapeMeshDistanceTraversalNode
+class ShapeMeshDistanceTraversalNode
     : public ShapeBVHDistanceTraversalNode<Shape, BV>
-{ 
+{
 public:
 
   using S = typename BV::S;
@@ -69,7 +69,7 @@ public:
 
   S rel_err;
   S abs_err;
-    
+
   const NarrowPhaseSolver* nsolver;
 };
 
@@ -89,7 +89,7 @@ bool initialize(
     bool refit_bottomup = false);
 
 template <typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT ShapeMeshDistanceTraversalNodeRSS
+class ShapeMeshDistanceTraversalNodeRSS
     : public ShapeMeshDistanceTraversalNode<
     Shape, RSS<typename Shape::S>, NarrowPhaseSolver>
 {
@@ -123,7 +123,7 @@ bool initialize(
     DistanceResult<typename Shape::S>& result);
 
 template <typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT ShapeMeshDistanceTraversalNodekIOS
+class ShapeMeshDistanceTraversalNodekIOS
     : public ShapeMeshDistanceTraversalNode<
     Shape, kIOS<typename Shape::S>, NarrowPhaseSolver>
 {
@@ -140,7 +140,7 @@ public:
   S BVTesting(int b1, int b2) const;
 
   void leafTesting(int b1, int b2) const;
-  
+
 };
 
 /// @brief Initialize traversal node for distance computation between one shape
@@ -157,7 +157,7 @@ bool initialize(
     DistanceResult<typename Shape::S>& result);
 
 template <typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT ShapeMeshDistanceTraversalNodeOBBRSS
+class ShapeMeshDistanceTraversalNodeOBBRSS
     : public ShapeMeshDistanceTraversalNode<
     Shape, OBBRSS<typename Shape::S>, NarrowPhaseSolver>
 {
@@ -174,7 +174,7 @@ public:
   S BVTesting(int b1, int b2) const;
 
   void leafTesting(int b1, int b2) const;
-  
+
 };
 
 /// @brief Initialize traversal node for distance computation between one shape
diff --git a/include/fcl/narrowphase/detail/traversal/octree/collision/mesh_octree_collision_traversal_node.h b/include/fcl/narrowphase/detail/traversal/octree/collision/mesh_octree_collision_traversal_node.h
index 2792dd2..f060a66 100644
--- a/include/fcl/narrowphase/detail/traversal/octree/collision/mesh_octree_collision_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/octree/collision/mesh_octree_collision_traversal_node.h
@@ -56,7 +56,7 @@ namespace detail
 
 /// @brief Traversal node for mesh-octree collision
 template <typename BV, typename NarrowPhaseSolver>
-class FCL_EXPORT MeshOcTreeCollisionTraversalNode
+class MeshOcTreeCollisionTraversalNode
     : public CollisionTraversalNodeBase<typename BV::S>
 {
 public:
diff --git a/include/fcl/narrowphase/detail/traversal/octree/collision/octree_collision_traversal_node.h b/include/fcl/narrowphase/detail/traversal/octree/collision/octree_collision_traversal_node.h
index b122459..7692db9 100644
--- a/include/fcl/narrowphase/detail/traversal/octree/collision/octree_collision_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/octree/collision/octree_collision_traversal_node.h
@@ -55,7 +55,7 @@ namespace detail
 
 /// @brief Traversal node for octree collision
 template <typename NarrowPhaseSolver>
-class FCL_EXPORT OcTreeCollisionTraversalNode
+class OcTreeCollisionTraversalNode
     : public CollisionTraversalNodeBase<typename NarrowPhaseSolver::S>
 {
 public:
diff --git a/include/fcl/narrowphase/detail/traversal/octree/collision/octree_mesh_collision_traversal_node.h b/include/fcl/narrowphase/detail/traversal/octree/collision/octree_mesh_collision_traversal_node.h
index 304a9cb..7c16d8f 100644
--- a/include/fcl/narrowphase/detail/traversal/octree/collision/octree_mesh_collision_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/octree/collision/octree_mesh_collision_traversal_node.h
@@ -56,7 +56,7 @@ namespace detail
 
 /// @brief Traversal node for octree-mesh collision
 template <typename BV, typename NarrowPhaseSolver>
-class FCL_EXPORT OcTreeMeshCollisionTraversalNode
+class OcTreeMeshCollisionTraversalNode
     : public CollisionTraversalNodeBase<typename BV::S>
 {
 public:
diff --git a/include/fcl/narrowphase/detail/traversal/octree/collision/octree_shape_collision_traversal_node.h b/include/fcl/narrowphase/detail/traversal/octree/collision/octree_shape_collision_traversal_node.h
index 93b53ab..36962ba 100644
--- a/include/fcl/narrowphase/detail/traversal/octree/collision/octree_shape_collision_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/octree/collision/octree_shape_collision_traversal_node.h
@@ -56,7 +56,7 @@ namespace detail
 
 /// @brief Traversal node for octree-shape collision
 template <typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT OcTreeShapeCollisionTraversalNode
+class OcTreeShapeCollisionTraversalNode
     : public CollisionTraversalNodeBase<typename Shape::S>
 {
 public:
diff --git a/include/fcl/narrowphase/detail/traversal/octree/collision/shape_octree_collision_traversal_node.h b/include/fcl/narrowphase/detail/traversal/octree/collision/shape_octree_collision_traversal_node.h
index 147de06..998b152 100644
--- a/include/fcl/narrowphase/detail/traversal/octree/collision/shape_octree_collision_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/octree/collision/shape_octree_collision_traversal_node.h
@@ -56,7 +56,7 @@ namespace detail
 
 /// @brief Traversal node for shape-octree collision
 template <typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT ShapeOcTreeCollisionTraversalNode
+class ShapeOcTreeCollisionTraversalNode
     : public CollisionTraversalNodeBase<typename Shape::S>
 {
 public:
diff --git a/include/fcl/narrowphase/detail/traversal/octree/distance/mesh_octree_distance_traversal_node.h b/include/fcl/narrowphase/detail/traversal/octree/distance/mesh_octree_distance_traversal_node.h
index b299e78..cafb22e 100644
--- a/include/fcl/narrowphase/detail/traversal/octree/distance/mesh_octree_distance_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/octree/distance/mesh_octree_distance_traversal_node.h
@@ -56,7 +56,7 @@ namespace detail
 
 /// @brief Traversal node for mesh-octree distance
 template <typename BV, typename NarrowPhaseSolver>
-class FCL_EXPORT MeshOcTreeDistanceTraversalNode
+class MeshOcTreeDistanceTraversalNode
     : public DistanceTraversalNodeBase<typename BV::S>
 {
 public:
diff --git a/include/fcl/narrowphase/detail/traversal/octree/distance/octree_distance_traversal_node.h b/include/fcl/narrowphase/detail/traversal/octree/distance/octree_distance_traversal_node.h
index 2df8424..3fc223c 100644
--- a/include/fcl/narrowphase/detail/traversal/octree/distance/octree_distance_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/octree/distance/octree_distance_traversal_node.h
@@ -55,7 +55,7 @@ namespace detail
 
 /// @brief Traversal node for octree distance
 template <typename NarrowPhaseSolver>
-class FCL_EXPORT OcTreeDistanceTraversalNode
+class OcTreeDistanceTraversalNode
     : public DistanceTraversalNodeBase<typename NarrowPhaseSolver::S>
 {
 public:
diff --git a/include/fcl/narrowphase/detail/traversal/octree/distance/octree_mesh_distance_traversal_node.h b/include/fcl/narrowphase/detail/traversal/octree/distance/octree_mesh_distance_traversal_node.h
index 5ac1cc2..c1fbfeb 100644
--- a/include/fcl/narrowphase/detail/traversal/octree/distance/octree_mesh_distance_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/octree/distance/octree_mesh_distance_traversal_node.h
@@ -56,7 +56,7 @@ namespace detail
 
 /// @brief Traversal node for octree-mesh distance
 template <typename BV, typename NarrowPhaseSolver>
-class FCL_EXPORT OcTreeMeshDistanceTraversalNode
+class OcTreeMeshDistanceTraversalNode
     : public DistanceTraversalNodeBase<typename BV::S>
 {
 public:
diff --git a/include/fcl/narrowphase/detail/traversal/octree/distance/octree_shape_distance_traversal_node.h b/include/fcl/narrowphase/detail/traversal/octree/distance/octree_shape_distance_traversal_node.h
index 482f5f8..b9bebf5 100644
--- a/include/fcl/narrowphase/detail/traversal/octree/distance/octree_shape_distance_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/octree/distance/octree_shape_distance_traversal_node.h
@@ -56,7 +56,7 @@ namespace detail
 
 /// @brief Traversal node for octree-shape distance
 template <typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT OcTreeShapeDistanceTraversalNode
+class OcTreeShapeDistanceTraversalNode
     : public DistanceTraversalNodeBase<typename Shape::S>
 {
 public:
diff --git a/include/fcl/narrowphase/detail/traversal/octree/distance/shape_octree_distance_traversal_node.h b/include/fcl/narrowphase/detail/traversal/octree/distance/shape_octree_distance_traversal_node.h
index 02b3547..06d2da6 100644
--- a/include/fcl/narrowphase/detail/traversal/octree/distance/shape_octree_distance_traversal_node.h
+++ b/include/fcl/narrowphase/detail/traversal/octree/distance/shape_octree_distance_traversal_node.h
@@ -56,7 +56,7 @@ namespace detail
 
 /// @brief Traversal node for shape-octree distance
 template <typename Shape, typename NarrowPhaseSolver>
-class FCL_EXPORT ShapeOcTreeDistanceTraversalNode
+class ShapeOcTreeDistanceTraversalNode
     : public DistanceTraversalNodeBase<typename Shape::S>
 {
 public:
diff --git a/include/fcl/narrowphase/detail/traversal/octree/octree_solver.h b/include/fcl/narrowphase/detail/traversal/octree/octree_solver.h
index 4159742..1446012 100644
--- a/include/fcl/narrowphase/detail/traversal/octree/octree_solver.h
+++ b/include/fcl/narrowphase/detail/traversal/octree/octree_solver.h
@@ -56,7 +56,7 @@ namespace detail
 
 /// @brief Algorithms for collision related with octree
 template <typename NarrowPhaseSolver>
-class FCL_EXPORT OcTreeSolver
+class OcTreeSolver
 {
 private:
 
diff --git a/include/fcl/narrowphase/detail/traversal/traversal_node_base.h b/include/fcl/narrowphase/detail/traversal/traversal_node_base.h
index 2f3b187..93cd7f0 100644
--- a/include/fcl/narrowphase/detail/traversal/traversal_node_base.h
+++ b/include/fcl/narrowphase/detail/traversal/traversal_node_base.h
@@ -48,16 +48,16 @@ namespace detail
 
 /// @brief Node structure encoding the information required for traversal.
 template <typename S>
-class FCL_EXPORT TraversalNodeBase
+class TraversalNodeBase
 {
 public:
   virtual ~TraversalNodeBase();
 
   virtual void preprocess();
-  
+
   virtual void postprocess();
 
-  /// @brief Whether b is a leaf node in the first BVH tree 
+  /// @brief Whether b is a leaf node in the first BVH tree
   virtual bool isFirstNodeLeaf(int b) const;
 
   /// @brief Whether b is a leaf node in the second BVH tree
diff --git a/include/fcl/narrowphase/detail/traversal/traversal_recurse-inl.h b/include/fcl/narrowphase/detail/traversal/traversal_recurse-inl.h
index 1c46c1c..7c55918 100644
--- a/include/fcl/narrowphase/detail/traversal/traversal_recurse-inl.h
+++ b/include/fcl/narrowphase/detail/traversal/traversal_recurse-inl.h
@@ -52,35 +52,41 @@ namespace detail
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void collisionRecurse(CollisionTraversalNodeBase<double>* node, int b1, int b2, BVHFrontList* front_list);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void collisionRecurse(MeshCollisionTraversalNodeOBB<double>* node, int b1, int b2, const Matrix3<double>& R, const Vector3<double>& T, BVHFrontList* front_list);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void collisionRecurse(MeshCollisionTraversalNodeRSS<double>* node, int b1, int b2, const Matrix3<double>& R, const Vector3<double>& T, BVHFrontList* front_list);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void selfCollisionRecurse(CollisionTraversalNodeBase<double>* node, int b, BVHFrontList* front_list);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void distanceRecurse(DistanceTraversalNodeBase<double>* node, int b1, int b2, BVHFrontList* front_list);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void distanceQueueRecurse(DistanceTraversalNodeBase<double>* node, int b1, int b2, BVHFrontList* front_list, int qsize);
 
 //==============================================================================
 extern template
+FCL_EXPORT
 void propagateBVHFrontListCollisionRecurse(CollisionTraversalNodeBase<double>* node, BVHFrontList* front_list);
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void collisionRecurse(CollisionTraversalNodeBase<S>* node, int b1, int b2, BVHFrontList* front_list)
 {
   bool l1 = node->isFirstNodeLeaf(b1);
@@ -130,7 +136,6 @@ void collisionRecurse(CollisionTraversalNodeBase<S>* node, int b1, int b2, BVHFr
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void collisionRecurse(MeshCollisionTraversalNodeOBB<S>* node, int b1, int b2, const Matrix3<S>& R, const Vector3<S>& T, BVHFrontList* front_list)
 {
   bool l1 = node->isFirstNodeLeaf(b1);
@@ -216,7 +221,6 @@ void collisionRecurse(MeshCollisionTraversalNodeOBB<S>* node, int b1, int b2, co
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void collisionRecurse(MeshCollisionTraversalNodeRSS<S>* node, int b1, int b2, const Matrix3<S>& R, const Vector3<S>& T, BVHFrontList* front_list)
 {
   FCL_UNUSED(node);
@@ -234,7 +238,6 @@ void collisionRecurse(MeshCollisionTraversalNodeRSS<S>* node, int b1, int b2, co
  * Make sure node is set correctly so that the first and second tree are the same
  */
 template <typename S>
-FCL_EXPORT
 void selfCollisionRecurse(CollisionTraversalNodeBase<S>* node, int b, BVHFrontList* front_list)
 {
   bool l = node->isFirstNodeLeaf(b);
@@ -255,7 +258,6 @@ void selfCollisionRecurse(CollisionTraversalNodeBase<S>* node, int b, BVHFrontLi
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void distanceRecurse(DistanceTraversalNodeBase<S>* node, int b1, int b2, BVHFrontList* front_list)
 {
   bool l1 = node->isFirstNodeLeaf(b1);
@@ -318,7 +320,7 @@ void distanceRecurse(DistanceTraversalNodeBase<S>* node, int b1, int b2, BVHFron
 //==============================================================================
 /** @brief Bounding volume test structure */
 template <typename S>
-struct FCL_EXPORT BVT
+struct BVT
 {
   /** @brief distance between bvs */
   S d;
@@ -330,7 +332,7 @@ struct FCL_EXPORT BVT
 //==============================================================================
 /** @brief Comparer between two BVT */
 template <typename S>
-struct FCL_EXPORT BVT_Comparer
+struct BVT_Comparer
 {
   bool operator() (const BVT<S>& lhs, const BVT<S>& rhs) const
   {
@@ -340,7 +342,7 @@ struct FCL_EXPORT BVT_Comparer
 
 //==============================================================================
 template <typename S>
-struct FCL_EXPORT BVTQ
+struct BVTQ
 {
   BVTQ() : qsize(2) {}
 
@@ -382,7 +384,6 @@ struct FCL_EXPORT BVTQ
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void distanceQueueRecurse(DistanceTraversalNodeBase<S>* node, int b1, int b2, BVHFrontList* front_list, int qsize)
 {
   BVTQ<S> bvtq;
@@ -461,7 +462,6 @@ void distanceQueueRecurse(DistanceTraversalNodeBase<S>* node, int b1, int b2, BV
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void propagateBVHFrontListCollisionRecurse(CollisionTraversalNodeBase<S>* node, BVHFrontList* front_list)
 {
   BVHFrontList::iterator front_iter;
diff --git a/include/fcl/narrowphase/detail/traversal/traversal_recurse.h b/include/fcl/narrowphase/detail/traversal/traversal_recurse.h
index d586c7e..cb9316f 100644
--- a/include/fcl/narrowphase/detail/traversal/traversal_recurse.h
+++ b/include/fcl/narrowphase/detail/traversal/traversal_recurse.h
@@ -52,37 +52,30 @@ namespace detail
 
 /// @brief Recurse function for collision
 template <typename S>
-FCL_EXPORT
 void collisionRecurse(CollisionTraversalNodeBase<S>* node, int b1, int b2, BVHFrontList* front_list);
 
 /// @brief Recurse function for collision, specialized for OBB type
 template <typename S>
-FCL_EXPORT
 void collisionRecurse(MeshCollisionTraversalNodeOBB<S>* node, int b1, int b2, const Matrix3<S>& R, const Vector3<S>& T, BVHFrontList* front_list);
 
 /// @brief Recurse function for collision, specialized for RSS type
 template <typename S>
-FCL_EXPORT
 void collisionRecurse(MeshCollisionTraversalNodeRSS<S>* node, int b1, int b2, const Matrix3<S>& R, const Vector3<S>& T, BVHFrontList* front_list);
 
 /// @brief Recurse function for self collision. Make sure node is set correctly so that the first and second tree are the same
 template <typename S>
-FCL_EXPORT
 void selfCollisionRecurse(CollisionTraversalNodeBase<S>* node, int b, BVHFrontList* front_list);
 
 /// @brief Recurse function for distance
 template <typename S>
-FCL_EXPORT
 void distanceRecurse(DistanceTraversalNodeBase<S>* node, int b1, int b2, BVHFrontList* front_list);
 
 /// @brief Recurse function for distance, using queue acceleration
 template <typename S>
-FCL_EXPORT
 void distanceQueueRecurse(DistanceTraversalNodeBase<S>* node, int b1, int b2, BVHFrontList* front_list, int qsize);
 
 /// @brief Recurse function for front list propagation
 template <typename S>
-FCL_EXPORT
 void propagateBVHFrontListCollisionRecurse(CollisionTraversalNodeBase<S>* node, BVHFrontList* front_list);
 
 } // namespace detail
diff --git a/include/fcl/narrowphase/distance-inl.h b/include/fcl/narrowphase/distance-inl.h
index 115b710..a9bfc2d 100644
--- a/include/fcl/narrowphase/distance-inl.h
+++ b/include/fcl/narrowphase/distance-inl.h
@@ -47,6 +47,7 @@ namespace fcl
 
 //==============================================================================
 extern template
+FCL_EXPORT
 double distance(
     const CollisionObject<double>* o1,
     const CollisionObject<double>* o2,
@@ -55,6 +56,7 @@ double distance(
 
 //==============================================================================
 extern template
+FCL_EXPORT
 double distance(
     const CollisionGeometry<double>* o1, const Transform3<double>& tf1,
     const CollisionGeometry<double>* o2, const Transform3<double>& tf2,
diff --git a/include/fcl/narrowphase/distance.h b/include/fcl/narrowphase/distance.h
index 7629d26..9d77e52 100644
--- a/include/fcl/narrowphase/distance.h
+++ b/include/fcl/narrowphase/distance.h
@@ -46,16 +46,14 @@
 namespace fcl
 {
 
-/// @brief Main distance interface: given two collision objects, and the requirements for contacts, including whether return the nearest points, this function performs the distance between them. 
+/// @brief Main distance interface: given two collision objects, and the requirements for contacts, including whether return the nearest points, this function performs the distance between them.
 /// Return value is the minimum distance generated between the two objects.
 template <typename S>
-FCL_EXPORT
 S distance(
     const CollisionObject<S>* o1, const CollisionObject<S>* o2,
     const DistanceRequest<S>& request, DistanceResult<S>& result);
 
 template <typename S>
-FCL_EXPORT
 S distance(
     const CollisionGeometry<S>* o1, const Transform3<S>& tf1,
     const CollisionGeometry<S>* o2, const Transform3<S>& tf2,
diff --git a/include/fcl/narrowphase/distance_request-inl.h b/include/fcl/narrowphase/distance_request-inl.h
index 1c63dea..2526367 100644
--- a/include/fcl/narrowphase/distance_request-inl.h
+++ b/include/fcl/narrowphase/distance_request-inl.h
@@ -47,7 +47,7 @@ namespace fcl
 
 //==============================================================================
 extern template
-struct DistanceRequest<double>;
+struct FCL_EXPORT DistanceRequest<double>;
 
 //==============================================================================
 template <typename S>
diff --git a/include/fcl/narrowphase/distance_request.h b/include/fcl/narrowphase/distance_request.h
index c157699..8dc92a1 100644
--- a/include/fcl/narrowphase/distance_request.h
+++ b/include/fcl/narrowphase/distance_request.h
@@ -49,7 +49,7 @@ struct DistanceResult;
 
 /// @brief request to the distance computation
 template <typename S>
-struct FCL_EXPORT DistanceRequest
+struct DistanceRequest
 {
   /// @brief whether to return the nearest points
   bool enable_nearest_points;
diff --git a/include/fcl/narrowphase/distance_result-inl.h b/include/fcl/narrowphase/distance_result-inl.h
index 424cffd..98f617b 100644
--- a/include/fcl/narrowphase/distance_result-inl.h
+++ b/include/fcl/narrowphase/distance_result-inl.h
@@ -45,11 +45,10 @@ namespace fcl
 
 //==============================================================================
 extern template
-struct DistanceResult<double>;
+struct FCL_EXPORT DistanceResult<double>;
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 DistanceResult<S>::DistanceResult(S min_distance_)
   : min_distance(min_distance_),
     o1(nullptr),
@@ -62,7 +61,6 @@ DistanceResult<S>::DistanceResult(S min_distance_)
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DistanceResult<S>::update(
     S distance,
     const CollisionGeometry<S>* o1_,
@@ -82,7 +80,6 @@ void DistanceResult<S>::update(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DistanceResult<S>::update(
     S distance,
     const CollisionGeometry<S>* o1_,
@@ -106,7 +103,6 @@ void DistanceResult<S>::update(
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DistanceResult<S>::update(const DistanceResult& other_result)
 {
   if(min_distance > other_result.min_distance)
@@ -123,7 +119,6 @@ void DistanceResult<S>::update(const DistanceResult& other_result)
 
 //==============================================================================
 template <typename S>
-FCL_EXPORT
 void DistanceResult<S>::clear()
 {
   min_distance = std::numeric_limits<S>::max();
diff --git a/include/fcl/narrowphase/distance_result.h b/include/fcl/narrowphase/distance_result.h
index 045d2c8..c555858 100644
--- a/include/fcl/narrowphase/distance_result.h
+++ b/include/fcl/narrowphase/distance_result.h
@@ -48,7 +48,7 @@ class CollisionGeometry;
 
 /// @brief distance result
 template <typename S>
-struct FCL_EXPORT DistanceResult
+struct DistanceResult
 {
 public:
 
@@ -88,7 +88,7 @@ public:
 
   /// @brief invalid contact primitive information
   static const int NONE = -1;
-  
+
   DistanceResult(S min_distance_ = std::numeric_limits<S>::max());
 
   /// @brief add distance information into the result
diff --git a/src/broadphase/broadphase_SSaP.cpp b/src/broadphase/broadphase_SSaP.cpp
index dc92716..17812f8 100644
--- a/src/broadphase/broadphase_SSaP.cpp
+++ b/src/broadphase/broadphase_SSaP.cpp
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class SSaPCollisionManager<double>;
+class FCL_EXPORT SSaPCollisionManager<double>;
 
 } // namespace
diff --git a/src/broadphase/broadphase_SaP.cpp b/src/broadphase/broadphase_SaP.cpp
index cee8117..00f1673 100644
--- a/src/broadphase/broadphase_SaP.cpp
+++ b/src/broadphase/broadphase_SaP.cpp
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class SaPCollisionManager<double>;
+class FCL_EXPORT SaPCollisionManager<double>;
 
 } // namespace fcl
diff --git a/src/broadphase/broadphase_bruteforce.cpp b/src/broadphase/broadphase_bruteforce.cpp
index a8f5339..5a5bb9e 100644
--- a/src/broadphase/broadphase_bruteforce.cpp
+++ b/src/broadphase/broadphase_bruteforce.cpp
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class NaiveCollisionManager<double>;
+class FCL_EXPORT NaiveCollisionManager<double>;
 
 } // namespace fcl
diff --git a/src/broadphase/broadphase_collision_manager.cpp b/src/broadphase/broadphase_collision_manager.cpp
index 3cecc24..4ce48b2 100644
--- a/src/broadphase/broadphase_collision_manager.cpp
+++ b/src/broadphase/broadphase_collision_manager.cpp
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class BroadPhaseCollisionManager<double>;
+class FCL_EXPORT BroadPhaseCollisionManager<double>;
 
 } // namespace fcl
diff --git a/src/broadphase/broadphase_continuous_collision_manager.cpp b/src/broadphase/broadphase_continuous_collision_manager.cpp
index d06760a..77ec491 100644
--- a/src/broadphase/broadphase_continuous_collision_manager.cpp
+++ b/src/broadphase/broadphase_continuous_collision_manager.cpp
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class BroadPhaseContinuousCollisionManager<double>;
+class FCL_EXPORT BroadPhaseContinuousCollisionManager<double>;
 
 } // namespace fcl
diff --git a/src/broadphase/broadphase_dynamic_AABB_tree.cpp b/src/broadphase/broadphase_dynamic_AABB_tree.cpp
index 1da6ca3..6216e44 100644
--- a/src/broadphase/broadphase_dynamic_AABB_tree.cpp
+++ b/src/broadphase/broadphase_dynamic_AABB_tree.cpp
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class DynamicAABBTreeCollisionManager<double>;
+class FCL_EXPORT DynamicAABBTreeCollisionManager<double>;
 
 } // namespace fcl
diff --git a/src/broadphase/broadphase_dynamic_AABB_tree_array.cpp b/src/broadphase/broadphase_dynamic_AABB_tree_array.cpp
index 515feda..89ca9b8 100644
--- a/src/broadphase/broadphase_dynamic_AABB_tree_array.cpp
+++ b/src/broadphase/broadphase_dynamic_AABB_tree_array.cpp
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class DynamicAABBTreeCollisionManager_Array<double>;
+class FCL_EXPORT DynamicAABBTreeCollisionManager_Array<double>;
 
 } // namespace fcl
diff --git a/src/broadphase/broadphase_interval_tree.cpp b/src/broadphase/broadphase_interval_tree.cpp
index 3567fb1..581146a 100644
--- a/src/broadphase/broadphase_interval_tree.cpp
+++ b/src/broadphase/broadphase_interval_tree.cpp
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class IntervalTreeCollisionManager<double>;
+class FCL_EXPORT IntervalTreeCollisionManager<double>;
 
 } // namespace fcl
diff --git a/src/broadphase/broadphase_spatialhash.cpp b/src/broadphase/broadphase_spatialhash.cpp
index 3a9d90e..407b5e7 100644
--- a/src/broadphase/broadphase_spatialhash.cpp
+++ b/src/broadphase/broadphase_spatialhash.cpp
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -41,7 +41,7 @@ namespace fcl
 {
 
 template
-class SpatialHashingCollisionManager<
+class FCL_EXPORT SpatialHashingCollisionManager<
     double,
     detail::SimpleHashTable<
         AABB<double>, CollisionObject<double>*, detail::SpatialHash<double>>>;
diff --git a/src/broadphase/detail/interval_tree.cpp b/src/broadphase/detail/interval_tree.cpp
index 28419ff..e6b7a14 100644
--- a/src/broadphase/detail/interval_tree.cpp
+++ b/src/broadphase/detail/interval_tree.cpp
@@ -44,10 +44,10 @@ namespace detail
 {
 
 template
-struct it_recursion_node<double>;
+struct FCL_EXPORT it_recursion_node<double>;
 
 template
-class IntervalTree<double>;
+class FCL_EXPORT IntervalTree<double>;
 
 } // namespace detail
 } // namespace fcl
diff --git a/src/broadphase/detail/interval_tree_node.cpp b/src/broadphase/detail/interval_tree_node.cpp
index b3779b7..432f857 100644
--- a/src/broadphase/detail/interval_tree_node.cpp
+++ b/src/broadphase/detail/interval_tree_node.cpp
@@ -44,7 +44,7 @@ namespace detail
 {
 
 template
-class IntervalTreeNode<double>;
+class FCL_EXPORT IntervalTreeNode<double>;
 
 } // namespace detail
 } // namespace fcl
diff --git a/src/broadphase/detail/morton.cpp b/src/broadphase/detail/morton.cpp
index fa0419f..ce2c8ce 100644
--- a/src/broadphase/detail/morton.cpp
+++ b/src/broadphase/detail/morton.cpp
@@ -47,6 +47,7 @@ namespace detail
 
 //==============================================================================
 template
+FCL_EXPORT
 uint32 quantize(double x, uint32 n);
 
 //==============================================================================
@@ -86,11 +87,11 @@ uint64 morton_code60(uint32 x, uint32 y, uint32 z)
 
 //==============================================================================
 template
-struct morton_functor<double, uint32>;
+struct FCL_EXPORT morton_functor<double, uint32>;
 
 //==============================================================================
 template
-struct morton_functor<double, uint64>;
+struct FCL_EXPORT morton_functor<double, uint64>;
 
 } // namespace detail
 /// @endcond
diff --git a/src/broadphase/detail/simple_interval.cpp b/src/broadphase/detail/simple_interval.cpp
index 0271d9b..e6715b0 100644
--- a/src/broadphase/detail/simple_interval.cpp
+++ b/src/broadphase/detail/simple_interval.cpp
@@ -44,7 +44,7 @@ namespace detail
 {
 
 template
-struct SimpleInterval<double>;
+struct FCL_EXPORT SimpleInterval<double>;
 
 } // namespace detail
 } // namespace fcl
diff --git a/src/broadphase/detail/spatial_hash.cpp b/src/broadphase/detail/spatial_hash.cpp
index 01a8e25..b7c050b 100644
--- a/src/broadphase/detail/spatial_hash.cpp
+++ b/src/broadphase/detail/spatial_hash.cpp
@@ -31,7 +31,7 @@
  *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  *  POSSIBILITY OF SUCH DAMAGE.
- */ 
+ */
 
 /** @author Jia Pan */
 
@@ -44,7 +44,7 @@ namespace detail
 {
 
 template
-struct SpatialHash<double>;
+struct FCL_EXPORT SpatialHash<double>;
 
 } // namespace detail
 } // namespace fcl
diff --git a/src/common/detail/profiler.cpp b/src/common/detail/profiler.cpp
index 6d78ee0..47d4ffc 100644
--- a/src/common/detail/profiler.cpp
+++ b/src/common/detail/profiler.cpp
@@ -238,14 +238,14 @@ bool Profiler::Running()
 }
 
 //==============================================================================
-struct FCL_EXPORT dataIntVal
+struct dataIntVal
 {
   std::string       name;
   unsigned long int value;
 };
 
 //==============================================================================
-struct FCL_EXPORT SortIntByValue
+struct SortIntByValue
 {
   bool operator()(const dataIntVal &a, const dataIntVal &b) const
   {
@@ -254,14 +254,14 @@ struct FCL_EXPORT SortIntByValue
 };
 
 //==============================================================================
-struct FCL_EXPORT dataDoubleVal
+struct dataDoubleVal
 {
   std::string  name;
   double       value;
 };
 
 //==============================================================================
-struct FCL_EXPORT SortDoubleByValue
+struct SortDoubleByValue
 {
   bool operator()(const dataDoubleVal &a, const dataDoubleVal &b) const
   {
diff --git a/src/geometry/bvh/BVH_utility.cpp b/src/geometry/bvh/BVH_utility.cpp
index bfcc8e8..b8af648 100644
--- a/src/geometry/bvh/BVH_utility.cpp
+++ b/src/geometry/bvh/BVH_utility.cpp
@@ -42,11 +42,13 @@ namespace fcl
 
 //==============================================================================
 template
+FCL_EXPORT
 void BVHExpand(
     BVHModel<OBB<double>>& model, const Variance3<double>* ucs, double r);
 
 //==============================================================================
 template
+FCL_EXPORT
 void BVHExpand(
     BVHModel<RSS<double>>& model, const Variance3<double>* ucs, double r);
 
diff --git a/src/geometry/collision_geometry.cpp b/src/geometry/collision_geometry.cpp
index a898ecd..00de42a 100644
--- a/src/geometry/collision_geometry.cpp
+++ b/src/geometry/collision_geometry.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class CollisionGeometry<double>;
+class FCL_EXPORT CollisionGeometry<double>;
 
 } // namespace fcl
diff --git a/src/geometry/octree/octree.cpp b/src/geometry/octree/octree.cpp
index 1e392e9..4b4879e 100644
--- a/src/geometry/octree/octree.cpp
+++ b/src/geometry/octree/octree.cpp
@@ -46,12 +46,13 @@ namespace fcl
 
 //==============================================================================
 template
-class OcTree<double>;
+class FCL_EXPORT OcTree<double>;
 
 //==============================================================================
 template
+FCL_EXPORT
 void computeChildBV(const AABB<double>& root_bv, unsigned int i, AABB<double>& child_bv);
 
 } // namespace fcl
 
-#endif
\ No newline at end of file
+#endif
diff --git a/src/geometry/shape/box.cpp b/src/geometry/shape/box.cpp
index 9c96f1c..dee9d77 100644
--- a/src/geometry/shape/box.cpp
+++ b/src/geometry/shape/box.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class Box<double>;
+class FCL_EXPORT Box<double>;
 
 } // namespace fcl
diff --git a/src/geometry/shape/capsule.cpp b/src/geometry/shape/capsule.cpp
index db46b66..0eaea73 100644
--- a/src/geometry/shape/capsule.cpp
+++ b/src/geometry/shape/capsule.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class Capsule<double>;
+class FCL_EXPORT Capsule<double>;
 
 } // namespace fcl
diff --git a/src/geometry/shape/cone.cpp b/src/geometry/shape/cone.cpp
index f201ebb..e4de4f6 100644
--- a/src/geometry/shape/cone.cpp
+++ b/src/geometry/shape/cone.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class Cone<double>;
+class FCL_EXPORT Cone<double>;
 
 } // namespace fcl
diff --git a/src/geometry/shape/convex.cpp b/src/geometry/shape/convex.cpp
index 4242923..dbe3161 100644
--- a/src/geometry/shape/convex.cpp
+++ b/src/geometry/shape/convex.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class Convex<double>;
+class FCL_EXPORT Convex<double>;
 
 } // namespace fcl
diff --git a/src/geometry/shape/cylinder.cpp b/src/geometry/shape/cylinder.cpp
index 99933f9..5756720 100644
--- a/src/geometry/shape/cylinder.cpp
+++ b/src/geometry/shape/cylinder.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class Cylinder<double>;
+class FCL_EXPORT Cylinder<double>;
 
 } // namespace fcl
diff --git a/src/geometry/shape/ellipsoid.cpp b/src/geometry/shape/ellipsoid.cpp
index d30baea..355ed24 100644
--- a/src/geometry/shape/ellipsoid.cpp
+++ b/src/geometry/shape/ellipsoid.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class Ellipsoid<double>;
+class FCL_EXPORT Ellipsoid<double>;
 
 } // namespace fcl
diff --git a/src/geometry/shape/halfspace.cpp b/src/geometry/shape/halfspace.cpp
index f01e946..c00c021 100644
--- a/src/geometry/shape/halfspace.cpp
+++ b/src/geometry/shape/halfspace.cpp
@@ -41,9 +41,10 @@ namespace fcl
 {
 
 template
-class Halfspace<double>;
+class FCL_EXPORT Halfspace<double>;
 
 template
+FCL_EXPORT
 Halfspace<double> transform(const Halfspace<double>& a, const Transform3<double>& tf);
 
 } // namespace fcl
diff --git a/src/geometry/shape/plane.cpp b/src/geometry/shape/plane.cpp
index e61fa63..2fdb0f1 100644
--- a/src/geometry/shape/plane.cpp
+++ b/src/geometry/shape/plane.cpp
@@ -42,10 +42,11 @@ namespace fcl
 
 //==============================================================================
 template
-class Plane<double>;
+class FCL_EXPORT Plane<double>;
 
 //==============================================================================
 template
+FCL_EXPORT
 Plane<double> transform(const Plane<double>& a, const Transform3<double>& tf);
 
 } // namespace fcl
diff --git a/src/geometry/shape/shape_base.cpp b/src/geometry/shape/shape_base.cpp
index 179d73e..9570395 100644
--- a/src/geometry/shape/shape_base.cpp
+++ b/src/geometry/shape/shape_base.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class ShapeBase<double>;
+class FCL_EXPORT ShapeBase<double>;
 
 } // namespace fcl
diff --git a/src/geometry/shape/sphere.cpp b/src/geometry/shape/sphere.cpp
index b8a8578..26a314f 100644
--- a/src/geometry/shape/sphere.cpp
+++ b/src/geometry/shape/sphere.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class Sphere<double>;
+class FCL_EXPORT Sphere<double>;
 
 } // namespace fcl
diff --git a/src/geometry/shape/triangle_p.cpp b/src/geometry/shape/triangle_p.cpp
index 86546be..e0bf85b 100644
--- a/src/geometry/shape/triangle_p.cpp
+++ b/src/geometry/shape/triangle_p.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class TriangleP<double>;
+class FCL_EXPORT TriangleP<double>;
 
 } // namespace fcl
diff --git a/src/geometry/shape/utility.cpp b/src/geometry/shape/utility.cpp
index a64ee25..c5dbebb 100644
--- a/src/geometry/shape/utility.cpp
+++ b/src/geometry/shape/utility.cpp
@@ -41,66 +41,82 @@ namespace fcl {
 
 //==============================================================================
 template
+FCL_EXPORT
 void constructBox(const AABB<double>& bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 template
+FCL_EXPORT
 void constructBox(const OBB<double>& bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 template
+FCL_EXPORT
 void constructBox(const OBBRSS<double>& bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 template
+FCL_EXPORT
 void constructBox(const kIOS<double>& bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 template
+FCL_EXPORT
 void constructBox(const RSS<double>& bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 template
+FCL_EXPORT
 void constructBox(const KDOP<double, 16>& bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 template
+FCL_EXPORT
 void constructBox(const KDOP<double, 18>& bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 template
+FCL_EXPORT
 void constructBox(const KDOP<double, 24>& bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 template
+FCL_EXPORT
 void constructBox(const AABB<double>& bv, const Transform3<double>& tf_bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 template
+FCL_EXPORT
 void constructBox(const OBB<double>& bv, const Transform3<double>& tf_bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 template
+FCL_EXPORT
 void constructBox(const OBBRSS<double>& bv, const Transform3<double>& tf_bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 template
+FCL_EXPORT
 void constructBox(const kIOS<double>& bv, const Transform3<double>& tf_bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 template
+FCL_EXPORT
 void constructBox(const RSS<double>& bv, const Transform3<double>& tf_bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 template
+FCL_EXPORT
 void constructBox(const KDOP<double, 16>& bv, const Transform3<double>& tf_bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 template
+FCL_EXPORT
 void constructBox(const KDOP<double, 18>& bv, const Transform3<double>& tf_bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
 template
+FCL_EXPORT
 void constructBox(const KDOP<double, 24>& bv, const Transform3<double>& tf_bv, Box<double>& box, Transform3<double>& tf);
 
 //==============================================================================
@@ -109,119 +125,119 @@ namespace detail {
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, AABB<double>, Box<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, AABB<double>, Box<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, OBB<double>, Box<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, OBB<double>, Box<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, AABB<double>, Capsule<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, AABB<double>, Capsule<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, OBB<double>, Capsule<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, OBB<double>, Capsule<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, AABB<double>, Cone<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, AABB<double>, Cone<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, OBB<double>, Cone<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, OBB<double>, Cone<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, AABB<double>, Cylinder<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, AABB<double>, Cylinder<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, OBB<double>, Cylinder<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, OBB<double>, Cylinder<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, AABB<double>, Ellipsoid<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, AABB<double>, Ellipsoid<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, OBB<double>, Ellipsoid<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, OBB<double>, Ellipsoid<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, AABB<double>, Halfspace<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, AABB<double>, Halfspace<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, OBB<double>, Halfspace<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, OBB<double>, Halfspace<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, RSS<double>, Halfspace<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, RSS<double>, Halfspace<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, OBBRSS<double>, Halfspace<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, OBBRSS<double>, Halfspace<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, kIOS<double>, Halfspace<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, kIOS<double>, Halfspace<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, KDOP<double, 16>, Halfspace<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, KDOP<double, 16>, Halfspace<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, KDOP<double, 18>, Halfspace<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, KDOP<double, 18>, Halfspace<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, KDOP<double, 24>, Halfspace<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, KDOP<double, 24>, Halfspace<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, AABB<double>, Plane<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, AABB<double>, Plane<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, OBB<double>, Plane<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, OBB<double>, Plane<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, RSS<double>, Plane<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, RSS<double>, Plane<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, OBBRSS<double>, Plane<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, OBBRSS<double>, Plane<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, kIOS<double>, Plane<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, kIOS<double>, Plane<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, KDOP<double, 16>, Plane<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, KDOP<double, 16>, Plane<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, KDOP<double, 18>, Plane<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, KDOP<double, 18>, Plane<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, KDOP<double, 24>, Plane<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, KDOP<double, 24>, Plane<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, AABB<double>, Sphere<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, AABB<double>, Sphere<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, OBB<double>, Sphere<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, OBB<double>, Sphere<double>>;
 
 //==============================================================================
 template
-struct ComputeBVImpl<double, AABB<double>, TriangleP<double>>;
+struct FCL_EXPORT ComputeBVImpl<double, AABB<double>, TriangleP<double>>;
 
 //==============================================================================
 } // namespace detail
diff --git a/src/math/bv/AABB.cpp b/src/math/bv/AABB.cpp
index a7c3824..2371037 100644
--- a/src/math/bv/AABB.cpp
+++ b/src/math/bv/AABB.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class AABB<double>;
+class FCL_EXPORT AABB<double>;
 
 } // namespace fcl
diff --git a/src/math/bv/OBB.cpp b/src/math/bv/OBB.cpp
index 1cfa1f6..b911d35 100644
--- a/src/math/bv/OBB.cpp
+++ b/src/math/bv/OBB.cpp
@@ -42,22 +42,26 @@ namespace fcl
 
 //==============================================================================
 template
-class OBB<double>;
+class FCL_EXPORT OBB<double>;
 
 //==============================================================================
 template
+FCL_EXPORT
 void computeVertices(const OBB<double>& b, Vector3<double> vertices[8]);
 
 //==============================================================================
 template
+FCL_EXPORT
 OBB<double> merge_largedist(const OBB<double>& b1, const OBB<double>& b2);
 
 //==============================================================================
 template
+FCL_EXPORT
 OBB<double> merge_smalldist(const OBB<double>& b1, const OBB<double>& b2);
 
 //==============================================================================
 template
+FCL_EXPORT
 bool obbDisjoint(
     const Matrix3<double>& B,
     const Vector3<double>& T,
@@ -66,6 +70,7 @@ bool obbDisjoint(
 
 //==============================================================================
 template
+FCL_EXPORT
 bool obbDisjoint(
     const Transform3<double>& tf,
     const Vector3<double>& a,
diff --git a/src/math/bv/OBBRSS.cpp b/src/math/bv/OBBRSS.cpp
index 10cb794..b926af9 100644
--- a/src/math/bv/OBBRSS.cpp
+++ b/src/math/bv/OBBRSS.cpp
@@ -42,10 +42,11 @@ namespace fcl
 
 //==============================================================================
 template
-class OBBRSS<double>;
+class FCL_EXPORT OBBRSS<double>;
 
 //==============================================================================
 template
+FCL_EXPORT
 OBBRSS<double> translate(const OBBRSS<double>& bv, const Vector3<double>& t);
 
 } // namespace fcl
diff --git a/src/math/bv/RSS.cpp b/src/math/bv/RSS.cpp
index c7db037..a703d8f 100644
--- a/src/math/bv/RSS.cpp
+++ b/src/math/bv/RSS.cpp
@@ -42,14 +42,16 @@ namespace fcl
 
 //==============================================================================
 template
-class RSS<double>;
+class FCL_EXPORT RSS<double>;
 
 //==============================================================================
 template
+FCL_EXPORT
 void clipToRange(double& val, double a, double b);
 
 //==============================================================================
 template
+FCL_EXPORT
 void segCoords(
         double& t,
         double& u,
@@ -61,6 +63,7 @@ void segCoords(
 
 //==============================================================================
 template
+FCL_EXPORT
 bool inVoronoi(
         double a,
         double b,
@@ -72,6 +75,7 @@ bool inVoronoi(
 
 //==============================================================================
 template
+FCL_EXPORT
 double rectDistance(
     const Matrix3<double>& Rab,
     const Vector3<double>& Tab,
@@ -82,6 +86,7 @@ double rectDistance(
 
 //==============================================================================
 template
+FCL_EXPORT
 double rectDistance(
     const Transform3<double>& tfab,
     const double a[2],
@@ -91,6 +96,7 @@ double rectDistance(
 
 //==============================================================================
 template
+FCL_EXPORT
 RSS<double> translate(const RSS<double>& bv, const Vector3<double>& t);
 
 } // namespace fcl
diff --git a/src/math/bv/kDOP.cpp b/src/math/bv/kDOP.cpp
index 8879a44..61cc7c4 100644
--- a/src/math/bv/kDOP.cpp
+++ b/src/math/bv/kDOP.cpp
@@ -42,34 +42,39 @@ namespace fcl
 
 //==============================================================================
 template
-class KDOP<double, 16>;
+class FCL_EXPORT KDOP<double, 16>;
 
 //==============================================================================
 template
-class KDOP<double, 18>;
+class FCL_EXPORT KDOP<double, 18>;
 
 //==============================================================================
 template
-class KDOP<double, 24>;
+class FCL_EXPORT KDOP<double, 24>;
 
 //==============================================================================
 template
+FCL_EXPORT
 void minmax(double a, double b, double& minv, double& maxv);
 
 //==============================================================================
 template
+FCL_EXPORT
 void minmax(double p, double& minv, double& maxv);
 
 //==============================================================================
 template
+FCL_EXPORT
 void getDistances<double, 5>(const Vector3<double>& p, double* d);
 
 //==============================================================================
 template
+FCL_EXPORT
 void getDistances<double, 6>(const Vector3<double>& p, double* d);
 
 //==============================================================================
 template
+FCL_EXPORT
 void getDistances<double, 9>(const Vector3<double>& p, double* d);
 
 } // namespace fcl
diff --git a/src/math/bv/kIOS.cpp b/src/math/bv/kIOS.cpp
index 4c17b92..5ee7704 100644
--- a/src/math/bv/kIOS.cpp
+++ b/src/math/bv/kIOS.cpp
@@ -39,8 +39,8 @@
 
 namespace fcl
 {
- 
+
 template
-class kIOS<double>;
+class FCL_EXPORT kIOS<double>;
 
 } // namespace fcl
diff --git a/src/math/bv/utility.cpp b/src/math/bv/utility.cpp
index d2e44a9..7f2cc49 100644
--- a/src/math/bv/utility.cpp
+++ b/src/math/bv/utility.cpp
@@ -46,22 +46,27 @@ namespace OBB_fit_functions {
 
 //==============================================================================
 template
+FCL_EXPORT
 void fit1(const Vector3d* const ps, OBB<double>& bv);
 
 //==============================================================================
 template
+FCL_EXPORT
 void fit2(const Vector3d* const ps, OBB<double>& bv);
 
 //==============================================================================
 template
+FCL_EXPORT
 void fit3(const Vector3d* const ps, OBB<double>& bv);
 
 //==============================================================================
 template
+FCL_EXPORT
 void fit6(const Vector3d* const ps, OBB<double>& bv);
 
 //==============================================================================
 template
+FCL_EXPORT
 void fitn(const Vector3d* const ps, int n, OBB<double>& bv);
 
 //==============================================================================
@@ -74,22 +79,27 @@ namespace RSS_fit_functions {
 
 //==============================================================================
 template
+FCL_EXPORT
 void fit1(const Vector3d* const ps, RSS<double>& bv);
 
 //==============================================================================
 template
+FCL_EXPORT
 void fit2(const Vector3d* const ps, RSS<double>& bv);
 
 //==============================================================================
 template
+FCL_EXPORT
 void fit3(const Vector3d* const ps, RSS<double>& bv);
 
 //==============================================================================
 template
+FCL_EXPORT
 void fit6(const Vector3d* const ps, RSS<double>& bv);
 
 //==============================================================================
 template
+FCL_EXPORT
 void fitn(const Vector3d* const ps, int n, RSS<double>& bv);
 
 //==============================================================================
@@ -102,18 +112,22 @@ namespace kIOS_fit_functions {
 
 //==============================================================================
 template
+FCL_EXPORT
 void fit1(const Vector3d* const ps, kIOS<double>& bv);
 
 //==============================================================================
 template
+FCL_EXPORT
 void fit2(const Vector3d* const ps, kIOS<double>& bv);
 
 //==============================================================================
 template
+FCL_EXPORT
 void fit3(const Vector3d* const ps, kIOS<double>& bv);
 
 //==============================================================================
 template
+FCL_EXPORT
 void fitn(const Vector3d* const ps, int n, kIOS<double>& bv);
 
 //==============================================================================
@@ -126,18 +140,22 @@ namespace OBBRSS_fit_functions {
 
 //==============================================================================
 template
+FCL_EXPORT
 void fit1(const Vector3d* const ps, OBBRSS<double>& bv);
 
 //==============================================================================
 template
+FCL_EXPORT
 void fit2(const Vector3d* const ps, OBBRSS<double>& bv);
 
 //==============================================================================
 template
+FCL_EXPORT
 void fit3(const Vector3d* const ps, OBBRSS<double>& bv);
 
 //==============================================================================
 template
+FCL_EXPORT
 void fitn(const Vector3d* const ps, int n, OBBRSS<double>& bv);
 
 //==============================================================================
@@ -146,55 +164,55 @@ void fitn(const Vector3d* const ps, int n, OBBRSS<double>& bv);
 
 //==============================================================================
 template
-struct Fitter<double, OBB<double>>;
+struct FCL_EXPORT Fitter<double, OBB<double>>;
 
 //==============================================================================
 template
-struct Fitter<double, RSS<double>>;
+struct FCL_EXPORT Fitter<double, RSS<double>>;
 
 //==============================================================================
 template
-struct Fitter<double, kIOS<double>>;
+struct FCL_EXPORT Fitter<double, kIOS<double>>;
 
 //==============================================================================
 template
-struct Fitter<double, OBBRSS<double>>;
+struct FCL_EXPORT Fitter<double, OBBRSS<double>>;
 
 //==============================================================================
 template
-class ConvertBVImpl<double, AABB<double>, AABB<double>>;
+class FCL_EXPORT ConvertBVImpl<double, AABB<double>, AABB<double>>;
 
 //==============================================================================
 template
-class ConvertBVImpl<double, AABB<double>, OBB<double>>;
+class FCL_EXPORT ConvertBVImpl<double, AABB<double>, OBB<double>>;
 
 //==============================================================================
 template
-class ConvertBVImpl<double, OBB<double>, OBB<double>>;
+class FCL_EXPORT ConvertBVImpl<double, OBB<double>, OBB<double>>;
 
 //==============================================================================
 template
-class ConvertBVImpl<double, OBBRSS<double>, OBB<double>>;
+class FCL_EXPORT ConvertBVImpl<double, OBBRSS<double>, OBB<double>>;
 
 //==============================================================================
 template
-class ConvertBVImpl<double, RSS<double>, OBB<double>>;
+class FCL_EXPORT ConvertBVImpl<double, RSS<double>, OBB<double>>;
 
 //==============================================================================
 template
-class ConvertBVImpl<double, OBB<double>, RSS<double>>;
+class FCL_EXPORT ConvertBVImpl<double, OBB<double>, RSS<double>>;
 
 //==============================================================================
 template
-class ConvertBVImpl<double, RSS<double>, RSS<double>>;
+class FCL_EXPORT ConvertBVImpl<double, RSS<double>, RSS<double>>;
 
 //==============================================================================
 template
-class ConvertBVImpl<double, OBBRSS<double>, RSS<double>>;
+class FCL_EXPORT ConvertBVImpl<double, OBBRSS<double>, RSS<double>>;
 
 //==============================================================================
 template
-class ConvertBVImpl<double, AABB<double>, RSS<double>>;
+class FCL_EXPORT ConvertBVImpl<double, AABB<double>, RSS<double>>;
 
 } // namespace detail
 } // namespace fcl
diff --git a/src/math/detail/polysolver.cpp b/src/math/detail/polysolver.cpp
index 3aedfa0..483b5b7 100644
--- a/src/math/detail/polysolver.cpp
+++ b/src/math/detail/polysolver.cpp
@@ -1,49 +1,49 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#include "fcl/math/detail/polysolver-inl.h"
-
-namespace fcl
-{
-
-namespace detail {
-
-template
-class PolySolver<double>;
-
-} // namespace detail
-} // namespace fcl
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#include "fcl/math/detail/polysolver-inl.h"
+
+namespace fcl
+{
+
+namespace detail {
+
+template
+class FCL_EXPORT PolySolver<double>;
+
+} // namespace detail
+} // namespace fcl
diff --git a/src/math/detail/project.cpp b/src/math/detail/project.cpp
index e5bbe94..2955ae7 100644
--- a/src/math/detail/project.cpp
+++ b/src/math/detail/project.cpp
@@ -1,50 +1,50 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#include "fcl/math/detail/project-inl.h"
-
-namespace fcl
-{
-
-namespace detail
-{
-
-template
-class Project<double>;
-
-} // namespace detail
-} // namespace fcl
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#include "fcl/math/detail/project-inl.h"
+
+namespace fcl
+{
+
+namespace detail
+{
+
+template
+class FCL_EXPORT Project<double>;
+
+} // namespace detail
+} // namespace fcl
diff --git a/src/math/geometry.cpp b/src/math/geometry.cpp
index b40110f..e2a4880 100644
--- a/src/math/geometry.cpp
+++ b/src/math/geometry.cpp
@@ -41,41 +41,50 @@ namespace fcl {
 
 //==============================================================================
 template
+FCL_EXPORT
 void normalize(Vector3d& v, bool* signal);
 
 //==============================================================================
 template
+FCL_EXPORT
 void hat(Matrix3d& mat, const Vector3d& vec);
 
 //==============================================================================
 template
+FCL_EXPORT
 void eigen(const Matrix3d& m, Vector3d& dout, Matrix3d& vout);
 
 //==============================================================================
 template
+FCL_EXPORT
 void eigen_old(const Matrix3d& m, Vector3d& dout, Matrix3d& vout);
 
 //==============================================================================
 template
+FCL_EXPORT
 void axisFromEigen(
     const Matrix3d& eigenV, const Vector3d& eigenS, Matrix3d& axis);
 
 //==============================================================================
 template
+FCL_EXPORT
 void axisFromEigen(const Matrix3d& eigenV,
                    const Vector3d& eigenS,
                    Transform3d& tf);
 
 //==============================================================================
 template
+FCL_EXPORT
 void generateCoordinateSystem(Matrix3d& axis);
 
 //==============================================================================
 template
+FCL_EXPORT
 void generateCoordinateSystem(Transform3d& tf);
 
 //==============================================================================
 template
+FCL_EXPORT
 void getRadiusAndOriginAndRectangleSize(
     const Vector3d* const ps,
     const Vector3d* const ps2,
@@ -89,6 +98,7 @@ void getRadiusAndOriginAndRectangleSize(
 
 //==============================================================================
 template
+FCL_EXPORT
 void getRadiusAndOriginAndRectangleSize(
     const Vector3d* const ps,
     const Vector3d* const ps2,
@@ -101,6 +111,7 @@ void getRadiusAndOriginAndRectangleSize(
 
 //==============================================================================
 template
+FCL_EXPORT
 void circumCircleComputation(
     const Vector3d& a,
     const Vector3d& b,
@@ -110,6 +121,7 @@ void circumCircleComputation(
 
 //==============================================================================
 template
+FCL_EXPORT
 double maximumDistance(
     const Vector3d* const ps,
     const Vector3d* const ps2,
@@ -120,6 +132,7 @@ double maximumDistance(
 
 //==============================================================================
 template
+FCL_EXPORT
 void getExtentAndCenter(
     const Vector3d* const ps,
     const Vector3d* const ps2,
@@ -132,6 +145,7 @@ void getExtentAndCenter(
 
 //==============================================================================
 template
+FCL_EXPORT
 void getCovariance(
     const Vector3d* const ps,
     const Vector3d* const ps2,
@@ -145,6 +159,7 @@ namespace detail {
 
 //==============================================================================
 template
+FCL_EXPORT
 double maximumDistance_mesh(
     const Vector3d* const ps,
     const Vector3d* const ps2,
@@ -155,6 +170,7 @@ double maximumDistance_mesh(
 
 //==============================================================================
 template
+FCL_EXPORT
 double maximumDistance_pointcloud(
     const Vector3d* const ps,
     const Vector3d* const ps2,
@@ -164,6 +180,7 @@ double maximumDistance_pointcloud(
 
 //==============================================================================
 template
+FCL_EXPORT
 void getExtentAndCenter_pointcloud(
     const Vector3d* const ps,
     const Vector3d* const ps2,
@@ -175,6 +192,7 @@ void getExtentAndCenter_pointcloud(
 
 //==============================================================================
 template
+FCL_EXPORT
 void getExtentAndCenter_mesh(
     const Vector3d* const ps,
     const Vector3d* const ps2,
diff --git a/src/math/motion/interp_motion.cpp b/src/math/motion/interp_motion.cpp
index aa5e592..cb3c542 100644
--- a/src/math/motion/interp_motion.cpp
+++ b/src/math/motion/interp_motion.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class InterpMotion<double>;
+class FCL_EXPORT InterpMotion<double>;
 
 } // namespace fcl
diff --git a/src/math/motion/motion_base.cpp b/src/math/motion/motion_base.cpp
index 981cc81..aeb4065 100644
--- a/src/math/motion/motion_base.cpp
+++ b/src/math/motion/motion_base.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class MotionBase<double>;
+class FCL_EXPORT MotionBase<double>;
 
 } // namespace fcl
diff --git a/src/math/motion/screw_motion.cpp b/src/math/motion/screw_motion.cpp
index 65d1066..dffcbcf 100644
--- a/src/math/motion/screw_motion.cpp
+++ b/src/math/motion/screw_motion.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class ScrewMotion<double>;
+class FCL_EXPORT ScrewMotion<double>;
 
 } // namespace fcl
diff --git a/src/math/motion/spline_motion.cpp b/src/math/motion/spline_motion.cpp
index 16601e2..b46de65 100644
--- a/src/math/motion/spline_motion.cpp
+++ b/src/math/motion/spline_motion.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class SplineMotion<double>;
+class FCL_EXPORT SplineMotion<double>;
 
 } // namespace fcl
diff --git a/src/math/motion/taylor_model/interval.cpp b/src/math/motion/taylor_model/interval.cpp
index 236ec3d..7f7068f 100644
--- a/src/math/motion/taylor_model/interval.cpp
+++ b/src/math/motion/taylor_model/interval.cpp
@@ -43,14 +43,16 @@ namespace fcl
 
 //==============================================================================
 template
-struct Interval<double>;
+struct FCL_EXPORT Interval<double>;
 
 //==============================================================================
 template
+FCL_EXPORT
 Interval<double> bound(const Interval<double>& i, double v);
 
 //==============================================================================
 template
+FCL_EXPORT
 Interval<double> bound(const Interval<double>& i, const Interval<double>& other);
 
 } // namespace fcl
diff --git a/src/math/motion/taylor_model/interval_matrix.cpp b/src/math/motion/taylor_model/interval_matrix.cpp
index 1bb0f92..f1a3cd7 100644
--- a/src/math/motion/taylor_model/interval_matrix.cpp
+++ b/src/math/motion/taylor_model/interval_matrix.cpp
@@ -42,10 +42,11 @@ namespace fcl
 
 //==============================================================================
 template
-struct IMatrix3<double>;
+struct FCL_EXPORT IMatrix3<double>;
 
 //==============================================================================
 template
+FCL_EXPORT
 IMatrix3<double> rotationConstrain(const IMatrix3<double>& m);
 
 } // namespace fcl
diff --git a/src/math/motion/taylor_model/interval_vector.cpp b/src/math/motion/taylor_model/interval_vector.cpp
index 9e216a6..4c61905 100644
--- a/src/math/motion/taylor_model/interval_vector.cpp
+++ b/src/math/motion/taylor_model/interval_vector.cpp
@@ -42,14 +42,16 @@ namespace fcl
 
 //==============================================================================
 template
-struct IVector3<double>;
+struct FCL_EXPORT IVector3<double>;
 
 //==============================================================================
 template
+FCL_EXPORT
 IVector3<double> bound(const IVector3<double>& i, const Vector3<double>& v);
 
 //==============================================================================
 template
+FCL_EXPORT
 IVector3<double> bound(const IVector3<double>& i, const IVector3<double>& v);
 
 } // namespace fcl
diff --git a/src/math/motion/taylor_model/taylor_matrix.cpp b/src/math/motion/taylor_model/taylor_matrix.cpp
index baa926f..b744d3e 100644
--- a/src/math/motion/taylor_model/taylor_matrix.cpp
+++ b/src/math/motion/taylor_model/taylor_matrix.cpp
@@ -42,34 +42,41 @@ namespace fcl
 
 //==============================================================================
 template
-class TMatrix3<double>;
+class FCL_EXPORT TMatrix3<double>;
 
 //==============================================================================
 template
+FCL_EXPORT
 TMatrix3<double> rotationConstrain(const TMatrix3<double>& m);
 
 //==============================================================================
 template
+FCL_EXPORT
 TMatrix3<double> operator * (const Matrix3<double>& m, const TaylorModel<double>& a);
 
 //==============================================================================
 template
+FCL_EXPORT
 TMatrix3<double> operator * (const TaylorModel<double>& a, const Matrix3<double>& m);
 
 //==============================================================================
 template
+FCL_EXPORT
 TMatrix3<double> operator * (const TaylorModel<double>& a, const TMatrix3<double>& m);
 
 //==============================================================================
 template
+FCL_EXPORT
 TMatrix3<double> operator * (double d, const TMatrix3<double>& m);
 
 //==============================================================================
 template
+FCL_EXPORT
 TMatrix3<double> operator + (const Matrix3<double>& m1, const TMatrix3<double>& m2);
 
 //==============================================================================
 template
+FCL_EXPORT
 TMatrix3<double> operator - (const Matrix3<double>& m1, const TMatrix3<double>& m2);
 
 } // namespace fcl
diff --git a/src/math/motion/taylor_model/taylor_model.cpp b/src/math/motion/taylor_model/taylor_model.cpp
index 58a98d7..e2a3869 100644
--- a/src/math/motion/taylor_model/taylor_model.cpp
+++ b/src/math/motion/taylor_model/taylor_model.cpp
@@ -45,30 +45,36 @@ namespace fcl
 
 //==============================================================================
 template
-class TaylorModel<double>;
+class FCL_EXPORT TaylorModel<double>;
 
 //==============================================================================
 template
+FCL_EXPORT
 TaylorModel<double> operator * (double d, const TaylorModel<double>& a);
 
 //==============================================================================
 template
+FCL_EXPORT
 TaylorModel<double> operator + (double d, const TaylorModel<double>& a);
 
 //==============================================================================
 template
+FCL_EXPORT
 TaylorModel<double> operator - (double d, const TaylorModel<double>& a);
 
 //==============================================================================
 template
+FCL_EXPORT
 void generateTaylorModelForCosFunc(TaylorModel<double>& tm, double w, double q0);
 
 //==============================================================================
 template
+FCL_EXPORT
 void generateTaylorModelForSinFunc(TaylorModel<double>& tm, double w, double q0);
 
 //==============================================================================
 template
+FCL_EXPORT
 void generateTaylorModelForLinearFunc(TaylorModel<double>& tm, double p, double v);
 
 } // namespace fcl
diff --git a/src/math/motion/taylor_model/taylor_vector.cpp b/src/math/motion/taylor_model/taylor_vector.cpp
index 81acc6e..013dd88 100644
--- a/src/math/motion/taylor_model/taylor_vector.cpp
+++ b/src/math/motion/taylor_model/taylor_vector.cpp
@@ -42,22 +42,26 @@ namespace fcl
 
 //==============================================================================
 template
-class TVector3<double>;
+class FCL_EXPORT TVector3<double>;
 
 //==============================================================================
 template
+FCL_EXPORT
 void generateTVector3ForLinearFunc(TVector3<double>& v, const Vector3<double>& position, const Vector3<double>& velocity);
 
 //==============================================================================
 template
+FCL_EXPORT
 TVector3<double> operator * (const Vector3<double>& v, const TaylorModel<double>& a);
 
 //==============================================================================
 template
+FCL_EXPORT
 TVector3<double> operator + (const Vector3<double>& v1, const TVector3<double>& v2);
 
 //==============================================================================
 template
+FCL_EXPORT
 TVector3<double> operator - (const Vector3<double>& v1, const TVector3<double>& v2);
 
 } // namespace fcl
diff --git a/src/math/motion/taylor_model/time_interval.cpp b/src/math/motion/taylor_model/time_interval.cpp
index 2587db4..669a05c 100644
--- a/src/math/motion/taylor_model/time_interval.cpp
+++ b/src/math/motion/taylor_model/time_interval.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-struct TimeInterval<double>;
+struct FCL_EXPORT TimeInterval<double>;
 
 } // namespace fcl
diff --git a/src/math/motion/translation_motion.cpp b/src/math/motion/translation_motion.cpp
index abfbb41..873a717 100644
--- a/src/math/motion/translation_motion.cpp
+++ b/src/math/motion/translation_motion.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class TranslationMotion<double>;
+class FCL_EXPORT TranslationMotion<double>;
 
 } // namespace fcl
diff --git a/src/math/motion/triangle_motion_bound_visitor.cpp b/src/math/motion/triangle_motion_bound_visitor.cpp
index 1fd1f2b..9840e3e 100644
--- a/src/math/motion/triangle_motion_bound_visitor.cpp
+++ b/src/math/motion/triangle_motion_bound_visitor.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class TriangleMotionBoundVisitor<double>;
+class FCL_EXPORT TriangleMotionBoundVisitor<double>;
 
 } // namespace fcl
diff --git a/src/math/rng.cpp b/src/math/rng.cpp
index c997dab..ae3093d 100644
--- a/src/math/rng.cpp
+++ b/src/math/rng.cpp
@@ -42,6 +42,6 @@ namespace fcl
 
 //==============================================================================
 template
-class RNG<double>;
+class FCL_EXPORT RNG<double>;
 
 } // namespace fcl
diff --git a/src/math/sampler/sampler_base.cpp b/src/math/sampler/sampler_base.cpp
index 593cbdc..7b2b7b1 100644
--- a/src/math/sampler/sampler_base.cpp
+++ b/src/math/sampler/sampler_base.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class SamplerBase<double>;
+class FCL_EXPORT SamplerBase<double>;
 
 } // namespace fcl
diff --git a/src/math/sampler/sampler_se2.cpp b/src/math/sampler/sampler_se2.cpp
index 11495c1..4409bea 100644
--- a/src/math/sampler/sampler_se2.cpp
+++ b/src/math/sampler/sampler_se2.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class SamplerSE2<double>;
+class FCL_EXPORT SamplerSE2<double>;
 
 } // namespace fcl
diff --git a/src/math/sampler/sampler_se2_disk.cpp b/src/math/sampler/sampler_se2_disk.cpp
index d70aab9..f4ddf52 100644
--- a/src/math/sampler/sampler_se2_disk.cpp
+++ b/src/math/sampler/sampler_se2_disk.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class SamplerSE2_disk<double>;
+class FCL_EXPORT SamplerSE2_disk<double>;
 
 } // namespace fcl
diff --git a/src/math/sampler/sampler_se3_euler.cpp b/src/math/sampler/sampler_se3_euler.cpp
index 3f97745..9f8c689 100644
--- a/src/math/sampler/sampler_se3_euler.cpp
+++ b/src/math/sampler/sampler_se3_euler.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class SamplerSE3Euler<double>;
+class FCL_EXPORT SamplerSE3Euler<double>;
 
 } // namespace fcl
diff --git a/src/math/sampler/sampler_se3_euler_ball.cpp b/src/math/sampler/sampler_se3_euler_ball.cpp
index 3570439..53aaa08 100644
--- a/src/math/sampler/sampler_se3_euler_ball.cpp
+++ b/src/math/sampler/sampler_se3_euler_ball.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class SamplerSE3Euler_ball<double>;
+class FCL_EXPORT SamplerSE3Euler_ball<double>;
 
 } // namespace fcl
diff --git a/src/math/sampler/sampler_se3_quat.cpp b/src/math/sampler/sampler_se3_quat.cpp
index 0d0999e..181941b 100644
--- a/src/math/sampler/sampler_se3_quat.cpp
+++ b/src/math/sampler/sampler_se3_quat.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class SamplerSE3Quat<double>;
+class FCL_EXPORT SamplerSE3Quat<double>;
 
 } // namespace fcl
diff --git a/src/math/sampler/sampler_se3_quat_ball.cpp b/src/math/sampler/sampler_se3_quat_ball.cpp
index 0db789a..83f246b 100644
--- a/src/math/sampler/sampler_se3_quat_ball.cpp
+++ b/src/math/sampler/sampler_se3_quat_ball.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class SamplerSE3Quat_ball<double>;
+class FCL_EXPORT SamplerSE3Quat_ball<double>;
 
 } // namespace fcl
diff --git a/src/math/variance3.cpp b/src/math/variance3.cpp
index 91255f8..fb5bd85 100644
--- a/src/math/variance3.cpp
+++ b/src/math/variance3.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class Variance3<double>;
+class FCL_EXPORT Variance3<double>;
 
 } // namespace fcl
diff --git a/src/narrowphase/collision.cpp b/src/narrowphase/collision.cpp
index ad51861..e917e89 100644
--- a/src/narrowphase/collision.cpp
+++ b/src/narrowphase/collision.cpp
@@ -42,6 +42,7 @@ namespace fcl
 
 //==============================================================================
 template
+FCL_EXPORT
 std::size_t collide(
     const CollisionObject<double>* o1,
     const CollisionObject<double>* o2,
@@ -50,6 +51,7 @@ std::size_t collide(
 
 //==============================================================================
 template
+FCL_EXPORT
 std::size_t collide(
     const CollisionGeometry<double>* o1,
     const Transform3<double>& tf1,
diff --git a/src/narrowphase/collision_object.cpp b/src/narrowphase/collision_object.cpp
index 6362db1..fac663f 100644
--- a/src/narrowphase/collision_object.cpp
+++ b/src/narrowphase/collision_object.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class CollisionObject<double>;
+class FCL_EXPORT CollisionObject<double>;
 
 } // namespace fcl
diff --git a/src/narrowphase/collision_request.cpp b/src/narrowphase/collision_request.cpp
index d47be1e..f808b8f 100644
--- a/src/narrowphase/collision_request.cpp
+++ b/src/narrowphase/collision_request.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-struct CollisionRequest<double>;
+struct FCL_EXPORT CollisionRequest<double>;
 
 } // namespace fcl
diff --git a/src/narrowphase/collision_result.cpp b/src/narrowphase/collision_result.cpp
index 047193b..7429829 100644
--- a/src/narrowphase/collision_result.cpp
+++ b/src/narrowphase/collision_result.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-struct CollisionResult<double>;
+struct FCL_EXPORT CollisionResult<double>;
 
 } // namespace fcl
diff --git a/src/narrowphase/contact.cpp b/src/narrowphase/contact.cpp
index 4ca0c5e..3184b5a 100644
--- a/src/narrowphase/contact.cpp
+++ b/src/narrowphase/contact.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-struct Contact<double>;
+struct FCL_EXPORT Contact<double>;
 
 } // namespace fcl
diff --git a/src/narrowphase/contact_point.cpp b/src/narrowphase/contact_point.cpp
index 415e985..5885491 100644
--- a/src/narrowphase/contact_point.cpp
+++ b/src/narrowphase/contact_point.cpp
@@ -42,15 +42,17 @@ namespace fcl
 
 //==============================================================================
 template
-struct ContactPoint<double>;
+struct FCL_EXPORT ContactPoint<double>;
 
 //==============================================================================
 template
+FCL_EXPORT
 bool comparePenDepth(
     const ContactPoint<double>& _cp1, const ContactPoint<double>& _cp2);
 
 //==============================================================================
 template
+FCL_EXPORT
 void flipNormal(std::vector<ContactPoint<double>>& contacts);
 
 } // namespace fcl
diff --git a/src/narrowphase/continuous_collision.cpp b/src/narrowphase/continuous_collision.cpp
index bbbce19..1508e3d 100644
--- a/src/narrowphase/continuous_collision.cpp
+++ b/src/narrowphase/continuous_collision.cpp
@@ -42,6 +42,7 @@ namespace fcl
 
 //==============================================================================
 template
+FCL_EXPORT
 double continuousCollide(
     const CollisionGeometry<double>* o1,
     const MotionBase<double>* motion1,
@@ -52,6 +53,7 @@ double continuousCollide(
 
 //==============================================================================
 template
+FCL_EXPORT
 double continuousCollide(
     const CollisionGeometry<double>* o1,
     const Transform3<double>& tf1_beg,
@@ -64,6 +66,7 @@ double continuousCollide(
 
 //==============================================================================
 template
+FCL_EXPORT
 double continuousCollide(
     const CollisionObject<double>* o1,
     const Transform3<double>& tf1_end,
@@ -74,6 +77,7 @@ double continuousCollide(
 
 //==============================================================================
 template
+FCL_EXPORT
 double collide(
     const ContinuousCollisionObject<double>* o1,
     const ContinuousCollisionObject<double>* o2,
diff --git a/src/narrowphase/continuous_collision_object.cpp b/src/narrowphase/continuous_collision_object.cpp
index 93b7672..7688a58 100644
--- a/src/narrowphase/continuous_collision_object.cpp
+++ b/src/narrowphase/continuous_collision_object.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-class ContinuousCollisionObject<double>;
+class FCL_EXPORT ContinuousCollisionObject<double>;
 
 } // namespace fcl
diff --git a/src/narrowphase/continuous_collision_request.cpp b/src/narrowphase/continuous_collision_request.cpp
index 46dc3ea..6b62af6 100644
--- a/src/narrowphase/continuous_collision_request.cpp
+++ b/src/narrowphase/continuous_collision_request.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-struct ContinuousCollisionRequest<double>;
+struct FCL_EXPORT ContinuousCollisionRequest<double>;
 
 } // namespace fcl
diff --git a/src/narrowphase/continuous_collision_result.cpp b/src/narrowphase/continuous_collision_result.cpp
index 3d9c559..c60821e 100644
--- a/src/narrowphase/continuous_collision_result.cpp
+++ b/src/narrowphase/continuous_collision_result.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-struct ContinuousCollisionResult<double>;
+struct FCL_EXPORT ContinuousCollisionResult<double>;
 
 } // namespace fcl
diff --git a/src/narrowphase/cost_source.cpp b/src/narrowphase/cost_source.cpp
index 9c60638..b10af6b 100644
--- a/src/narrowphase/cost_source.cpp
+++ b/src/narrowphase/cost_source.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-struct CostSource<double>;
+struct FCL_EXPORT CostSource<double>;
 
 } // namespace fcl
diff --git a/src/narrowphase/detail/convexity_based_algorithm/epa.cpp b/src/narrowphase/detail/convexity_based_algorithm/epa.cpp
index eae9f17..a581f46 100644
--- a/src/narrowphase/detail/convexity_based_algorithm/epa.cpp
+++ b/src/narrowphase/detail/convexity_based_algorithm/epa.cpp
@@ -44,7 +44,7 @@ namespace detail
 {
 
 template
-struct EPA<double>;
+struct FCL_EXPORT EPA<double>;
 
 } // namespace detail
 } // namespace fcl
diff --git a/src/narrowphase/detail/convexity_based_algorithm/gjk.cpp b/src/narrowphase/detail/convexity_based_algorithm/gjk.cpp
index 6b693eb..a4a00f3 100644
--- a/src/narrowphase/detail/convexity_based_algorithm/gjk.cpp
+++ b/src/narrowphase/detail/convexity_based_algorithm/gjk.cpp
@@ -44,7 +44,7 @@ namespace detail
 {
 
 template
-struct GJK<double>;
+struct FCL_EXPORT GJK<double>;
 
 } // namespace detail
 } // namespace fcl
diff --git a/src/narrowphase/detail/convexity_based_algorithm/gjk_libccd.cpp b/src/narrowphase/detail/convexity_based_algorithm/gjk_libccd.cpp
index 7c3714e..68a162f 100644
--- a/src/narrowphase/detail/convexity_based_algorithm/gjk_libccd.cpp
+++ b/src/narrowphase/detail/convexity_based_algorithm/gjk_libccd.cpp
@@ -45,39 +45,41 @@ namespace detail
 
 //==============================================================================
 template
-class GJKInitializer<double, Cylinder<double>>;
+class FCL_EXPORT GJKInitializer<double, Cylinder<double>>;
 
 //==============================================================================
 template
-class GJKInitializer<double, Sphere<double>>;
+class FCL_EXPORT GJKInitializer<double, Sphere<double>>;
 
 //==============================================================================
 template
-class GJKInitializer<double, Ellipsoid<double>>;
+class FCL_EXPORT GJKInitializer<double, Ellipsoid<double>>;
 
 //==============================================================================
 template
-class GJKInitializer<double, Box<double>>;
+class FCL_EXPORT GJKInitializer<double, Box<double>>;
 
 //==============================================================================
 template
-class GJKInitializer<double, Capsule<double>>;
+class FCL_EXPORT GJKInitializer<double, Capsule<double>>;
 
 //==============================================================================
 template
-class GJKInitializer<double, Cone<double>>;
+class FCL_EXPORT GJKInitializer<double, Cone<double>>;
 
 //==============================================================================
 template
-class GJKInitializer<double, Convex<double>>;
+class FCL_EXPORT GJKInitializer<double, Convex<double>>;
 
 //==============================================================================
 template
+FCL_EXPORT
 void* triCreateGJKObject(
     const Vector3d& P1, const Vector3d& P2, const Vector3d& P3);
 
 //==============================================================================
 template
+FCL_EXPORT
 void* triCreateGJKObject(
     const Vector3d& P1,
     const Vector3d& P2,
@@ -86,6 +88,7 @@ void* triCreateGJKObject(
 
 //==============================================================================
 template
+FCL_EXPORT
 bool GJKCollide(
     void* obj1,
     ccd_support_fn supp1,
@@ -101,6 +104,7 @@ bool GJKCollide(
 
 //==============================================================================
 template
+FCL_EXPORT
 bool GJKDistance(
     void* obj1,
     ccd_support_fn supp1,
@@ -113,6 +117,7 @@ bool GJKDistance(
     Vector3d* p2);
 
 template
+FCL_EXPORT
 bool GJKSignedDistance(
     void* obj1,
     ccd_support_fn supp1,
diff --git a/src/narrowphase/detail/convexity_based_algorithm/minkowski_diff.cpp b/src/narrowphase/detail/convexity_based_algorithm/minkowski_diff.cpp
index af2d711..a8d7742 100644
--- a/src/narrowphase/detail/convexity_based_algorithm/minkowski_diff.cpp
+++ b/src/narrowphase/detail/convexity_based_algorithm/minkowski_diff.cpp
@@ -44,7 +44,7 @@ namespace detail
 {
 
 template
-struct MinkowskiDiff<double>;
+struct FCL_EXPORT MinkowskiDiff<double>;
 
 } // namespace detail
 } // namespace fcl
diff --git a/src/narrowphase/detail/gjk_solver_indep.cpp b/src/narrowphase/detail/gjk_solver_indep.cpp
index 8c17e3a..5e1bee8 100755
--- a/src/narrowphase/detail/gjk_solver_indep.cpp
+++ b/src/narrowphase/detail/gjk_solver_indep.cpp
@@ -44,7 +44,7 @@ namespace detail
 {
 
 template
-struct GJKSolver_indep<double>;
+struct FCL_EXPORT GJKSolver_indep<double>;
 
 } // namespace detail
 } // namespace fcl
diff --git a/src/narrowphase/detail/gjk_solver_libccd.cpp b/src/narrowphase/detail/gjk_solver_libccd.cpp
index e906a06..5811c35 100755
--- a/src/narrowphase/detail/gjk_solver_libccd.cpp
+++ b/src/narrowphase/detail/gjk_solver_libccd.cpp
@@ -44,7 +44,7 @@ namespace detail
 {
 
 template
-struct GJKSolver_libccd<double>;
+struct FCL_EXPORT GJKSolver_libccd<double>;
 
 } // namespace detail
 } // namespace fcl
diff --git a/src/narrowphase/detail/primitive_shape_algorithm/box_box.cpp b/src/narrowphase/detail/primitive_shape_algorithm/box_box.cpp
index aa27182..0a1d7cd 100755
--- a/src/narrowphase/detail/primitive_shape_algorithm/box_box.cpp
+++ b/src/narrowphase/detail/primitive_shape_algorithm/box_box.cpp
@@ -45,20 +45,24 @@ namespace detail
 
 //==============================================================================
 template
+FCL_EXPORT
 void lineClosestApproach(const Vector3<double>& pa, const Vector3<double>& ua,
                          const Vector3<double>& pb, const Vector3<double>& ub,
                          double* alpha, double* beta);
 
 //==============================================================================
 template
+FCL_EXPORT
 int intersectRectQuad2(double h[2], double p[8], double ret[16]);
 
 //==============================================================================
 template
+FCL_EXPORT
 void cullPoints2(int n, double p[], int m, int i0, int iret[]);
 
 //==============================================================================
 template
+FCL_EXPORT
 int boxBox2(
     const Vector3<double>& side1,
     const Transform3<double>& tf1,
@@ -72,6 +76,7 @@ int boxBox2(
 
 //==============================================================================
 template
+FCL_EXPORT
 bool boxBoxIntersect(const Box<double>& s1, const Transform3<double>& tf1,
                      const Box<double>& s2, const Transform3<double>& tf2,
                      std::vector<ContactPoint<double>>* contacts_);
diff --git a/src/narrowphase/detail/primitive_shape_algorithm/capsule_capsule.cpp b/src/narrowphase/detail/primitive_shape_algorithm/capsule_capsule.cpp
index bf72d5c..7806db4 100644
--- a/src/narrowphase/detail/primitive_shape_algorithm/capsule_capsule.cpp
+++ b/src/narrowphase/detail/primitive_shape_algorithm/capsule_capsule.cpp
@@ -45,18 +45,22 @@ namespace detail
 
 //==============================================================================
 template
+FCL_EXPORT
 double clamp(double n, double min, double max);
 
 //==============================================================================
-template double closestPtSegmentSegment(const Vector3d& p_FP1,
-                                        const Vector3d& p_FQ1,
-                                        const Vector3d& p_FP2,
-                                        const Vector3d& p_FQ2, double* s,
-                                        double* t, Vector3d* p_FC1,
-                                        Vector3d* p_FC2);
+template
+FCL_EXPORT
+double closestPtSegmentSegment(const Vector3d& p_FP1,
+                               const Vector3d& p_FQ1,
+                               const Vector3d& p_FP2,
+                               const Vector3d& p_FQ2, double* s,
+                               double* t, Vector3d* p_FC1,
+                               Vector3d* p_FC2);
 
 //==============================================================================
 template
+FCL_EXPORT
 bool capsuleCapsuleDistance(
     const Capsule<double>& s1, const Transform3<double>& tf1,
     const Capsule<double>& s2, const Transform3<double>& tf2,
diff --git a/src/narrowphase/detail/primitive_shape_algorithm/halfspace.cpp b/src/narrowphase/detail/primitive_shape_algorithm/halfspace.cpp
index 045a4da..0daaafc 100755
--- a/src/narrowphase/detail/primitive_shape_algorithm/halfspace.cpp
+++ b/src/narrowphase/detail/primitive_shape_algorithm/halfspace.cpp
@@ -59,6 +59,7 @@ double halfspaceIntersectTolerance()
 
 //==============================================================================
 template
+FCL_EXPORT
 bool sphereHalfspaceIntersect(
     const Sphere<double>& s1, const Transform3<double>& tf1,
     const Halfspace<double>& s2, const Transform3<double>& tf2,
@@ -66,6 +67,7 @@ bool sphereHalfspaceIntersect(
 
 //==============================================================================
 template
+FCL_EXPORT
 bool ellipsoidHalfspaceIntersect(
     const Ellipsoid<double>& s1, const Transform3<double>& tf1,
     const Halfspace<double>& s2, const Transform3<double>& tf2,
@@ -73,12 +75,14 @@ bool ellipsoidHalfspaceIntersect(
 
 //==============================================================================
 template
+FCL_EXPORT
 bool boxHalfspaceIntersect(
     const Box<double>& s1, const Transform3<double>& tf1,
     const Halfspace<double>& s2, const Transform3<double>& tf2);
 
 //==============================================================================
 template
+FCL_EXPORT
 bool boxHalfspaceIntersect(
     const Box<double>& s1, const Transform3<double>& tf1,
     const Halfspace<double>& s2, const Transform3<double>& tf2,
@@ -86,6 +90,7 @@ bool boxHalfspaceIntersect(
 
 //==============================================================================
 template
+FCL_EXPORT
 bool capsuleHalfspaceIntersect(
     const Capsule<double>& s1, const Transform3<double>& tf1,
     const Halfspace<double>& s2, const Transform3<double>& tf2,
@@ -93,6 +98,7 @@ bool capsuleHalfspaceIntersect(
 
 //==============================================================================
 template
+FCL_EXPORT
 bool cylinderHalfspaceIntersect(
     const Cylinder<double>& s1, const Transform3<double>& tf1,
     const Halfspace<double>& s2, const Transform3<double>& tf2,
@@ -100,6 +106,7 @@ bool cylinderHalfspaceIntersect(
 
 //==============================================================================
 template
+FCL_EXPORT
 bool coneHalfspaceIntersect(
     const Cone<double>& s1, const Transform3<double>& tf1,
     const Halfspace<double>& s2, const Transform3<double>& tf2,
@@ -107,6 +114,7 @@ bool coneHalfspaceIntersect(
 
 //==============================================================================
 template
+FCL_EXPORT
 bool convexHalfspaceIntersect(
     const Convex<double>& s1, const Transform3<double>& tf1,
     const Halfspace<double>& s2, const Transform3<double>& tf2,
@@ -114,6 +122,7 @@ bool convexHalfspaceIntersect(
 
 //==============================================================================
 template
+FCL_EXPORT
 bool halfspaceTriangleIntersect(
     const Halfspace<double>& s1, const Transform3<double>& tf1,
     const Vector3<double>& P1, const Vector3<double>& P2, const Vector3<double>& P3, const Transform3<double>& tf2,
@@ -121,6 +130,7 @@ bool halfspaceTriangleIntersect(
 
 //==============================================================================
 template
+FCL_EXPORT
 bool planeHalfspaceIntersect(
     const Plane<double>& s1, const Transform3<double>& tf1,
     const Halfspace<double>& s2, const Transform3<double>& tf2,
@@ -131,6 +141,7 @@ bool planeHalfspaceIntersect(
 
 //==============================================================================
 template
+FCL_EXPORT
 bool halfspacePlaneIntersect(
     const Halfspace<double>& s1, const Transform3<double>& tf1,
     const Plane<double>& s2, const Transform3<double>& tf2,
@@ -140,6 +151,7 @@ bool halfspacePlaneIntersect(
 
 //==============================================================================
 template
+FCL_EXPORT
 bool halfspaceIntersect(
     const Halfspace<double>& s1, const Transform3<double>& tf1,
     const Halfspace<double>& s2, const Transform3<double>& tf2,
diff --git a/src/narrowphase/detail/primitive_shape_algorithm/intersect.cpp b/src/narrowphase/detail/primitive_shape_algorithm/intersect.cpp
index b4d8a22..66e6f75 100644
--- a/src/narrowphase/detail/primitive_shape_algorithm/intersect.cpp
+++ b/src/narrowphase/detail/primitive_shape_algorithm/intersect.cpp
@@ -1,50 +1,50 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#include "fcl/narrowphase/detail/traversal/collision/intersect-inl.h"
-
-namespace fcl
-{
-
-namespace detail
-{
-
-template
-class Intersect<double>;
-
-} // namespace detail
-} // namespace fcl
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#include "fcl/narrowphase/detail/traversal/collision/intersect-inl.h"
+
+namespace fcl
+{
+
+namespace detail
+{
+
+template
+class FCL_EXPORT Intersect<double>;
+
+} // namespace detail
+} // namespace fcl
diff --git a/src/narrowphase/detail/primitive_shape_algorithm/plane.cpp b/src/narrowphase/detail/primitive_shape_algorithm/plane.cpp
index 5cee207..c41829d 100755
--- a/src/narrowphase/detail/primitive_shape_algorithm/plane.cpp
+++ b/src/narrowphase/detail/primitive_shape_algorithm/plane.cpp
@@ -59,64 +59,75 @@ float planeIntersectTolerance()
 
 //==============================================================================
 template
+FCL_EXPORT
 bool spherePlaneIntersect(const Sphere<double>& s1, const Transform3<double>& tf1,
                           const Plane<double>& s2, const Transform3<double>& tf2,
                           std::vector<ContactPoint<double>>* contacts);
 
 //==============================================================================
 template
+FCL_EXPORT
 bool ellipsoidPlaneIntersect(const Ellipsoid<double>& s1, const Transform3<double>& tf1,
                              const Plane<double>& s2, const Transform3<double>& tf2,
                              std::vector<ContactPoint<double>>* contacts);
 
 //==============================================================================
 template
+FCL_EXPORT
 bool boxPlaneIntersect(const Box<double>& s1, const Transform3<double>& tf1,
                        const Plane<double>& s2, const Transform3<double>& tf2,
                        std::vector<ContactPoint<double>>* contacts);
 
 //==============================================================================
 template
+FCL_EXPORT
 bool capsulePlaneIntersect(const Capsule<double>& s1, const Transform3<double>& tf1,
                            const Plane<double>& s2, const Transform3<double>& tf2);
 
 //==============================================================================
 template
+FCL_EXPORT
 bool capsulePlaneIntersect(const Capsule<double>& s1, const Transform3<double>& tf1,
                            const Plane<double>& s2, const Transform3<double>& tf2,
                            std::vector<ContactPoint<double>>* contacts);
 
 //==============================================================================
 template
+FCL_EXPORT
 bool cylinderPlaneIntersect(const Cylinder<double>& s1, const Transform3<double>& tf1,
                             const Plane<double>& s2, const Transform3<double>& tf2);
 
 //==============================================================================
 template
+FCL_EXPORT
 bool cylinderPlaneIntersect(const Cylinder<double>& s1, const Transform3<double>& tf1,
                             const Plane<double>& s2, const Transform3<double>& tf2,
                             std::vector<ContactPoint<double>>* contacts);
 
 //==============================================================================
 template
+FCL_EXPORT
 bool conePlaneIntersect(const Cone<double>& s1, const Transform3<double>& tf1,
                         const Plane<double>& s2, const Transform3<double>& tf2,
                         std::vector<ContactPoint<double>>* contacts);
 
 //==============================================================================
 template
+FCL_EXPORT
 bool convexPlaneIntersect(const Convex<double>& s1, const Transform3<double>& tf1,
                           const Plane<double>& s2, const Transform3<double>& tf2,
                           Vector3<double>* contact_points, double* penetration_depth, Vector3<double>* normal);
 
 //==============================================================================
 template
+FCL_EXPORT
 bool planeTriangleIntersect(const Plane<double>& s1, const Transform3<double>& tf1,
                             const Vector3<double>& P1, const Vector3<double>& P2, const Vector3<double>& P3, const Transform3<double>& tf2,
                             Vector3<double>* contact_points, double* penetration_depth, Vector3<double>* normal);
 
 //==============================================================================
 template
+FCL_EXPORT
 bool planeIntersect(const Plane<double>& s1, const Transform3<double>& tf1,
                     const Plane<double>& s2, const Transform3<double>& tf2,
                     std::vector<ContactPoint<double>>* contacts);
diff --git a/src/narrowphase/detail/primitive_shape_algorithm/sphere_box.cpp b/src/narrowphase/detail/primitive_shape_algorithm/sphere_box.cpp
index 291ad30..6aef051 100644
--- a/src/narrowphase/detail/primitive_shape_algorithm/sphere_box.cpp
+++ b/src/narrowphase/detail/primitive_shape_algorithm/sphere_box.cpp
@@ -43,18 +43,20 @@ namespace detail
 {
 
 //==============================================================================
-template bool
-sphereBoxIntersect(const Sphere<double>& sphere, const Transform3<double>& X_FS,
-                   const Box<double>& box, const Transform3<double>& X_FB,
-                   std::vector<ContactPoint<double>>* contacts);
+template
+FCL_EXPORT
+bool sphereBoxIntersect(const Sphere<double>& sphere, const Transform3<double>& X_FS,
+                        const Box<double>& box, const Transform3<double>& X_FB,
+                        std::vector<ContactPoint<double>>* contacts);
 
 //==============================================================================
 
-template bool
-sphereBoxDistance(const Sphere<double>& sphere, const Transform3<double>& X_FS,
-                  const Box<double>& box, const Transform3<double>& X_FB,
-                  double* distance, Vector3<double>* p_FSb,
-                  Vector3<double>* p_FBs);
+template
+FCL_EXPORT
+bool sphereBoxDistance(const Sphere<double>& sphere, const Transform3<double>& X_FS,
+                       const Box<double>& box, const Transform3<double>& X_FB,
+                       double* distance, Vector3<double>* p_FSb,
+                       Vector3<double>* p_FBs);
 
 } // namespace detail
 } // namespace fcl
diff --git a/src/narrowphase/detail/primitive_shape_algorithm/sphere_capsule.cpp b/src/narrowphase/detail/primitive_shape_algorithm/sphere_capsule.cpp
index 90d553d..5875122 100755
--- a/src/narrowphase/detail/primitive_shape_algorithm/sphere_capsule.cpp
+++ b/src/narrowphase/detail/primitive_shape_algorithm/sphere_capsule.cpp
@@ -45,6 +45,7 @@ namespace detail
 
 //==============================================================================
 template
+FCL_EXPORT
 void lineSegmentPointClosestToPoint(
     const Vector3<double> &p,
     const Vector3<double> &s1,
@@ -53,12 +54,14 @@ void lineSegmentPointClosestToPoint(
 
 //==============================================================================
 template
+FCL_EXPORT
 bool sphereCapsuleIntersect(const Sphere<double>& s1, const Transform3<double>& tf1,
                             const Capsule<double>& s2, const Transform3<double>& tf2,
                             std::vector<ContactPoint<double>>* contacts);
 
 //==============================================================================
 template
+FCL_EXPORT
 bool sphereCapsuleDistance(const Sphere<double>& s1, const Transform3<double>& tf1,
                            const Capsule<double>& s2, const Transform3<double>& tf2,
                            double* dist, Vector3<double>* p1, Vector3<double>* p2);
diff --git a/src/narrowphase/detail/primitive_shape_algorithm/sphere_cylinder.cpp b/src/narrowphase/detail/primitive_shape_algorithm/sphere_cylinder.cpp
index d9e87d5..5035b74 100644
--- a/src/narrowphase/detail/primitive_shape_algorithm/sphere_cylinder.cpp
+++ b/src/narrowphase/detail/primitive_shape_algorithm/sphere_cylinder.cpp
@@ -42,22 +42,24 @@ namespace fcl
 namespace detail
 {
 
-template bool
-sphereCylinderIntersect(const Sphere<double>& sphere,
-                        const Transform3<double>& X_FS,
-                        const Cylinder<double>& cylinder,
-                        const Transform3<double>& X_FC,
-                        std::vector<ContactPoint<double>>* contacts);
+template
+FCL_EXPORT
+bool sphereCylinderIntersect(const Sphere<double>& sphere,
+                             const Transform3<double>& X_FS,
+                             const Cylinder<double>& cylinder,
+                             const Transform3<double>& X_FC,
+                             std::vector<ContactPoint<double>>* contacts);
 
 //==============================================================================
 
-template bool
-sphereCylinderDistance(const Sphere<double>& sphere,
-                       const Transform3<double>& X_FS,
-                       const Cylinder<double>& cylinder,
-                       const Transform3<double>& X_FC,
-                       double* distance, Vector3<double>* p_FSc,
-                       Vector3<double>* p_FCs);
+template
+FCL_EXPORT
+bool sphereCylinderDistance(const Sphere<double>& sphere,
+                            const Transform3<double>& X_FS,
+                            const Cylinder<double>& cylinder,
+                            const Transform3<double>& X_FC,
+                            double* distance, Vector3<double>* p_FSc,
+                            Vector3<double>* p_FCs);
 
 } // namespace detail
 } // namespace fcl
diff --git a/src/narrowphase/detail/primitive_shape_algorithm/sphere_sphere.cpp b/src/narrowphase/detail/primitive_shape_algorithm/sphere_sphere.cpp
index e4e76ec..9d3330f 100755
--- a/src/narrowphase/detail/primitive_shape_algorithm/sphere_sphere.cpp
+++ b/src/narrowphase/detail/primitive_shape_algorithm/sphere_sphere.cpp
@@ -45,12 +45,14 @@ namespace detail
 
 //==============================================================================
 template
+FCL_EXPORT
 bool sphereSphereIntersect(const Sphere<double>& s1, const Transform3<double>& tf1,
                            const Sphere<double>& s2, const Transform3<double>& tf2,
                            std::vector<ContactPoint<double>>* contacts);
 
 //==============================================================================
 template
+FCL_EXPORT
 bool sphereSphereDistance(const Sphere<double>& s1, const Transform3<double>& tf1,
                           const Sphere<double>& s2, const Transform3<double>& tf2,
                           double* dist, Vector3<double>* p1, Vector3<double>* p2);
diff --git a/src/narrowphase/detail/primitive_shape_algorithm/sphere_triangle.cpp b/src/narrowphase/detail/primitive_shape_algorithm/sphere_triangle.cpp
index 29b6173..e5c96f4 100755
--- a/src/narrowphase/detail/primitive_shape_algorithm/sphere_triangle.cpp
+++ b/src/narrowphase/detail/primitive_shape_algorithm/sphere_triangle.cpp
@@ -45,31 +45,37 @@ namespace detail
 
 //==============================================================================
 template
+FCL_EXPORT
 double segmentSqrDistance(const Vector3<double>& from, const Vector3<double>& to,const Vector3<double>& p, Vector3<double>& nearest);
 
 //==============================================================================
 template
+FCL_EXPORT
 bool projectInTriangle(const Vector3<double>& p1, const Vector3<double>& p2, const Vector3<double>& p3, const Vector3<double>& normal, const Vector3<double>& p);
 
 //==============================================================================
 template
+FCL_EXPORT
 bool sphereTriangleIntersect(const Sphere<double>& s, const Transform3<double>& tf,
                              const Vector3<double>& P1, const Vector3<double>& P2, const Vector3<double>& P3, Vector3<double>* contact_points, double* penetration_depth, Vector3<double>* normal_);
 
 //==============================================================================
 template
+FCL_EXPORT
 bool sphereTriangleDistance(const Sphere<double>& sp, const Transform3<double>& tf,
                             const Vector3<double>& P1, const Vector3<double>& P2, const Vector3<double>& P3,
                             double* dist);
 
 //==============================================================================
 template
+FCL_EXPORT
 bool sphereTriangleDistance(const Sphere<double>& sp, const Transform3<double>& tf,
                             const Vector3<double>& P1, const Vector3<double>& P2, const Vector3<double>& P3,
                             double* dist, Vector3<double>* p1, Vector3<double>* p2);
 
 //==============================================================================
 template
+FCL_EXPORT
 bool sphereTriangleDistance(const Sphere<double>& sp, const Transform3<double>& tf1,
                             const Vector3<double>& P1, const Vector3<double>& P2, const Vector3<double>& P3, const Transform3<double>& tf2,
                             double* dist, Vector3<double>* p1, Vector3<double>* p2);
diff --git a/src/narrowphase/detail/primitive_shape_algorithm/triangle_distance.cpp b/src/narrowphase/detail/primitive_shape_algorithm/triangle_distance.cpp
index 2bb3a20..bb6831f 100644
--- a/src/narrowphase/detail/primitive_shape_algorithm/triangle_distance.cpp
+++ b/src/narrowphase/detail/primitive_shape_algorithm/triangle_distance.cpp
@@ -1,51 +1,51 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#include "fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance-inl.h"
-
-namespace fcl
-{
-
-namespace detail
-{
-
-//==============================================================================
-template
-class TriangleDistance<double>;
-
-} // namespace detail
-} // namespace fcl
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#include "fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance-inl.h"
+
+namespace fcl
+{
+
+namespace detail
+{
+
+//==============================================================================
+template
+class FCL_EXPORT TriangleDistance<double>;
+
+} // namespace detail
+} // namespace fcl
diff --git a/src/narrowphase/detail/traversal/collision/collision_traversal_node_base.cpp b/src/narrowphase/detail/traversal/collision/collision_traversal_node_base.cpp
index 89783e3..5532361 100644
--- a/src/narrowphase/detail/traversal/collision/collision_traversal_node_base.cpp
+++ b/src/narrowphase/detail/traversal/collision/collision_traversal_node_base.cpp
@@ -44,7 +44,7 @@ namespace detail
 {
 
 template
-class CollisionTraversalNodeBase<double>;
+class FCL_EXPORT CollisionTraversalNodeBase<double>;
 
 } // namespace detail
 } // namespace fcl
diff --git a/src/narrowphase/detail/traversal/collision/mesh_collision_traversal_node.cpp b/src/narrowphase/detail/traversal/collision/mesh_collision_traversal_node.cpp
index 46d34aa..d9fbbbb 100644
--- a/src/narrowphase/detail/traversal/collision/mesh_collision_traversal_node.cpp
+++ b/src/narrowphase/detail/traversal/collision/mesh_collision_traversal_node.cpp
@@ -45,10 +45,11 @@ namespace detail
 
 //==============================================================================
 template
-class MeshCollisionTraversalNodeOBB<double>;
+class FCL_EXPORT MeshCollisionTraversalNodeOBB<double>;
 
 //==============================================================================
 template
+FCL_EXPORT
 bool initialize(
     MeshCollisionTraversalNodeOBB<double>& node,
     const BVHModel<OBB<double>>& model1,
@@ -60,10 +61,11 @@ bool initialize(
 
 //==============================================================================
 template
-class MeshCollisionTraversalNodeRSS<double>;
+class FCL_EXPORT MeshCollisionTraversalNodeRSS<double>;
 
 //==============================================================================
 template
+FCL_EXPORT
 bool initialize(
     MeshCollisionTraversalNodeRSS<double>& node,
     const BVHModel<RSS<double>>& model1,
@@ -75,10 +77,11 @@ bool initialize(
 
 //==============================================================================
 template
-class MeshCollisionTraversalNodekIOS<double>;
+class FCL_EXPORT MeshCollisionTraversalNodekIOS<double>;
 
 //==============================================================================
 template
+FCL_EXPORT
 bool initialize(
     MeshCollisionTraversalNodekIOS<double>& node,
     const BVHModel<kIOS<double>>& model1,
@@ -90,10 +93,11 @@ bool initialize(
 
 //==============================================================================
 template
-class MeshCollisionTraversalNodeOBBRSS<double>;
+class FCL_EXPORT MeshCollisionTraversalNodeOBBRSS<double>;
 
 //==============================================================================
 template
+FCL_EXPORT
 bool initialize(
     MeshCollisionTraversalNodeOBBRSS<double>& node,
     const BVHModel<OBBRSS<double>>& model1,
diff --git a/src/narrowphase/detail/traversal/collision/mesh_continuous_collision_traversal_node.cpp b/src/narrowphase/detail/traversal/collision/mesh_continuous_collision_traversal_node.cpp
index d34c701..1fff836 100644
--- a/src/narrowphase/detail/traversal/collision/mesh_continuous_collision_traversal_node.cpp
+++ b/src/narrowphase/detail/traversal/collision/mesh_continuous_collision_traversal_node.cpp
@@ -44,7 +44,7 @@ namespace detail
 {
 
 template
-struct BVHContinuousCollisionPair<double>;
+struct FCL_EXPORT BVHContinuousCollisionPair<double>;
 
 } // namespace detail
 } // namespace fcl
diff --git a/src/narrowphase/detail/traversal/collision_node.cpp b/src/narrowphase/detail/traversal/collision_node.cpp
index 352cd40..0da3dc9 100644
--- a/src/narrowphase/detail/traversal/collision_node.cpp
+++ b/src/narrowphase/detail/traversal/collision_node.cpp
@@ -45,22 +45,27 @@ namespace detail
 
 //==============================================================================
 template
+FCL_EXPORT
 void collide(CollisionTraversalNodeBase<double>* node, BVHFrontList* front_list);
 
 //==============================================================================
 template
+FCL_EXPORT
 void selfCollide(CollisionTraversalNodeBase<double>* node, BVHFrontList* front_list);
 
 //==============================================================================
 template
+FCL_EXPORT
 void distance(DistanceTraversalNodeBase<double>* node, BVHFrontList* front_list, int qsize);
 
 //==============================================================================
 template
+FCL_EXPORT
 void collide2(MeshCollisionTraversalNodeOBB<double>* node, BVHFrontList* front_list);
 
 //==============================================================================
 template
+FCL_EXPORT
 void collide2(MeshCollisionTraversalNodeRSS<double>* node, BVHFrontList* front_list);
 
 } // namespace detail
diff --git a/src/narrowphase/detail/traversal/distance/conservative_advancement_stack_data.cpp b/src/narrowphase/detail/traversal/distance/conservative_advancement_stack_data.cpp
index b2501b6..12f1a22 100644
--- a/src/narrowphase/detail/traversal/distance/conservative_advancement_stack_data.cpp
+++ b/src/narrowphase/detail/traversal/distance/conservative_advancement_stack_data.cpp
@@ -44,7 +44,7 @@ namespace detail
 {
 
 template
-struct ConservativeAdvancementStackData<double>;
+struct FCL_EXPORT ConservativeAdvancementStackData<double>;
 
 } // namespace detail
 } // namespace fcl
diff --git a/src/narrowphase/detail/traversal/distance/distance_traversal_node_base.cpp b/src/narrowphase/detail/traversal/distance/distance_traversal_node_base.cpp
index b6cca49..66e9e05 100644
--- a/src/narrowphase/detail/traversal/distance/distance_traversal_node_base.cpp
+++ b/src/narrowphase/detail/traversal/distance/distance_traversal_node_base.cpp
@@ -44,7 +44,7 @@ namespace detail
 {
 
 template
-class DistanceTraversalNodeBase<double>;
+class FCL_EXPORT DistanceTraversalNodeBase<double>;
 
 } // namespace detail
 } // namespace fcl
diff --git a/src/narrowphase/detail/traversal/distance/mesh_conservative_advancement_traversal_node.cpp b/src/narrowphase/detail/traversal/distance/mesh_conservative_advancement_traversal_node.cpp
index ed7d8cc..fb511d8 100644
--- a/src/narrowphase/detail/traversal/distance/mesh_conservative_advancement_traversal_node.cpp
+++ b/src/narrowphase/detail/traversal/distance/mesh_conservative_advancement_traversal_node.cpp
@@ -45,10 +45,11 @@ namespace detail
 
 //==============================================================================
 template
-class MeshConservativeAdvancementTraversalNodeRSS<double>;
+class FCL_EXPORT MeshConservativeAdvancementTraversalNodeRSS<double>;
 
 //==============================================================================
 template
+FCL_EXPORT
 bool initialize(
     MeshConservativeAdvancementTraversalNodeRSS<double>& node,
     const BVHModel<RSS<double>>& model1,
@@ -59,10 +60,11 @@ bool initialize(
 
 //==============================================================================
 template
-class MeshConservativeAdvancementTraversalNodeOBBRSS<double>;
+class FCL_EXPORT MeshConservativeAdvancementTraversalNodeOBBRSS<double>;
 
 //==============================================================================
 template
+FCL_EXPORT
 bool initialize(
     MeshConservativeAdvancementTraversalNodeOBBRSS<double>& node,
     const BVHModel<OBBRSS<double>>& model1,
diff --git a/src/narrowphase/detail/traversal/distance/mesh_distance_traversal_node.cpp b/src/narrowphase/detail/traversal/distance/mesh_distance_traversal_node.cpp
index 7d862c1..103137b 100644
--- a/src/narrowphase/detail/traversal/distance/mesh_distance_traversal_node.cpp
+++ b/src/narrowphase/detail/traversal/distance/mesh_distance_traversal_node.cpp
@@ -45,10 +45,11 @@ namespace detail
 
 //==============================================================================
 template
-class MeshDistanceTraversalNodeRSS<double>;
+class FCL_EXPORT MeshDistanceTraversalNodeRSS<double>;
 
 //==============================================================================
 template
+FCL_EXPORT
 bool initialize(
     MeshDistanceTraversalNodeRSS<double>& node,
     const BVHModel<RSS<double>>& model1,
@@ -60,10 +61,11 @@ bool initialize(
 
 //==============================================================================
 template
-class MeshDistanceTraversalNodekIOS<double>;
+class FCL_EXPORT MeshDistanceTraversalNodekIOS<double>;
 
 //==============================================================================
 template
+FCL_EXPORT
 bool initialize(
     MeshDistanceTraversalNodekIOS<double>& node,
     const BVHModel<kIOS<double>>& model1,
@@ -75,10 +77,11 @@ bool initialize(
 
 //==============================================================================
 template
-class MeshDistanceTraversalNodeOBBRSS<double>;
+class FCL_EXPORT MeshDistanceTraversalNodeOBBRSS<double>;
 
 //==============================================================================
 template
+FCL_EXPORT
 bool initialize(
     MeshDistanceTraversalNodeOBBRSS<double>& node,
     const BVHModel<OBBRSS<double>>& model1,
diff --git a/src/narrowphase/detail/traversal/traversal_node_base.cpp b/src/narrowphase/detail/traversal/traversal_node_base.cpp
index 4a11aaf..207722e 100644
--- a/src/narrowphase/detail/traversal/traversal_node_base.cpp
+++ b/src/narrowphase/detail/traversal/traversal_node_base.cpp
@@ -44,7 +44,7 @@ namespace detail
 {
 
 template
-class TraversalNodeBase<double>;
+class FCL_EXPORT TraversalNodeBase<double>;
 
 } // namespace detail
 } // namespace fcl
diff --git a/src/narrowphase/detail/traversal/traversal_recurse.cpp b/src/narrowphase/detail/traversal/traversal_recurse.cpp
index a382a32..fa15797 100644
--- a/src/narrowphase/detail/traversal/traversal_recurse.cpp
+++ b/src/narrowphase/detail/traversal/traversal_recurse.cpp
@@ -45,30 +45,37 @@ namespace detail
 
 //==============================================================================
 template
+FCL_EXPORT
 void collisionRecurse(CollisionTraversalNodeBase<double>* node, int b1, int b2, BVHFrontList* front_list);
 
 //==============================================================================
 template
+FCL_EXPORT
 void collisionRecurse(MeshCollisionTraversalNodeOBB<double>* node, int b1, int b2, const Matrix3<double>& R, const Vector3<double>& T, BVHFrontList* front_list);
 
 //==============================================================================
 template
+FCL_EXPORT
 void collisionRecurse(MeshCollisionTraversalNodeRSS<double>* node, int b1, int b2, const Matrix3<double>& R, const Vector3<double>& T, BVHFrontList* front_list);
 
 //==============================================================================
 template
+FCL_EXPORT
 void selfCollisionRecurse(CollisionTraversalNodeBase<double>* node, int b, BVHFrontList* front_list);
 
 //==============================================================================
 template
+FCL_EXPORT
 void distanceRecurse(DistanceTraversalNodeBase<double>* node, int b1, int b2, BVHFrontList* front_list);
 
 //==============================================================================
 template
+FCL_EXPORT
 void distanceQueueRecurse(DistanceTraversalNodeBase<double>* node, int b1, int b2, BVHFrontList* front_list, int qsize);
 
 //==============================================================================
 template
+FCL_EXPORT
 void propagateBVHFrontListCollisionRecurse(CollisionTraversalNodeBase<double>* node, BVHFrontList* front_list);
 
 } // namespace detail
diff --git a/src/narrowphase/distance.cpp b/src/narrowphase/distance.cpp
index 5ef7dc6..2129a34 100644
--- a/src/narrowphase/distance.cpp
+++ b/src/narrowphase/distance.cpp
@@ -42,6 +42,7 @@ namespace fcl
 
 //==============================================================================
 template
+FCL_EXPORT
 double distance(
     const CollisionObject<double>* o1,
     const CollisionObject<double>* o2,
@@ -50,6 +51,7 @@ double distance(
 
 //==============================================================================
 template
+FCL_EXPORT
 double distance(
     const CollisionGeometry<double>* o1, const Transform3<double>& tf1,
     const CollisionGeometry<double>* o2, const Transform3<double>& tf2,
diff --git a/src/narrowphase/distance_request.cpp b/src/narrowphase/distance_request.cpp
index e694013..f9c631a 100644
--- a/src/narrowphase/distance_request.cpp
+++ b/src/narrowphase/distance_request.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-struct DistanceRequest<double>;
+struct FCL_EXPORT DistanceRequest<double>;
 
 } // namespace fcl
diff --git a/src/narrowphase/distance_result.cpp b/src/narrowphase/distance_result.cpp
index 1fefd21..48307f1 100644
--- a/src/narrowphase/distance_result.cpp
+++ b/src/narrowphase/distance_result.cpp
@@ -41,6 +41,6 @@ namespace fcl
 {
 
 template
-struct DistanceResult<double>;
+struct FCL_EXPORT DistanceResult<double>;
 
 } // namespace fcl
